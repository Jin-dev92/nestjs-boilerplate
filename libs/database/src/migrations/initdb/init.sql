create database playground
    with owner kpasd002;

-- Unknown how to generate base type type

comment on type pg_catalog.bool is 'boolean, ''true''/''false''';

alter type pg_catalog.bool owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.bytea is 'variable-length string, binary values escaped';

alter type pg_catalog.bytea owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.char is 'single character';

alter type pg_catalog.char owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.name is '63-byte type for storing system identifiers';

alter type pg_catalog.name owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.int8 is '~18 digit integer, 8-byte storage';

alter type pg_catalog.int8 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.int2 is '-32 thousand to 32 thousand, 2-byte storage';

alter type pg_catalog.int2 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.int4 is '-2 billion to 2 billion integer, 4-byte storage';

alter type pg_catalog.int4 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regproc is 'registered procedure';

alter type pg_catalog.regproc owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.text is 'variable-length string, no limit specified';

alter type pg_catalog.text owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.oid is 'object identifier(oid), maximum 4 billion';

alter type pg_catalog.oid owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.tid is '(block, offset), physical location of tuple';

alter type pg_catalog.tid owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.xid is 'transaction id';

alter type pg_catalog.xid owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.cid is 'command identifier type, sequence in transaction id';

alter type pg_catalog.cid owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.json is 'JSON stored as text';

alter type pg_catalog.json owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.xml is 'XML content';

alter type pg_catalog.xml owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_node_tree is 'string representing an internal node tree';

alter type pg_catalog.pg_node_tree owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.point is 'geometric point ''(x, y)''';

alter type pg_catalog.point owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.lseg is 'geometric line segment ''(pt1,pt2)''';

alter type pg_catalog.lseg owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.path is 'geometric path ''(pt1,...)''';

alter type pg_catalog.path owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.box is 'geometric box ''(lower left,upper right)''';

alter type pg_catalog.box owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.polygon is 'geometric polygon ''(pt1,...)''';

alter type pg_catalog.polygon owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.line is 'geometric line';

alter type pg_catalog.line owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.cidr is 'network IP address/netmask, network address';

alter type pg_catalog.cidr owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.float4 is 'single-precision floating point number, 4-byte storage';

alter type pg_catalog.float4 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.float8 is 'double-precision floating point number, 8-byte storage';

alter type pg_catalog.float8 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.circle is 'geometric circle ''(center,radius)''';

alter type pg_catalog.circle owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr8 is 'XX:XX:XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr8 owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.money is 'monetary amounts, $d,ddd.cc';

alter type pg_catalog.money owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.macaddr is 'XX:XX:XX:XX:XX:XX, MAC address';

alter type pg_catalog.macaddr owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.inet is 'IP address/netmask, host address, netmask optional';

alter type pg_catalog.inet owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.aclitem is 'access control list';

alter type pg_catalog.aclitem owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.bpchar is 'char(length), blank-padded string, fixed storage length';

alter type pg_catalog.bpchar owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.varchar is 'varchar(length), non-blank-padded string, variable storage length';

alter type pg_catalog.varchar owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.date is 'date';

alter type pg_catalog.date owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.time is 'time of day';

alter type pg_catalog.time owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.timestamp is 'date and time';

alter type pg_catalog.timestamp owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.timestamptz is 'date and time with time zone';

alter type pg_catalog.timestamptz owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.interval is '@ <number> <units>, time interval';

alter type pg_catalog.interval owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.timetz is 'time of day with time zone';

alter type pg_catalog.timetz owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.bit is 'fixed-length bit string';

alter type pg_catalog.bit owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.varbit is 'variable-length bit string';

alter type pg_catalog.varbit owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.numeric is 'numeric(precision, decimal), arbitrary precision number';

alter type pg_catalog.numeric owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.refcursor is 'reference to cursor (portal name)';

alter type pg_catalog.refcursor owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regprocedure is 'registered procedure (with args)';

alter type pg_catalog.regprocedure owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regoper is 'registered operator';

alter type pg_catalog.regoper owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regoperator is 'registered operator (with args)';

alter type pg_catalog.regoperator owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regclass is 'registered class';

alter type pg_catalog.regclass owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regtype is 'registered type';

alter type pg_catalog.regtype owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.uuid is 'UUID datatype';

alter type pg_catalog.uuid owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.txid_snapshot is 'txid snapshot';

alter type pg_catalog.txid_snapshot owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_lsn is 'PostgreSQL LSN datatype';

alter type pg_catalog.pg_lsn owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_ndistinct is 'multivariate ndistinct coefficients';

alter type pg_catalog.pg_ndistinct owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_dependencies is 'multivariate dependencies';

alter type pg_catalog.pg_dependencies owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.tsvector is 'text representation for text search';

alter type pg_catalog.tsvector owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.tsquery is 'query representation for text search';

alter type pg_catalog.tsquery owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.gtsvector is 'GiST index internal text representation for text search';

alter type pg_catalog.gtsvector owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regconfig is 'registered text search configuration';

alter type pg_catalog.regconfig owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regdictionary is 'registered text search dictionary';

alter type pg_catalog.regdictionary owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.jsonb is 'Binary JSON';

alter type pg_catalog.jsonb owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.jsonpath is 'JSON path';

alter type pg_catalog.jsonpath owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regnamespace is 'registered namespace';

alter type pg_catalog.regnamespace owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regrole is 'registered role';

alter type pg_catalog.regrole owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.regcollation is 'registered collation';

alter type pg_catalog.regcollation owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_brin_bloom_summary is 'BRIN bloom summary';

alter type pg_catalog.pg_brin_bloom_summary owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_brin_minmax_multi_summary is 'BRIN minmax-multi summary';

alter type pg_catalog.pg_brin_minmax_multi_summary owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_mcv_list is 'multivariate MCV list';

alter type pg_catalog.pg_mcv_list owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.pg_snapshot is 'snapshot';

alter type pg_catalog.pg_snapshot owner to "kim-uijin";

-- Unknown how to generate base type type

comment on type pg_catalog.xid8 is 'full transaction id';

alter type pg_catalog.xid8 owner to "kim-uijin";

create domain information_schema.cardinal_number as integer
    constraint cardinal_number_domain_check check (VALUE >= 0);

alter domain information_schema.cardinal_number owner to "kim-uijin";

create domain information_schema.character_data as varchar;

alter domain information_schema.character_data owner to "kim-uijin";

create domain information_schema.sql_identifier as name;

alter domain information_schema.sql_identifier owner to "kim-uijin";

create domain information_schema.time_stamp as timestamp(2) with time zone
    default CURRENT_TIMESTAMP(2);

alter domain information_schema.time_stamp owner to "kim-uijin";

create domain information_schema.yes_or_no as varchar(3)
    constraint yes_or_no_check check ((VALUE)::text = ANY
                                      ((ARRAY ['YES'::character varying, 'NO'::character varying])::text[]));

alter domain information_schema.yes_or_no owner to "kim-uijin";

create type public.user_auth_role_enum as enum ('ADMIN', 'USER');

alter type public.user_auth_role_enum owner to kpasd002;

create table pg_catalog.pg_default_acl
(
    oid             oid       not null
        constraint pg_default_acl_oid_index
            primary key,
    defaclrole      oid       not null,
    defaclnamespace oid       not null,
    defaclobjtype   "char"    not null,
    defaclacl       aclitem[] not null,
    constraint pg_default_acl_role_nsp_obj_index
        unique (defaclrole, defaclnamespace, defaclobjtype)
);

alter table pg_catalog.pg_default_acl
    owner to "kim-uijin";

grant select on pg_catalog.pg_default_acl to public;

create table pg_catalog.pg_tablespace
(
    oid        oid  not null
        constraint pg_tablespace_oid_index
            primary key,
    spcname    name not null
        constraint pg_tablespace_spcname_index
            unique,
    spcowner   oid  not null,
    spcacl     aclitem[],
    spcoptions text[]
)
    tablespace pg_global;

alter table pg_catalog.pg_tablespace
    owner to "kim-uijin";

grant select on pg_catalog.pg_tablespace to public;

create table pg_catalog.pg_shdepend
(
    dbid       oid     not null,
    classid    oid     not null,
    objid      oid     not null,
    objsubid   integer not null,
    refclassid oid     not null,
    refobjid   oid     not null,
    deptype    "char"  not null
)
    tablespace pg_global;

alter table pg_catalog.pg_shdepend
    owner to "kim-uijin";

create index pg_shdepend_depender_index
    on pg_catalog.pg_shdepend (dbid, classid, objid, objsubid)
    tablespace pg_global;

create index pg_shdepend_reference_index
    on pg_catalog.pg_shdepend (refclassid, refobjid)
    tablespace pg_global;

grant select on pg_catalog.pg_shdepend to public;

create table pg_catalog.pg_type
(
    oid            oid      not null
        constraint pg_type_oid_index
            primary key,
    typname        name     not null,
    typnamespace   oid      not null,
    typowner       oid      not null,
    typlen         smallint not null,
    typbyval       boolean  not null,
    typtype        "char"   not null,
    typcategory    "char"   not null,
    typispreferred boolean  not null,
    typisdefined   boolean  not null,
    typdelim       "char"   not null,
    typrelid       oid      not null,
    typsubscript   regproc  not null,
    typelem        oid      not null,
    typarray       oid      not null,
    typinput       regproc  not null,
    typoutput      regproc  not null,
    typreceive     regproc  not null,
    typsend        regproc  not null,
    typmodin       regproc  not null,
    typmodout      regproc  not null,
    typanalyze     regproc  not null,
    typalign       "char"   not null,
    typstorage     "char"   not null,
    typnotnull     boolean  not null,
    typbasetype    oid      not null,
    typtypmod      integer  not null,
    typndims       integer  not null,
    typcollation   oid      not null,
    typdefaultbin  pg_node_tree,
    typdefault     text,
    typacl         aclitem[],
    constraint pg_type_typname_nsp_index
        unique (typname, typnamespace)
);

alter table pg_catalog.pg_type
    owner to "kim-uijin";

grant select on pg_catalog.pg_type to public;

create table pg_catalog.pg_attribute
(
    attrelid       oid      not null,
    attname        name     not null,
    atttypid       oid      not null,
    attstattarget  integer  not null,
    attlen         smallint not null,
    attnum         smallint not null,
    attndims       integer  not null,
    attcacheoff    integer  not null,
    atttypmod      integer  not null,
    attbyval       boolean  not null,
    attalign       "char"   not null,
    attstorage     "char"   not null,
    attcompression "char"   not null,
    attnotnull     boolean  not null,
    atthasdef      boolean  not null,
    atthasmissing  boolean  not null,
    attidentity    "char"   not null,
    attgenerated   "char"   not null,
    attisdropped   boolean  not null,
    attislocal     boolean  not null,
    attinhcount    integer  not null,
    attcollation   oid      not null,
    attacl         aclitem[],
    attoptions     text[],
    attfdwoptions  text[],
    attmissingval  anyarray,
    constraint pg_attribute_relid_attnum_index
        primary key (attrelid, attnum),
    constraint pg_attribute_relid_attnam_index
        unique (attrelid, attname)
);

alter table pg_catalog.pg_attribute
    owner to "kim-uijin";

grant select on pg_catalog.pg_attribute to public;

create table pg_catalog.pg_proc
(
    oid             oid       not null
        constraint pg_proc_oid_index
            primary key,
    proname         name      not null,
    pronamespace    oid       not null,
    proowner        oid       not null,
    prolang         oid       not null,
    procost         real      not null,
    prorows         real      not null,
    provariadic     oid       not null,
    prosupport      regproc   not null,
    prokind         "char"    not null,
    prosecdef       boolean   not null,
    proleakproof    boolean   not null,
    proisstrict     boolean   not null,
    proretset       boolean   not null,
    provolatile     "char"    not null,
    proparallel     "char"    not null,
    pronargs        smallint  not null,
    pronargdefaults smallint  not null,
    prorettype      oid       not null,
    proargtypes     oidvector not null,
    proallargtypes  oid[],
    proargmodes     "char"[],
    proargnames     text[],
    proargdefaults  pg_node_tree,
    protrftypes     oid[],
    prosrc          text      not null,
    probin          text,
    prosqlbody      pg_node_tree,
    proconfig       text[],
    proacl          aclitem[],
    constraint pg_proc_proname_args_nsp_index
        unique (proname, proargtypes, pronamespace)
);

alter table pg_catalog.pg_proc
    owner to "kim-uijin";

grant select on pg_catalog.pg_proc to public;

create table pg_catalog.pg_class
(
    oid                 oid      not null
        constraint pg_class_oid_index
            primary key,
    relname             name     not null,
    relnamespace        oid      not null,
    reltype             oid      not null,
    reloftype           oid      not null,
    relowner            oid      not null,
    relam               oid      not null,
    relfilenode         oid      not null,
    reltablespace       oid      not null,
    relpages            integer  not null,
    reltuples           real     not null,
    relallvisible       integer  not null,
    reltoastrelid       oid      not null,
    relhasindex         boolean  not null,
    relisshared         boolean  not null,
    relpersistence      "char"   not null,
    relkind             "char"   not null,
    relnatts            smallint not null,
    relchecks           smallint not null,
    relhasrules         boolean  not null,
    relhastriggers      boolean  not null,
    relhassubclass      boolean  not null,
    relrowsecurity      boolean  not null,
    relforcerowsecurity boolean  not null,
    relispopulated      boolean  not null,
    relreplident        "char"   not null,
    relispartition      boolean  not null,
    relrewrite          oid      not null,
    relfrozenxid        xid      not null,
    relminmxid          xid      not null,
    relacl              aclitem[],
    reloptions          text[],
    relpartbound        pg_node_tree,
    constraint pg_class_relname_nsp_index
        unique (relname, relnamespace)
);

alter table pg_catalog.pg_class
    owner to "kim-uijin";

create index pg_class_tblspc_relfilenode_index
    on pg_catalog.pg_class (reltablespace, relfilenode);

grant select on pg_catalog.pg_class to public;

create table pg_catalog.pg_authid
(
    oid            oid     not null
        constraint pg_authid_oid_index
            primary key,
    rolname        name    not null
        constraint pg_authid_rolname_index
            unique,
    rolsuper       boolean not null,
    rolinherit     boolean not null,
    rolcreaterole  boolean not null,
    rolcreatedb    boolean not null,
    rolcanlogin    boolean not null,
    rolreplication boolean not null,
    rolbypassrls   boolean not null,
    rolconnlimit   integer not null,
    rolpassword    text,
    rolvaliduntil  timestamp with time zone
)
    tablespace pg_global;

alter table pg_catalog.pg_authid
    owner to "kim-uijin";

create table pg_catalog.pg_auth_members
(
    roleid       oid     not null,
    member       oid     not null,
    grantor      oid     not null,
    admin_option boolean not null,
    constraint pg_auth_members_role_member_index
        primary key (roleid, member),
    constraint pg_auth_members_member_role_index
        unique (member, roleid)
)
    tablespace pg_global;

alter table pg_catalog.pg_auth_members
    owner to "kim-uijin";

grant select on pg_catalog.pg_auth_members to public;

create table pg_catalog.pg_database
(
    oid           oid     not null
        constraint pg_database_oid_index
            primary key,
    datname       name    not null
        constraint pg_database_datname_index
            unique,
    datdba        oid     not null,
    encoding      integer not null,
    datcollate    name    not null,
    datctype      name    not null,
    datistemplate boolean not null,
    datallowconn  boolean not null,
    datconnlimit  integer not null,
    datlastsysoid oid     not null,
    datfrozenxid  xid     not null,
    datminmxid    xid     not null,
    dattablespace oid     not null,
    datacl        aclitem[]
)
    tablespace pg_global;

alter table pg_catalog.pg_database
    owner to "kim-uijin";

grant select on pg_catalog.pg_database to public;

create table pg_catalog.pg_foreign_server
(
    oid        oid  not null
        constraint pg_foreign_server_oid_index
            primary key,
    srvname    name not null
        constraint pg_foreign_server_name_index
            unique,
    srvowner   oid  not null,
    srvfdw     oid  not null,
    srvtype    text,
    srvversion text,
    srvacl     aclitem[],
    srvoptions text[]
);

alter table pg_catalog.pg_foreign_server
    owner to "kim-uijin";

grant select on pg_catalog.pg_foreign_server to public;

create table pg_catalog.pg_user_mapping
(
    oid       oid not null
        constraint pg_user_mapping_oid_index
            primary key,
    umuser    oid not null,
    umserver  oid not null,
    umoptions text[],
    constraint pg_user_mapping_user_server_index
        unique (umuser, umserver)
);

alter table pg_catalog.pg_user_mapping
    owner to "kim-uijin";

create table pg_catalog.pg_sequence
(
    seqrelid     oid     not null
        constraint pg_sequence_seqrelid_index
            primary key,
    seqtypid     oid     not null,
    seqstart     bigint  not null,
    seqincrement bigint  not null,
    seqmax       bigint  not null,
    seqmin       bigint  not null,
    seqcache     bigint  not null,
    seqcycle     boolean not null
);

alter table pg_catalog.pg_sequence
    owner to "kim-uijin";

grant select on pg_catalog.pg_sequence to public;

create table pg_catalog.pg_foreign_data_wrapper
(
    oid          oid  not null
        constraint pg_foreign_data_wrapper_oid_index
            primary key,
    fdwname      name not null
        constraint pg_foreign_data_wrapper_name_index
            unique,
    fdwowner     oid  not null,
    fdwhandler   oid  not null,
    fdwvalidator oid  not null,
    fdwacl       aclitem[],
    fdwoptions   text[]
);

alter table pg_catalog.pg_foreign_data_wrapper
    owner to "kim-uijin";

grant select on pg_catalog.pg_foreign_data_wrapper to public;

create table pg_catalog.pg_shdescription
(
    objoid      oid  not null,
    classoid    oid  not null,
    description text not null,
    constraint pg_shdescription_o_c_index
        primary key (objoid, classoid)
)
    tablespace pg_global;

alter table pg_catalog.pg_shdescription
    owner to "kim-uijin";

grant select on pg_catalog.pg_shdescription to public;

create table pg_catalog.pg_aggregate
(
    aggfnoid         regproc  not null
        constraint pg_aggregate_fnoid_index
            primary key,
    aggkind          "char"   not null,
    aggnumdirectargs smallint not null,
    aggtransfn       regproc  not null,
    aggfinalfn       regproc  not null,
    aggcombinefn     regproc  not null,
    aggserialfn      regproc  not null,
    aggdeserialfn    regproc  not null,
    aggmtransfn      regproc  not null,
    aggminvtransfn   regproc  not null,
    aggmfinalfn      regproc  not null,
    aggfinalextra    boolean  not null,
    aggmfinalextra   boolean  not null,
    aggfinalmodify   "char"   not null,
    aggmfinalmodify  "char"   not null,
    aggsortop        oid      not null,
    aggtranstype     oid      not null,
    aggtransspace    integer  not null,
    aggmtranstype    oid      not null,
    aggmtransspace   integer  not null,
    agginitval       text,
    aggminitval      text
);

alter table pg_catalog.pg_aggregate
    owner to "kim-uijin";

grant select on pg_catalog.pg_aggregate to public;

create table pg_catalog.pg_am
(
    oid       oid     not null
        constraint pg_am_oid_index
            primary key,
    amname    name    not null
        constraint pg_am_name_index
            unique,
    amhandler regproc not null,
    amtype    "char"  not null
);

alter table pg_catalog.pg_am
    owner to "kim-uijin";

grant select on pg_catalog.pg_am to public;

create table pg_catalog.pg_amop
(
    oid            oid      not null
        constraint pg_amop_oid_index
            primary key,
    amopfamily     oid      not null,
    amoplefttype   oid      not null,
    amoprighttype  oid      not null,
    amopstrategy   smallint not null,
    amoppurpose    "char"   not null,
    amopopr        oid      not null,
    amopmethod     oid      not null,
    amopsortfamily oid      not null,
    constraint pg_amop_fam_strat_index
        unique (amopfamily, amoplefttype, amoprighttype, amopstrategy),
    constraint pg_amop_opr_fam_index
        unique (amopopr, amoppurpose, amopfamily)
);

alter table pg_catalog.pg_amop
    owner to "kim-uijin";

grant select on pg_catalog.pg_amop to public;

create table pg_catalog.pg_amproc
(
    oid             oid      not null
        constraint pg_amproc_oid_index
            primary key,
    amprocfamily    oid      not null,
    amproclefttype  oid      not null,
    amprocrighttype oid      not null,
    amprocnum       smallint not null,
    amproc          regproc  not null,
    constraint pg_amproc_fam_proc_index
        unique (amprocfamily, amproclefttype, amprocrighttype, amprocnum)
);

alter table pg_catalog.pg_amproc
    owner to "kim-uijin";

grant select on pg_catalog.pg_amproc to public;

create table pg_catalog.pg_attrdef
(
    oid     oid          not null
        constraint pg_attrdef_oid_index
            primary key,
    adrelid oid          not null,
    adnum   smallint     not null,
    adbin   pg_node_tree not null,
    constraint pg_attrdef_adrelid_adnum_index
        unique (adrelid, adnum)
);

alter table pg_catalog.pg_attrdef
    owner to "kim-uijin";

grant select on pg_catalog.pg_attrdef to public;

create table pg_catalog.pg_cast
(
    oid         oid    not null
        constraint pg_cast_oid_index
            primary key,
    castsource  oid    not null,
    casttarget  oid    not null,
    castfunc    oid    not null,
    castcontext "char" not null,
    castmethod  "char" not null,
    constraint pg_cast_source_target_index
        unique (castsource, casttarget)
);

alter table pg_catalog.pg_cast
    owner to "kim-uijin";

grant select on pg_catalog.pg_cast to public;

create table pg_catalog.pg_constraint
(
    oid           oid     not null
        constraint pg_constraint_oid_index
            primary key,
    conname       name    not null,
    connamespace  oid     not null,
    contype       "char"  not null,
    condeferrable boolean not null,
    condeferred   boolean not null,
    convalidated  boolean not null,
    conrelid      oid     not null,
    contypid      oid     not null,
    conindid      oid     not null,
    conparentid   oid     not null,
    confrelid     oid     not null,
    confupdtype   "char"  not null,
    confdeltype   "char"  not null,
    confmatchtype "char"  not null,
    conislocal    boolean not null,
    coninhcount   integer not null,
    connoinherit  boolean not null,
    conkey        smallint[],
    confkey       smallint[],
    conpfeqop     oid[],
    conppeqop     oid[],
    conffeqop     oid[],
    conexclop     oid[],
    conbin        pg_node_tree,
    constraint pg_constraint_conrelid_contypid_conname_index
        unique (conrelid, contypid, conname)
);

alter table pg_catalog.pg_constraint
    owner to "kim-uijin";

create index pg_constraint_conparentid_index
    on pg_catalog.pg_constraint (conparentid);

create index pg_constraint_conname_nsp_index
    on pg_catalog.pg_constraint (conname collate "C", connamespace);

create index pg_constraint_contypid_index
    on pg_catalog.pg_constraint (contypid);

grant select on pg_catalog.pg_constraint to public;

create table pg_catalog.pg_conversion
(
    oid            oid     not null
        constraint pg_conversion_oid_index
            primary key,
    conname        name    not null,
    connamespace   oid     not null,
    conowner       oid     not null,
    conforencoding integer not null,
    contoencoding  integer not null,
    conproc        regproc not null,
    condefault     boolean not null,
    constraint pg_conversion_default_index
        unique (connamespace, conforencoding, contoencoding, oid),
    constraint pg_conversion_name_nsp_index
        unique (conname, connamespace)
);

alter table pg_catalog.pg_conversion
    owner to "kim-uijin";

grant select on pg_catalog.pg_conversion to public;

create table pg_catalog.pg_depend
(
    classid     oid     not null,
    objid       oid     not null,
    objsubid    integer not null,
    refclassid  oid     not null,
    refobjid    oid     not null,
    refobjsubid integer not null,
    deptype     "char"  not null
);

alter table pg_catalog.pg_depend
    owner to "kim-uijin";

create index pg_depend_depender_index
    on pg_catalog.pg_depend (classid, objid, objsubid);

create index pg_depend_reference_index
    on pg_catalog.pg_depend (refclassid, refobjid, refobjsubid);

grant select on pg_catalog.pg_depend to public;

create table pg_catalog.pg_description
(
    objoid      oid     not null,
    classoid    oid     not null,
    objsubid    integer not null,
    description text    not null,
    constraint pg_description_o_c_o_index
        primary key (objoid, classoid, objsubid)
);

alter table pg_catalog.pg_description
    owner to "kim-uijin";

grant select on pg_catalog.pg_description to public;

create table pg_catalog.pg_index
(
    indexrelid     oid        not null
        constraint pg_index_indexrelid_index
            primary key,
    indrelid       oid        not null,
    indnatts       smallint   not null,
    indnkeyatts    smallint   not null,
    indisunique    boolean    not null,
    indisprimary   boolean    not null,
    indisexclusion boolean    not null,
    indimmediate   boolean    not null,
    indisclustered boolean    not null,
    indisvalid     boolean    not null,
    indcheckxmin   boolean    not null,
    indisready     boolean    not null,
    indislive      boolean    not null,
    indisreplident boolean    not null,
    indkey         int2vector not null,
    indcollation   oidvector  not null,
    indclass       oidvector  not null,
    indoption      int2vector not null,
    indexprs       pg_node_tree,
    indpred        pg_node_tree
);

alter table pg_catalog.pg_index
    owner to "kim-uijin";

create index pg_index_indrelid_index
    on pg_catalog.pg_index (indrelid);

grant select on pg_catalog.pg_index to public;

create table pg_catalog.pg_inherits
(
    inhrelid         oid     not null,
    inhparent        oid     not null,
    inhseqno         integer not null,
    inhdetachpending boolean not null,
    constraint pg_inherits_relid_seqno_index
        primary key (inhrelid, inhseqno)
);

alter table pg_catalog.pg_inherits
    owner to "kim-uijin";

create index pg_inherits_parent_index
    on pg_catalog.pg_inherits (inhparent);

grant select on pg_catalog.pg_inherits to public;

create table pg_catalog.pg_language
(
    oid           oid     not null
        constraint pg_language_oid_index
            primary key,
    lanname       name    not null
        constraint pg_language_name_index
            unique,
    lanowner      oid     not null,
    lanispl       boolean not null,
    lanpltrusted  boolean not null,
    lanplcallfoid oid     not null,
    laninline     oid     not null,
    lanvalidator  oid     not null,
    lanacl        aclitem[]
);

alter table pg_catalog.pg_language
    owner to "kim-uijin";

grant select on pg_catalog.pg_language to public;

create table pg_catalog.pg_largeobject
(
    loid   oid     not null,
    pageno integer not null,
    data   bytea   not null,
    constraint pg_largeobject_loid_pn_index
        primary key (loid, pageno)
);

alter table pg_catalog.pg_largeobject
    owner to "kim-uijin";

create table pg_catalog.pg_namespace
(
    oid      oid  not null
        constraint pg_namespace_oid_index
            primary key,
    nspname  name not null
        constraint pg_namespace_nspname_index
            unique,
    nspowner oid  not null,
    nspacl   aclitem[]
);

alter table pg_catalog.pg_namespace
    owner to "kim-uijin";

grant select on pg_catalog.pg_namespace to public;

create table pg_catalog.pg_opclass
(
    oid          oid     not null
        constraint pg_opclass_oid_index
            primary key,
    opcmethod    oid     not null,
    opcname      name    not null,
    opcnamespace oid     not null,
    opcowner     oid     not null,
    opcfamily    oid     not null,
    opcintype    oid     not null,
    opcdefault   boolean not null,
    opckeytype   oid     not null,
    constraint pg_opclass_am_name_nsp_index
        unique (opcmethod, opcname, opcnamespace)
);

alter table pg_catalog.pg_opclass
    owner to "kim-uijin";

grant select on pg_catalog.pg_opclass to public;

create table pg_catalog.pg_operator
(
    oid          oid     not null
        constraint pg_operator_oid_index
            primary key,
    oprname      name    not null,
    oprnamespace oid     not null,
    oprowner     oid     not null,
    oprkind      "char"  not null,
    oprcanmerge  boolean not null,
    oprcanhash   boolean not null,
    oprleft      oid     not null,
    oprright     oid     not null,
    oprresult    oid     not null,
    oprcom       oid     not null,
    oprnegate    oid     not null,
    oprcode      regproc not null,
    oprrest      regproc not null,
    oprjoin      regproc not null,
    constraint pg_operator_oprname_l_r_n_index
        unique (oprname, oprleft, oprright, oprnamespace)
);

alter table pg_catalog.pg_operator
    owner to "kim-uijin";

grant select on pg_catalog.pg_operator to public;

create table pg_catalog.pg_rewrite
(
    oid        oid          not null
        constraint pg_rewrite_oid_index
            primary key,
    rulename   name         not null,
    ev_class   oid          not null,
    ev_type    "char"       not null,
    ev_enabled "char"       not null,
    is_instead boolean      not null,
    ev_qual    pg_node_tree not null,
    ev_action  pg_node_tree not null,
    constraint pg_rewrite_rel_rulename_index
        unique (ev_class, rulename)
);

alter table pg_catalog.pg_rewrite
    owner to "kim-uijin";

grant select on pg_catalog.pg_rewrite to public;

create table pg_catalog.pg_statistic
(
    starelid    oid      not null,
    staattnum   smallint not null,
    stainherit  boolean  not null,
    stanullfrac real     not null,
    stawidth    integer  not null,
    stadistinct real     not null,
    stakind1    smallint not null,
    stakind2    smallint not null,
    stakind3    smallint not null,
    stakind4    smallint not null,
    stakind5    smallint not null,
    staop1      oid      not null,
    staop2      oid      not null,
    staop3      oid      not null,
    staop4      oid      not null,
    staop5      oid      not null,
    stacoll1    oid      not null,
    stacoll2    oid      not null,
    stacoll3    oid      not null,
    stacoll4    oid      not null,
    stacoll5    oid      not null,
    stanumbers1 real[],
    stanumbers2 real[],
    stanumbers3 real[],
    stanumbers4 real[],
    stanumbers5 real[],
    stavalues1  anyarray,
    stavalues2  anyarray,
    stavalues3  anyarray,
    stavalues4  anyarray,
    stavalues5  anyarray,
    constraint pg_statistic_relid_att_inh_index
        primary key (starelid, staattnum, stainherit)
);

alter table pg_catalog.pg_statistic
    owner to "kim-uijin";

create table pg_catalog.pg_trigger
(
    oid            oid        not null
        constraint pg_trigger_oid_index
            primary key,
    tgrelid        oid        not null,
    tgparentid     oid        not null,
    tgname         name       not null,
    tgfoid         oid        not null,
    tgtype         smallint   not null,
    tgenabled      "char"     not null,
    tgisinternal   boolean    not null,
    tgconstrrelid  oid        not null,
    tgconstrindid  oid        not null,
    tgconstraint   oid        not null,
    tgdeferrable   boolean    not null,
    tginitdeferred boolean    not null,
    tgnargs        smallint   not null,
    tgattr         int2vector not null,
    tgargs         bytea      not null,
    tgqual         pg_node_tree,
    tgoldtable     name,
    tgnewtable     name,
    constraint pg_trigger_tgrelid_tgname_index
        unique (tgrelid, tgname)
);

alter table pg_catalog.pg_trigger
    owner to "kim-uijin";

create index pg_trigger_tgconstraint_index
    on pg_catalog.pg_trigger (tgconstraint);

grant select on pg_catalog.pg_trigger to public;

create table pg_catalog.pg_opfamily
(
    oid          oid  not null
        constraint pg_opfamily_oid_index
            primary key,
    opfmethod    oid  not null,
    opfname      name not null,
    opfnamespace oid  not null,
    opfowner     oid  not null,
    constraint pg_opfamily_am_name_nsp_index
        unique (opfmethod, opfname, opfnamespace)
);

alter table pg_catalog.pg_opfamily
    owner to "kim-uijin";

grant select on pg_catalog.pg_opfamily to public;

create table pg_catalog.pg_db_role_setting
(
    setdatabase oid not null,
    setrole     oid not null,
    setconfig   text[],
    constraint pg_db_role_setting_databaseid_rol_index
        primary key (setdatabase, setrole)
)
    tablespace pg_global;

alter table pg_catalog.pg_db_role_setting
    owner to "kim-uijin";

grant select on pg_catalog.pg_db_role_setting to public;

create table pg_catalog.pg_largeobject_metadata
(
    oid      oid not null
        constraint pg_largeobject_metadata_oid_index
            primary key,
    lomowner oid not null,
    lomacl   aclitem[]
);

alter table pg_catalog.pg_largeobject_metadata
    owner to "kim-uijin";

grant select on pg_catalog.pg_largeobject_metadata to public;

create table pg_catalog.pg_extension
(
    oid            oid     not null
        constraint pg_extension_oid_index
            primary key,
    extname        name    not null
        constraint pg_extension_name_index
            unique,
    extowner       oid     not null,
    extnamespace   oid     not null,
    extrelocatable boolean not null,
    extversion     text    not null,
    extconfig      oid[],
    extcondition   text[]
);

alter table pg_catalog.pg_extension
    owner to "kim-uijin";

grant select on pg_catalog.pg_extension to public;

create table pg_catalog.pg_foreign_table
(
    ftrelid   oid not null
        constraint pg_foreign_table_relid_index
            primary key,
    ftserver  oid not null,
    ftoptions text[]
);

alter table pg_catalog.pg_foreign_table
    owner to "kim-uijin";

grant select on pg_catalog.pg_foreign_table to public;

create table pg_catalog.pg_policy
(
    oid           oid     not null
        constraint pg_policy_oid_index
            primary key,
    polname       name    not null,
    polrelid      oid     not null,
    polcmd        "char"  not null,
    polpermissive boolean not null,
    polroles      oid[]   not null,
    polqual       pg_node_tree,
    polwithcheck  pg_node_tree,
    constraint pg_policy_polrelid_polname_index
        unique (polrelid, polname)
);

alter table pg_catalog.pg_policy
    owner to "kim-uijin";

grant select on pg_catalog.pg_policy to public;

create table pg_catalog.pg_partitioned_table
(
    partrelid     oid        not null
        constraint pg_partitioned_table_partrelid_index
            primary key,
    partstrat     "char"     not null,
    partnatts     smallint   not null,
    partdefid     oid        not null,
    partattrs     int2vector not null,
    partclass     oidvector  not null,
    partcollation oidvector  not null,
    partexprs     pg_node_tree
);

alter table pg_catalog.pg_partitioned_table
    owner to "kim-uijin";

grant select on pg_catalog.pg_partitioned_table to public;

create table pg_catalog.pg_statistic_ext
(
    oid           oid        not null
        constraint pg_statistic_ext_oid_index
            primary key,
    stxrelid      oid        not null,
    stxname       name       not null,
    stxnamespace  oid        not null,
    stxowner      oid        not null,
    stxstattarget integer    not null,
    stxkeys       int2vector not null,
    stxkind       "char"[]   not null,
    stxexprs      pg_node_tree,
    constraint pg_statistic_ext_name_index
        unique (stxname, stxnamespace)
);

alter table pg_catalog.pg_statistic_ext
    owner to "kim-uijin";

create index pg_statistic_ext_relid_index
    on pg_catalog.pg_statistic_ext (stxrelid);

grant select on pg_catalog.pg_statistic_ext to public;

create table pg_catalog.pg_init_privs
(
    objoid    oid       not null,
    classoid  oid       not null,
    objsubid  integer   not null,
    privtype  "char"    not null,
    initprivs aclitem[] not null,
    constraint pg_init_privs_o_c_o_index
        primary key (objoid, classoid, objsubid)
);

alter table pg_catalog.pg_init_privs
    owner to "kim-uijin";

grant select on pg_catalog.pg_init_privs to public;

create table pg_catalog.pg_statistic_ext_data
(
    stxoid           oid not null
        constraint pg_statistic_ext_data_stxoid_index
            primary key,
    stxdndistinct    pg_ndistinct,
    stxddependencies pg_dependencies,
    stxdmcv          pg_mcv_list,
    stxdexpr         pg_statistic[]
);

alter table pg_catalog.pg_statistic_ext_data
    owner to "kim-uijin";

create table pg_catalog.pg_collation
(
    oid                 oid     not null
        constraint pg_collation_oid_index
            primary key,
    collname            name    not null,
    collnamespace       oid     not null,
    collowner           oid     not null,
    collprovider        "char"  not null,
    collisdeterministic boolean not null,
    collencoding        integer not null,
    collcollate         name    not null,
    collctype           name    not null,
    collversion         text,
    constraint pg_collation_name_enc_nsp_index
        unique (collname, collencoding, collnamespace)
);

alter table pg_catalog.pg_collation
    owner to "kim-uijin";

grant select on pg_catalog.pg_collation to public;

create table pg_catalog.pg_event_trigger
(
    oid        oid    not null
        constraint pg_event_trigger_oid_index
            primary key,
    evtname    name   not null
        constraint pg_event_trigger_evtname_index
            unique,
    evtevent   name   not null,
    evtowner   oid    not null,
    evtfoid    oid    not null,
    evtenabled "char" not null,
    evttags    text[]
);

alter table pg_catalog.pg_event_trigger
    owner to "kim-uijin";

grant select on pg_catalog.pg_event_trigger to public;

create table pg_catalog.pg_enum
(
    oid           oid  not null
        constraint pg_enum_oid_index
            primary key,
    enumtypid     oid  not null,
    enumsortorder real not null,
    enumlabel     name not null,
    constraint pg_enum_typid_label_index
        unique (enumtypid, enumlabel),
    constraint pg_enum_typid_sortorder_index
        unique (enumtypid, enumsortorder)
);

alter table pg_catalog.pg_enum
    owner to "kim-uijin";

grant select on pg_catalog.pg_enum to public;

create table pg_catalog.pg_range
(
    rngtypid      oid     not null
        constraint pg_range_rngtypid_index
            primary key,
    rngsubtype    oid     not null,
    rngmultitypid oid     not null
        constraint pg_range_rngmultitypid_index
            unique,
    rngcollation  oid     not null,
    rngsubopc     oid     not null,
    rngcanonical  regproc not null,
    rngsubdiff    regproc not null
);

alter table pg_catalog.pg_range
    owner to "kim-uijin";

grant select on pg_catalog.pg_range to public;

create table pg_catalog.pg_transform
(
    oid        oid     not null
        constraint pg_transform_oid_index
            primary key,
    trftype    oid     not null,
    trflang    oid     not null,
    trffromsql regproc not null,
    trftosql   regproc not null,
    constraint pg_transform_type_lang_index
        unique (trftype, trflang)
);

alter table pg_catalog.pg_transform
    owner to "kim-uijin";

grant select on pg_catalog.pg_transform to public;

create table pg_catalog.pg_shseclabel
(
    objoid   oid  not null,
    classoid oid  not null,
    provider text not null,
    label    text not null,
    constraint pg_shseclabel_object_index
        primary key (objoid, classoid, provider)
)
    tablespace pg_global;

alter table pg_catalog.pg_shseclabel
    owner to "kim-uijin";

grant select on pg_catalog.pg_shseclabel to public;

create table pg_catalog.pg_seclabel
(
    objoid   oid     not null,
    classoid oid     not null,
    objsubid integer not null,
    provider text    not null,
    label    text    not null,
    constraint pg_seclabel_object_index
        primary key (objoid, classoid, objsubid, provider)
);

alter table pg_catalog.pg_seclabel
    owner to "kim-uijin";

grant select on pg_catalog.pg_seclabel to public;

create table pg_catalog.pg_ts_dict
(
    oid            oid  not null
        constraint pg_ts_dict_oid_index
            primary key,
    dictname       name not null,
    dictnamespace  oid  not null,
    dictowner      oid  not null,
    dicttemplate   oid  not null,
    dictinitoption text,
    constraint pg_ts_dict_dictname_index
        unique (dictname, dictnamespace)
);

alter table pg_catalog.pg_ts_dict
    owner to "kim-uijin";

grant select on pg_catalog.pg_ts_dict to public;

create table pg_catalog.pg_ts_parser
(
    oid          oid     not null
        constraint pg_ts_parser_oid_index
            primary key,
    prsname      name    not null,
    prsnamespace oid     not null,
    prsstart     regproc not null,
    prstoken     regproc not null,
    prsend       regproc not null,
    prsheadline  regproc not null,
    prslextype   regproc not null,
    constraint pg_ts_parser_prsname_index
        unique (prsname, prsnamespace)
);

alter table pg_catalog.pg_ts_parser
    owner to "kim-uijin";

grant select on pg_catalog.pg_ts_parser to public;

create table pg_catalog.pg_ts_config
(
    oid          oid  not null
        constraint pg_ts_config_oid_index
            primary key,
    cfgname      name not null,
    cfgnamespace oid  not null,
    cfgowner     oid  not null,
    cfgparser    oid  not null,
    constraint pg_ts_config_cfgname_index
        unique (cfgname, cfgnamespace)
);

alter table pg_catalog.pg_ts_config
    owner to "kim-uijin";

grant select on pg_catalog.pg_ts_config to public;

create table pg_catalog.pg_ts_config_map
(
    mapcfg       oid     not null,
    maptokentype integer not null,
    mapseqno     integer not null,
    mapdict      oid     not null,
    constraint pg_ts_config_map_index
        primary key (mapcfg, maptokentype, mapseqno)
);

alter table pg_catalog.pg_ts_config_map
    owner to "kim-uijin";

grant select on pg_catalog.pg_ts_config_map to public;

create table pg_catalog.pg_ts_template
(
    oid           oid     not null
        constraint pg_ts_template_oid_index
            primary key,
    tmplname      name    not null,
    tmplnamespace oid     not null,
    tmplinit      regproc not null,
    tmpllexize    regproc not null,
    constraint pg_ts_template_tmplname_index
        unique (tmplname, tmplnamespace)
);

alter table pg_catalog.pg_ts_template
    owner to "kim-uijin";

grant select on pg_catalog.pg_ts_template to public;

create table pg_catalog.pg_replication_origin
(
    roident oid  not null
        constraint pg_replication_origin_roiident_index
            primary key,
    roname  text not null
        constraint pg_replication_origin_roname_index
            unique
)
    tablespace pg_global;

alter table pg_catalog.pg_replication_origin
    owner to "kim-uijin";

grant select on pg_catalog.pg_replication_origin to public;

create table pg_catalog.pg_subscription
(
    oid             oid     not null
        constraint pg_subscription_oid_index
            primary key,
    subdbid         oid     not null,
    subname         name    not null,
    subowner        oid     not null,
    subenabled      boolean not null,
    subbinary       boolean not null,
    substream       boolean not null,
    subconninfo     text    not null,
    subslotname     name,
    subsynccommit   text    not null,
    subpublications text[]  not null,
    constraint pg_subscription_subname_index
        unique (subdbid, subname)
)
    tablespace pg_global;

alter table pg_catalog.pg_subscription
    owner to "kim-uijin";

grant select (oid, subdbid, subname, subowner, subenabled, subbinary, substream, subslotname, subsynccommit,
              subpublications) on pg_catalog.pg_subscription to public;

create table pg_catalog.pg_subscription_rel
(
    srsubid    oid    not null,
    srrelid    oid    not null,
    srsubstate "char" not null,
    srsublsn   pg_lsn,
    constraint pg_subscription_rel_srrelid_srsubid_index
        primary key (srrelid, srsubid)
);

alter table pg_catalog.pg_subscription_rel
    owner to "kim-uijin";

grant select on pg_catalog.pg_subscription_rel to public;

create table pg_catalog.pg_publication
(
    oid          oid     not null
        constraint pg_publication_oid_index
            primary key,
    pubname      name    not null
        constraint pg_publication_pubname_index
            unique,
    pubowner     oid     not null,
    puballtables boolean not null,
    pubinsert    boolean not null,
    pubupdate    boolean not null,
    pubdelete    boolean not null,
    pubtruncate  boolean not null,
    pubviaroot   boolean not null
);

alter table pg_catalog.pg_publication
    owner to "kim-uijin";

grant select on pg_catalog.pg_publication to public;

create table pg_catalog.pg_publication_rel
(
    oid     oid not null
        constraint pg_publication_rel_oid_index
            primary key,
    prpubid oid not null,
    prrelid oid not null,
    constraint pg_publication_rel_prrelid_prpubid_index
        unique (prrelid, prpubid)
);

alter table pg_catalog.pg_publication_rel
    owner to "kim-uijin";

grant select on pg_catalog.pg_publication_rel to public;

create table information_schema.sql_features
(
    feature_id       information_schema.character_data,
    feature_name     information_schema.character_data,
    sub_feature_id   information_schema.character_data,
    sub_feature_name information_schema.character_data,
    is_supported     information_schema.yes_or_no,
    is_verified_by   information_schema.character_data,
    comments         information_schema.character_data
);

alter table information_schema.sql_features
    owner to "kim-uijin";

grant select on information_schema.sql_features to public;

create table information_schema.sql_implementation_info
(
    implementation_info_id   information_schema.character_data,
    implementation_info_name information_schema.character_data,
    integer_value            information_schema.cardinal_number,
    character_value          information_schema.character_data,
    comments                 information_schema.character_data
);

alter table information_schema.sql_implementation_info
    owner to "kim-uijin";

grant select on information_schema.sql_implementation_info to public;

create table information_schema.sql_parts
(
    feature_id     information_schema.character_data,
    feature_name   information_schema.character_data,
    is_supported   information_schema.yes_or_no,
    is_verified_by information_schema.character_data,
    comments       information_schema.character_data
);

alter table information_schema.sql_parts
    owner to "kim-uijin";

create table information_schema.sql_sizing
(
    sizing_id       information_schema.cardinal_number,
    sizing_name     information_schema.character_data,
    supported_value information_schema.cardinal_number,
    comments        information_schema.character_data
);

alter table information_schema.sql_sizing
    owner to "kim-uijin";

grant select on information_schema.sql_sizing to public;

create table public.user_kakao_oauth
(
    "kakaoId"          integer                  not null
        constraint "PK_fb1f792541e10dd2fe9474fd743"
            primary key,
    id_token           varchar(255)             not null,
    access_token       varchar(255)             not null,
    refresh_token      varchar(255)             not null,
    expires_on         timestamp with time zone not null,
    refresh_expires_on timestamp with time zone not null,
    created_at         timestamp default now()  not null,
    updated_at         timestamp default now()  not null,
    delete_at          timestamp with time zone
);

alter table public.user_kakao_oauth
    owner to kpasd002;

create table public.user_auth
(
    id                  serial
        constraint "PK_56d00ec31dc3eed1c3f6bff4f58"
            primary key,
    password            varchar(255),
    role                user_auth_role_enum default 'USER'::user_auth_role_enum not null,
    salt                varchar(255),
    access_token        varchar(255),
    refresh_token       varchar(255),
    "kakaoOauthKakaoId" integer
        constraint "REL_62645b1b556baf7b4f1d452a9a"
            unique
        constraint "FK_62645b1b556baf7b4f1d452a9a2"
            references public.user_kakao_oauth
            on update cascade on delete cascade
);

alter table public.user_auth
    owner to kpasd002;

create table public."user"
(
    uuid         uuid      default uuid_generate_v4() not null
        constraint "PK_a95e949168be7b7ece1a2382fed"
            primary key,
    name         varchar(20)                          not null,
    email        varchar(50)                          not null,
    phone        varchar(20)                          not null,
    birth        varchar(8),
    point        integer   default 0                  not null,
    ip           varchar(50),
    useragent    varchar(255),
    created_at   timestamp default now()              not null,
    updated_at   timestamp default now()              not null,
    delete_at    timestamp with time zone,
    "userAuthId" integer
        constraint "REL_35e7719aa0aaf688491f85c3bb"
            unique
        constraint "FK_35e7719aa0aaf688491f85c3bbf"
            references public.user_auth
            on update cascade on delete cascade
);

alter table public."user"
    owner to kpasd002;

create view pg_catalog.pg_roles
            (rolname, rolsuper, rolinherit, rolcreaterole, rolcreatedb, rolcanlogin, rolreplication, rolconnlimit,
             rolpassword, rolvaliduntil, rolbypassrls, rolconfig, oid)
as
SELECT pg_authid.rolname,
       pg_authid.rolsuper,
       pg_authid.rolinherit,
       pg_authid.rolcreaterole,
       pg_authid.rolcreatedb,
       pg_authid.rolcanlogin,
       pg_authid.rolreplication,
       pg_authid.rolconnlimit,
       '********'::text AS rolpassword,
       pg_authid.rolvaliduntil,
       pg_authid.rolbypassrls,
       s.setconfig      AS rolconfig,
       pg_authid.oid
FROM pg_authid
         LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid;

alter table pg_catalog.pg_roles
    owner to "kim-uijin";

grant select on pg_catalog.pg_roles to public;

create view pg_catalog.pg_shadow
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
SELECT pg_authid.rolname        AS usename,
       pg_authid.oid            AS usesysid,
       pg_authid.rolcreatedb    AS usecreatedb,
       pg_authid.rolsuper       AS usesuper,
       pg_authid.rolreplication AS userepl,
       pg_authid.rolbypassrls   AS usebypassrls,
       pg_authid.rolpassword    AS passwd,
       pg_authid.rolvaliduntil  AS valuntil,
       s.setconfig              AS useconfig
FROM pg_authid
         LEFT JOIN pg_db_role_setting s ON pg_authid.oid = s.setrole AND s.setdatabase = 0::oid
WHERE pg_authid.rolcanlogin;

alter table pg_catalog.pg_shadow
    owner to "kim-uijin";

create view pg_catalog.pg_group(groname, grosysid, grolist) as
SELECT pg_authid.rolname                                   AS groname,
       pg_authid.oid                                       AS grosysid,
       ARRAY(SELECT pg_auth_members.member
             FROM pg_auth_members
             WHERE pg_auth_members.roleid = pg_authid.oid) AS grolist
FROM pg_authid
WHERE NOT pg_authid.rolcanlogin;

alter table pg_catalog.pg_group
    owner to "kim-uijin";

grant select on pg_catalog.pg_group to public;

create view pg_catalog.pg_user
            (usename, usesysid, usecreatedb, usesuper, userepl, usebypassrls, passwd, valuntil, useconfig) as
SELECT pg_shadow.usename,
       pg_shadow.usesysid,
       pg_shadow.usecreatedb,
       pg_shadow.usesuper,
       pg_shadow.userepl,
       pg_shadow.usebypassrls,
       '********'::text AS passwd,
       pg_shadow.valuntil,
       pg_shadow.useconfig
FROM pg_shadow;

alter table pg_catalog.pg_user
    owner to "kim-uijin";

grant select on pg_catalog.pg_user to public;

create view pg_catalog.pg_policies (schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check) as
SELECT n.nspname                                   AS schemaname,
       c.relname                                   AS tablename,
       pol.polname                                 AS policyname,
       CASE
           WHEN pol.polpermissive THEN 'PERMISSIVE'::text
           ELSE 'RESTRICTIVE'::text
           END                                     AS permissive,
       CASE
           WHEN pol.polroles = '{0}'::oid[] THEN string_to_array('public'::text, ''::text)::name[]
           ELSE ARRAY(SELECT pg_authid.rolname
                      FROM pg_authid
                      WHERE pg_authid.oid = ANY (pol.polroles)
                      ORDER BY pg_authid.rolname)
           END                                     AS roles,
       CASE pol.polcmd
           WHEN 'r'::"char" THEN 'SELECT'::text
           WHEN 'a'::"char" THEN 'INSERT'::text
           WHEN 'w'::"char" THEN 'UPDATE'::text
           WHEN 'd'::"char" THEN 'DELETE'::text
           WHEN '*'::"char" THEN 'ALL'::text
           ELSE NULL::text
           END                                     AS cmd,
       pg_get_expr(pol.polqual, pol.polrelid)      AS qual,
       pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check
FROM pg_policy pol
         JOIN pg_class c ON c.oid = pol.polrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace;

alter table pg_catalog.pg_policies
    owner to "kim-uijin";

grant select on pg_catalog.pg_policies to public;

create view pg_catalog.pg_rules(schemaname, tablename, rulename, definition) as
SELECT n.nspname             AS schemaname,
       c.relname             AS tablename,
       r.rulename,
       pg_get_ruledef(r.oid) AS definition
FROM pg_rewrite r
         JOIN pg_class c ON c.oid = r.ev_class
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE r.rulename <> '_RETURN'::name;

alter table pg_catalog.pg_rules
    owner to "kim-uijin";

grant select on pg_catalog.pg_rules to public;

create view pg_catalog.pg_views(schemaname, viewname, viewowner, definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS viewname,
       pg_get_userbyid(c.relowner) AS viewowner,
       pg_get_viewdef(c.oid)       AS definition
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'v'::"char";

alter table pg_catalog.pg_views
    owner to "kim-uijin";

grant select on pg_catalog.pg_views to public;

create view pg_catalog.pg_tables
            (schemaname, tablename, tableowner, tablespace, hasindexes, hasrules, hastriggers, rowsecurity) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS tablename,
       pg_get_userbyid(c.relowner) AS tableowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relhasrules               AS hasrules,
       c.relhastriggers            AS hastriggers,
       c.relrowsecurity            AS rowsecurity
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]);

alter table pg_catalog.pg_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_tables to public;

create view pg_catalog.pg_matviews
            (schemaname, matviewname, matviewowner, tablespace, hasindexes, ispopulated, definition) as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS matviewname,
       pg_get_userbyid(c.relowner) AS matviewowner,
       t.spcname                   AS tablespace,
       c.relhasindex               AS hasindexes,
       c.relispopulated            AS ispopulated,
       pg_get_viewdef(c.oid)       AS definition
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
WHERE c.relkind = 'm'::"char";

alter table pg_catalog.pg_matviews
    owner to "kim-uijin";

grant select on pg_catalog.pg_matviews to public;

create view pg_catalog.pg_indexes(schemaname, tablename, indexname, tablespace, indexdef) as
SELECT n.nspname              AS schemaname,
       c.relname              AS tablename,
       i.relname              AS indexname,
       t.spcname              AS tablespace,
       pg_get_indexdef(i.oid) AS indexdef
FROM pg_index x
         JOIN pg_class c ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
         LEFT JOIN pg_tablespace t ON t.oid = i.reltablespace
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 'm'::"char", 'p'::"char"]))
  AND (i.relkind = ANY (ARRAY ['i'::"char", 'I'::"char"]));

alter table pg_catalog.pg_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_indexes to public;

create view pg_catalog.pg_sequences
            (schemaname, sequencename, sequenceowner, data_type, start_value, min_value, max_value, increment_by, cycle,
             cache_size, last_value)
as
SELECT n.nspname                   AS schemaname,
       c.relname                   AS sequencename,
       pg_get_userbyid(c.relowner) AS sequenceowner,
       s.seqtypid::regtype         AS data_type,
       s.seqstart                  AS start_value,
       s.seqmin                    AS min_value,
       s.seqmax                    AS max_value,
       s.seqincrement              AS increment_by,
       s.seqcycle                  AS cycle,
       s.seqcache                  AS cache_size,
       CASE
           WHEN has_sequence_privilege(c.oid, 'SELECT,USAGE'::text) THEN pg_sequence_last_value(c.oid::regclass)
           ELSE NULL::bigint
           END                     AS last_value
FROM pg_sequence s
         JOIN pg_class c ON c.oid = s.seqrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE NOT pg_is_other_temp_schema(n.oid)
  AND c.relkind = 'S'::"char";

alter table pg_catalog.pg_sequences
    owner to "kim-uijin";

grant select on pg_catalog.pg_sequences to public;

create view pg_catalog.pg_stats
            (schemaname, tablename, attname, inherited, null_frac, avg_width, n_distinct, most_common_vals,
             most_common_freqs, histogram_bounds, correlation, most_common_elems, most_common_elem_freqs,
             elem_count_histogram)
as
SELECT n.nspname     AS schemaname,
       c.relname     AS tablename,
       a.attname,
       s.stainherit  AS inherited,
       s.stanullfrac AS null_frac,
       s.stawidth    AS avg_width,
       s.stadistinct AS n_distinct,
       CASE
           WHEN s.stakind1 = 1 THEN s.stavalues1
           WHEN s.stakind2 = 1 THEN s.stavalues2
           WHEN s.stakind3 = 1 THEN s.stavalues3
           WHEN s.stakind4 = 1 THEN s.stavalues4
           WHEN s.stakind5 = 1 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_vals,
       CASE
           WHEN s.stakind1 = 1 THEN s.stanumbers1
           WHEN s.stakind2 = 1 THEN s.stanumbers2
           WHEN s.stakind3 = 1 THEN s.stanumbers3
           WHEN s.stakind4 = 1 THEN s.stanumbers4
           WHEN s.stakind5 = 1 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_freqs,
       CASE
           WHEN s.stakind1 = 2 THEN s.stavalues1
           WHEN s.stakind2 = 2 THEN s.stavalues2
           WHEN s.stakind3 = 2 THEN s.stavalues3
           WHEN s.stakind4 = 2 THEN s.stavalues4
           WHEN s.stakind5 = 2 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS histogram_bounds,
       CASE
           WHEN s.stakind1 = 3 THEN s.stanumbers1[1]
           WHEN s.stakind2 = 3 THEN s.stanumbers2[1]
           WHEN s.stakind3 = 3 THEN s.stanumbers3[1]
           WHEN s.stakind4 = 3 THEN s.stanumbers4[1]
           WHEN s.stakind5 = 3 THEN s.stanumbers5[1]
           ELSE NULL::real
           END       AS correlation,
       CASE
           WHEN s.stakind1 = 4 THEN s.stavalues1
           WHEN s.stakind2 = 4 THEN s.stavalues2
           WHEN s.stakind3 = 4 THEN s.stavalues3
           WHEN s.stakind4 = 4 THEN s.stavalues4
           WHEN s.stakind5 = 4 THEN s.stavalues5
           ELSE NULL::anyarray
           END       AS most_common_elems,
       CASE
           WHEN s.stakind1 = 4 THEN s.stanumbers1
           WHEN s.stakind2 = 4 THEN s.stanumbers2
           WHEN s.stakind3 = 4 THEN s.stanumbers3
           WHEN s.stakind4 = 4 THEN s.stanumbers4
           WHEN s.stakind5 = 4 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS most_common_elem_freqs,
       CASE
           WHEN s.stakind1 = 5 THEN s.stanumbers1
           WHEN s.stakind2 = 5 THEN s.stanumbers2
           WHEN s.stakind3 = 5 THEN s.stanumbers3
           WHEN s.stakind4 = 5 THEN s.stanumbers4
           WHEN s.stakind5 = 5 THEN s.stanumbers5
           ELSE NULL::real[]
           END       AS elem_count_histogram
FROM pg_statistic s
         JOIN pg_class c ON c.oid = s.starelid
         JOIN pg_attribute a ON c.oid = a.attrelid AND a.attnum = s.staattnum
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE NOT a.attisdropped
  AND has_column_privilege(c.oid, a.attnum, 'select'::text)
  AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));

alter table pg_catalog.pg_stats
    owner to "kim-uijin";

grant select on pg_catalog.pg_stats to public;

create view pg_catalog.pg_stats_ext
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, attnames, exprs, kinds,
             n_distinct, dependencies, most_common_vals, most_common_val_nulls, most_common_freqs,
             most_common_base_freqs)
as
SELECT cn.nspname                                                                   AS schemaname,
       c.relname                                                                    AS tablename,
       sn.nspname                                                                   AS statistics_schemaname,
       s.stxname                                                                    AS statistics_name,
       pg_get_userbyid(s.stxowner)                                                  AS statistics_owner,
       (SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg
        FROM unnest(s.stxkeys) k(k)
                 JOIN pg_attribute a ON a.attrelid = s.stxrelid AND a.attnum = k.k) AS attnames,
       pg_get_statisticsobjdef_expressions(s.oid)                                   AS exprs,
       s.stxkind                                                                    AS kinds,
       sd.stxdndistinct                                                             AS n_distinct,
       sd.stxddependencies                                                          AS dependencies,
       m.most_common_vals,
       m.most_common_val_nulls,
       m.most_common_freqs,
       m.most_common_base_freqs
FROM pg_statistic_ext s
         JOIN pg_class c ON c.oid = s.stxrelid
         JOIN pg_statistic_ext_data sd ON s.oid = sd.stxoid
         LEFT JOIN pg_namespace cn ON cn.oid = c.relnamespace
         LEFT JOIN pg_namespace sn ON sn.oid = s.stxnamespace
         LEFT JOIN LATERAL ( SELECT array_agg(pg_mcv_list_items."values")       AS most_common_vals,
                                    array_agg(pg_mcv_list_items.nulls)          AS most_common_val_nulls,
                                    array_agg(pg_mcv_list_items.frequency)      AS most_common_freqs,
                                    array_agg(pg_mcv_list_items.base_frequency) AS most_common_base_freqs
                             FROM pg_mcv_list_items(sd.stxdmcv) pg_mcv_list_items(index, "values", nulls, frequency, base_frequency)) m
                   ON sd.stxdmcv IS NOT NULL
WHERE pg_has_role(c.relowner, 'USAGE'::text)
  AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));

alter table pg_catalog.pg_stats_ext
    owner to "kim-uijin";

grant select on pg_catalog.pg_stats_ext to public;

create view pg_catalog.pg_stats_ext_exprs
            (schemaname, tablename, statistics_schemaname, statistics_name, statistics_owner, expr, null_frac,
             avg_width, n_distinct, most_common_vals, most_common_freqs, histogram_bounds, correlation,
             most_common_elems, most_common_elem_freqs, elem_count_histogram)
as
SELECT cn.nspname                  AS schemaname,
       c.relname                   AS tablename,
       sn.nspname                  AS statistics_schemaname,
       s.stxname                   AS statistics_name,
       pg_get_userbyid(s.stxowner) AS statistics_owner,
       stat.expr,
       (stat.a).stanullfrac        AS null_frac,
       (stat.a).stawidth           AS avg_width,
       (stat.a).stadistinct        AS n_distinct,
       CASE
           WHEN (stat.a).stakind1 = 1 THEN (stat.a).stavalues1
           WHEN (stat.a).stakind2 = 1 THEN (stat.a).stavalues2
           WHEN (stat.a).stakind3 = 1 THEN (stat.a).stavalues3
           WHEN (stat.a).stakind4 = 1 THEN (stat.a).stavalues4
           WHEN (stat.a).stakind5 = 1 THEN (stat.a).stavalues5
           ELSE NULL::anyarray
           END                     AS most_common_vals,
       CASE
           WHEN (stat.a).stakind1 = 1 THEN (stat.a).stanumbers1
           WHEN (stat.a).stakind2 = 1 THEN (stat.a).stanumbers2
           WHEN (stat.a).stakind3 = 1 THEN (stat.a).stanumbers3
           WHEN (stat.a).stakind4 = 1 THEN (stat.a).stanumbers4
           WHEN (stat.a).stakind5 = 1 THEN (stat.a).stanumbers5
           ELSE NULL::real[]
           END                     AS most_common_freqs,
       CASE
           WHEN (stat.a).stakind1 = 2 THEN (stat.a).stavalues1
           WHEN (stat.a).stakind2 = 2 THEN (stat.a).stavalues2
           WHEN (stat.a).stakind3 = 2 THEN (stat.a).stavalues3
           WHEN (stat.a).stakind4 = 2 THEN (stat.a).stavalues4
           WHEN (stat.a).stakind5 = 2 THEN (stat.a).stavalues5
           ELSE NULL::anyarray
           END                     AS histogram_bounds,
       CASE
           WHEN (stat.a).stakind1 = 3 THEN (stat.a).stanumbers1[1]
           WHEN (stat.a).stakind2 = 3 THEN (stat.a).stanumbers2[1]
           WHEN (stat.a).stakind3 = 3 THEN (stat.a).stanumbers3[1]
           WHEN (stat.a).stakind4 = 3 THEN (stat.a).stanumbers4[1]
           WHEN (stat.a).stakind5 = 3 THEN (stat.a).stanumbers5[1]
           ELSE NULL::real
           END                     AS correlation,
       CASE
           WHEN (stat.a).stakind1 = 4 THEN (stat.a).stavalues1
           WHEN (stat.a).stakind2 = 4 THEN (stat.a).stavalues2
           WHEN (stat.a).stakind3 = 4 THEN (stat.a).stavalues3
           WHEN (stat.a).stakind4 = 4 THEN (stat.a).stavalues4
           WHEN (stat.a).stakind5 = 4 THEN (stat.a).stavalues5
           ELSE NULL::anyarray
           END                     AS most_common_elems,
       CASE
           WHEN (stat.a).stakind1 = 4 THEN (stat.a).stanumbers1
           WHEN (stat.a).stakind2 = 4 THEN (stat.a).stanumbers2
           WHEN (stat.a).stakind3 = 4 THEN (stat.a).stanumbers3
           WHEN (stat.a).stakind4 = 4 THEN (stat.a).stanumbers4
           WHEN (stat.a).stakind5 = 4 THEN (stat.a).stanumbers5
           ELSE NULL::real[]
           END                     AS most_common_elem_freqs,
       CASE
           WHEN (stat.a).stakind1 = 5 THEN (stat.a).stanumbers1
           WHEN (stat.a).stakind2 = 5 THEN (stat.a).stanumbers2
           WHEN (stat.a).stakind3 = 5 THEN (stat.a).stanumbers3
           WHEN (stat.a).stakind4 = 5 THEN (stat.a).stanumbers4
           WHEN (stat.a).stakind5 = 5 THEN (stat.a).stanumbers5
           ELSE NULL::real[]
           END                     AS elem_count_histogram
FROM pg_statistic_ext s
         JOIN pg_class c ON c.oid = s.stxrelid
         LEFT JOIN pg_statistic_ext_data sd ON s.oid = sd.stxoid
         LEFT JOIN pg_namespace cn ON cn.oid = c.relnamespace
         LEFT JOIN pg_namespace sn ON sn.oid = s.stxnamespace
         JOIN LATERAL ( SELECT unnest(pg_get_statisticsobjdef_expressions(s.oid)) AS expr,
                               unnest(sd.stxdexpr)                                AS a) stat ON stat.expr IS NOT NULL
WHERE pg_has_role(c.relowner, 'USAGE'::text)
  AND (c.relrowsecurity = false OR NOT row_security_active(c.oid));

alter table pg_catalog.pg_stats_ext_exprs
    owner to "kim-uijin";

grant select on pg_catalog.pg_stats_ext_exprs to public;

create view pg_catalog.pg_publication_tables(pubname, schemaname, tablename) as
SELECT p.pubname,
       n.nspname AS schemaname,
       c.relname AS tablename
FROM pg_publication p,
     LATERAL pg_get_publication_tables(p.pubname::text) gpt(relid),
     pg_class c
         JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.oid = gpt.relid;

alter table pg_catalog.pg_publication_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_publication_tables to public;

create view pg_catalog.pg_locks
            (locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
             virtualtransaction, pid, mode, granted, fastpath, waitstart)
as
SELECT l.locktype,
       l.database,
       l.relation,
       l.page,
       l.tuple,
       l.virtualxid,
       l.transactionid,
       l.classid,
       l.objid,
       l.objsubid,
       l.virtualtransaction,
       l.pid,
       l.mode,
       l.granted,
       l.fastpath,
       l.waitstart
FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid,
                        virtualtransaction, pid, mode, granted, fastpath, waitstart);

alter table pg_catalog.pg_locks
    owner to "kim-uijin";

grant select on pg_catalog.pg_locks to public;

create view pg_catalog.pg_cursors(name, statement, is_holdable, is_binary, is_scrollable, creation_time) as
SELECT c.name,
       c.statement,
       c.is_holdable,
       c.is_binary,
       c.is_scrollable,
       c.creation_time
FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);

alter table pg_catalog.pg_cursors
    owner to "kim-uijin";

grant select on pg_catalog.pg_cursors to public;

create view pg_catalog.pg_available_extensions(name, default_version, installed_version, comment) as
SELECT e.name,
       e.default_version,
       x.extversion AS installed_version,
       e.comment
FROM pg_available_extensions() e(name, default_version, comment)
         LEFT JOIN pg_extension x ON e.name = x.extname;

alter table pg_catalog.pg_available_extensions
    owner to "kim-uijin";

grant select on pg_catalog.pg_available_extensions to public;

create view pg_catalog.pg_available_extension_versions
            (name, version, installed, superuser, trusted, relocatable, schema, requires, comment) as
SELECT e.name,
       e.version,
       x.extname IS NOT NULL AS installed,
       e.superuser,
       e.trusted,
       e.relocatable,
       e.schema,
       e.requires,
       e.comment
FROM pg_available_extension_versions() e(name, version, superuser, trusted, relocatable, schema, requires, comment)
         LEFT JOIN pg_extension x ON e.name = x.extname AND e.version = x.extversion;

alter table pg_catalog.pg_available_extension_versions
    owner to "kim-uijin";

grant select on pg_catalog.pg_available_extension_versions to public;

create view pg_catalog.pg_prepared_xacts(transaction, gid, prepared, owner, database) as
SELECT p.transaction,
       p.gid,
       p.prepared,
       u.rolname AS owner,
       d.datname AS database
FROM pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)
         LEFT JOIN pg_authid u ON p.ownerid = u.oid
         LEFT JOIN pg_database d ON p.dbid = d.oid;

alter table pg_catalog.pg_prepared_xacts
    owner to "kim-uijin";

grant select on pg_catalog.pg_prepared_xacts to public;

create view pg_catalog.pg_prepared_statements
            (name, statement, prepare_time, parameter_types, from_sql, generic_plans, custom_plans) as
SELECT p.name,
       p.statement,
       p.prepare_time,
       p.parameter_types,
       p.from_sql,
       p.generic_plans,
       p.custom_plans
FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql, generic_plans, custom_plans);

alter table pg_catalog.pg_prepared_statements
    owner to "kim-uijin";

grant select on pg_catalog.pg_prepared_statements to public;

create view pg_catalog.pg_seclabels (objoid, classoid, objsubid, objtype, objnamespace, objname, provider, label) as
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE
           WHEN rel.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]) THEN 'table'::text
           WHEN rel.relkind = 'v'::"char" THEN 'view'::text
           WHEN rel.relkind = 'm'::"char" THEN 'materialized view'::text
           WHEN rel.relkind = 'S'::"char" THEN 'sequence'::text
           WHEN rel.relkind = 'f'::"char" THEN 'foreign table'::text
           ELSE NULL::text
           END          AS objtype,
       rel.relnamespace AS objnamespace,
       CASE
           WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)
           ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)
           END          AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid
         JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'column'::text                                 AS objtype,
       rel.relnamespace                               AS objnamespace,
       (
           CASE
               WHEN pg_table_is_visible(rel.oid) THEN quote_ident(rel.relname::text)
               ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(rel.relname::text)
               END || '.'::text) || att.attname::text AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_class rel ON l.classoid = rel.tableoid AND l.objoid = rel.oid
         JOIN pg_attribute att ON rel.oid = att.attrelid AND l.objsubid = att.attnum
         JOIN pg_namespace nsp ON rel.relnamespace = nsp.oid
WHERE l.objsubid <> 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE pro.prokind
           WHEN 'a'::"char" THEN 'aggregate'::text
           WHEN 'f'::"char" THEN 'function'::text
           WHEN 'p'::"char" THEN 'procedure'::text
           WHEN 'w'::"char" THEN 'window'::text
           ELSE NULL::text
           END                                                                        AS objtype,
       pro.pronamespace                                                               AS objnamespace,
       ((
            CASE
                WHEN pg_function_is_visible(pro.oid) THEN quote_ident(pro.proname::text)
                ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(pro.proname::text)
                END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_proc pro ON l.classoid = pro.tableoid AND l.objoid = pro.oid
         JOIN pg_namespace nsp ON pro.pronamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       CASE
           WHEN typ.typtype = 'd'::"char" THEN 'domain'::text
           ELSE 'type'::text
           END          AS objtype,
       typ.typnamespace AS objnamespace,
       CASE
           WHEN pg_type_is_visible(typ.oid) THEN quote_ident(typ.typname::text)
           ELSE (quote_ident(nsp.nspname::text) || '.'::text) || quote_ident(typ.typname::text)
           END          AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_type typ ON l.classoid = typ.tableoid AND l.objoid = typ.oid
         JOIN pg_namespace nsp ON typ.typnamespace = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'large object'::text AS objtype,
       NULL::oid            AS objnamespace,
       l.objoid::text       AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_largeobject_metadata lom ON l.objoid = lom.oid
WHERE l.classoid = 'pg_largeobject'::regclass::oid
  AND l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'language'::text               AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(lan.lanname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_language lan ON l.classoid = lan.tableoid AND l.objoid = lan.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'schema'::text                 AS objtype,
       nsp.oid                        AS objnamespace,
       quote_ident(nsp.nspname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_namespace nsp ON l.classoid = nsp.tableoid AND l.objoid = nsp.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'event trigger'::text          AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(evt.evtname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_event_trigger evt ON l.classoid = evt.tableoid AND l.objoid = evt.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       l.objsubid,
       'publication'::text          AS objtype,
       NULL::oid                    AS objnamespace,
       quote_ident(p.pubname::text) AS objname,
       l.provider,
       l.label
FROM pg_seclabel l
         JOIN pg_publication p ON l.classoid = p.tableoid AND l.objoid = p.oid
WHERE l.objsubid = 0
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                            AS objsubid,
       'subscription'::text         AS objtype,
       NULL::oid                    AS objnamespace,
       quote_ident(s.subname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_subscription s ON l.classoid = s.tableoid AND l.objoid = s.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'database'::text               AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(dat.datname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_database dat ON l.classoid = dat.tableoid AND l.objoid = dat.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'tablespace'::text             AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(spc.spcname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_tablespace spc ON l.classoid = spc.tableoid AND l.objoid = spc.oid
UNION ALL
SELECT l.objoid,
       l.classoid,
       0                              AS objsubid,
       'role'::text                   AS objtype,
       NULL::oid                      AS objnamespace,
       quote_ident(rol.rolname::text) AS objname,
       l.provider,
       l.label
FROM pg_shseclabel l
         JOIN pg_authid rol ON l.classoid = rol.tableoid AND l.objoid = rol.oid;

alter table pg_catalog.pg_seclabels
    owner to "kim-uijin";

grant select on pg_catalog.pg_seclabels to public;

create view pg_catalog.pg_settings
            (name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val,
             enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart)
as
SELECT a.name,
       a.setting,
       a.unit,
       a.category,
       a.short_desc,
       a.extra_desc,
       a.context,
       a.vartype,
       a.source,
       a.min_val,
       a.max_val,
       a.enumvals,
       a.boot_val,
       a.reset_val,
       a.sourcefile,
       a.sourceline,
       a.pending_restart
FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val,
                              max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);

alter table pg_catalog.pg_settings
    owner to "kim-uijin";

CREATE RULE pg_settings_u AS
    ON UPDATE TO pg_settings
    WHERE new.name = old.name DO  SELECT set_config(old.name, new.setting, false) AS set_config;

CREATE RULE pg_settings_n AS
    ON UPDATE TO pg_settings DO INSTEAD NOTHING;

grant select, update on pg_catalog.pg_settings to public;

create view pg_catalog.pg_file_settings(sourcefile, sourceline, seqno, name, setting, applied, error) as
SELECT a.sourcefile,
       a.sourceline,
       a.seqno,
       a.name,
       a.setting,
       a.applied,
       a.error
FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);

alter table pg_catalog.pg_file_settings
    owner to "kim-uijin";

create view pg_catalog.pg_hba_file_rules
            (line_number, type, database, user_name, address, netmask, auth_method, options, error) as
SELECT a.line_number,
       a.type,
       a.database,
       a.user_name,
       a.address,
       a.netmask,
       a.auth_method,
       a.options,
       a.error
FROM pg_hba_file_rules() a(line_number, type, database, user_name, address, netmask, auth_method, options, error);

alter table pg_catalog.pg_hba_file_rules
    owner to "kim-uijin";

create view pg_catalog.pg_timezone_abbrevs(abbrev, utc_offset, is_dst) as
SELECT pg_timezone_abbrevs.abbrev,
       pg_timezone_abbrevs.utc_offset,
       pg_timezone_abbrevs.is_dst
FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_abbrevs
    owner to "kim-uijin";

grant select on pg_catalog.pg_timezone_abbrevs to public;

create view pg_catalog.pg_timezone_names(name, abbrev, utc_offset, is_dst) as
SELECT pg_timezone_names.name,
       pg_timezone_names.abbrev,
       pg_timezone_names.utc_offset,
       pg_timezone_names.is_dst
FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);

alter table pg_catalog.pg_timezone_names
    owner to "kim-uijin";

grant select on pg_catalog.pg_timezone_names to public;

create view pg_catalog.pg_config(name, setting) as
SELECT pg_config.name,
       pg_config.setting
FROM pg_config() pg_config(name, setting);

alter table pg_catalog.pg_config
    owner to "kim-uijin";

create view pg_catalog.pg_shmem_allocations(name, "off", size, allocated_size) as
SELECT pg_get_shmem_allocations.name,
       pg_get_shmem_allocations.off,
       pg_get_shmem_allocations.size,
       pg_get_shmem_allocations.allocated_size
FROM pg_get_shmem_allocations() pg_get_shmem_allocations(name, off, size, allocated_size);

alter table pg_catalog.pg_shmem_allocations
    owner to "kim-uijin";

create view pg_catalog.pg_backend_memory_contexts
            (name, ident, parent, level, total_bytes, total_nblocks, free_bytes, free_chunks, used_bytes) as
SELECT pg_get_backend_memory_contexts.name,
       pg_get_backend_memory_contexts.ident,
       pg_get_backend_memory_contexts.parent,
       pg_get_backend_memory_contexts.level,
       pg_get_backend_memory_contexts.total_bytes,
       pg_get_backend_memory_contexts.total_nblocks,
       pg_get_backend_memory_contexts.free_bytes,
       pg_get_backend_memory_contexts.free_chunks,
       pg_get_backend_memory_contexts.used_bytes
FROM pg_get_backend_memory_contexts() pg_get_backend_memory_contexts(name, ident, parent, level, total_bytes,
                                                                     total_nblocks, free_bytes, free_chunks,
                                                                     used_bytes);

alter table pg_catalog.pg_backend_memory_contexts
    owner to "kim-uijin";

create view pg_catalog.pg_stat_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
SELECT c.oid                                                                                     AS relid,
       n.nspname                                                                                 AS schemaname,
       c.relname,
       pg_stat_get_numscans(c.oid)                                                               AS seq_scan,
       pg_stat_get_tuples_returned(c.oid)                                                        AS seq_tup_read,
       sum(pg_stat_get_numscans(i.indexrelid))::bigint                                           AS idx_scan,
       sum(pg_stat_get_tuples_fetched(i.indexrelid))::bigint + pg_stat_get_tuples_fetched(c.oid) AS idx_tup_fetch,
       pg_stat_get_tuples_inserted(c.oid)                                                        AS n_tup_ins,
       pg_stat_get_tuples_updated(c.oid)                                                         AS n_tup_upd,
       pg_stat_get_tuples_deleted(c.oid)                                                         AS n_tup_del,
       pg_stat_get_tuples_hot_updated(c.oid)                                                     AS n_tup_hot_upd,
       pg_stat_get_live_tuples(c.oid)                                                            AS n_live_tup,
       pg_stat_get_dead_tuples(c.oid)                                                            AS n_dead_tup,
       pg_stat_get_mod_since_analyze(c.oid)                                                      AS n_mod_since_analyze,
       pg_stat_get_ins_since_vacuum(c.oid)                                                       AS n_ins_since_vacuum,
       pg_stat_get_last_vacuum_time(c.oid)                                                       AS last_vacuum,
       pg_stat_get_last_autovacuum_time(c.oid)                                                   AS last_autovacuum,
       pg_stat_get_last_analyze_time(c.oid)                                                      AS last_analyze,
       pg_stat_get_last_autoanalyze_time(c.oid)                                                  AS last_autoanalyze,
       pg_stat_get_vacuum_count(c.oid)                                                           AS vacuum_count,
       pg_stat_get_autovacuum_count(c.oid)                                                       AS autovacuum_count,
       pg_stat_get_analyze_count(c.oid)                                                          AS analyze_count,
       pg_stat_get_autoanalyze_count(c.oid)                                                      AS autoanalyze_count
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char", 'p'::"char"])
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_all_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_all_tables to public;

create view pg_catalog.pg_stat_xact_all_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT c.oid                                                                                               AS relid,
       n.nspname                                                                                           AS schemaname,
       c.relname,
       pg_stat_get_xact_numscans(c.oid)                                                                    AS seq_scan,
       pg_stat_get_xact_tuples_returned(c.oid)                                                             AS seq_tup_read,
       sum(pg_stat_get_xact_numscans(i.indexrelid))::bigint                                                AS idx_scan,
       sum(pg_stat_get_xact_tuples_fetched(i.indexrelid))::bigint +
       pg_stat_get_xact_tuples_fetched(c.oid)                                                              AS idx_tup_fetch,
       pg_stat_get_xact_tuples_inserted(c.oid)                                                             AS n_tup_ins,
       pg_stat_get_xact_tuples_updated(c.oid)                                                              AS n_tup_upd,
       pg_stat_get_xact_tuples_deleted(c.oid)                                                              AS n_tup_del,
       pg_stat_get_xact_tuples_hot_updated(c.oid)                                                          AS n_tup_hot_upd
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char", 'p'::"char"])
GROUP BY c.oid, n.nspname, c.relname;

alter table pg_catalog.pg_stat_xact_all_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_xact_all_tables to public;

create view pg_catalog.pg_stat_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.n_ins_since_vacuum,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE (pg_stat_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_sys_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_sys_tables to public;

create view pg_catalog.pg_stat_xact_sys_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE (pg_stat_xact_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_xact_sys_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_xact_sys_tables to public;

create view pg_catalog.pg_stat_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd, n_live_tup, n_dead_tup, n_mod_since_analyze, n_ins_since_vacuum, last_vacuum,
             last_autovacuum, last_analyze, last_autoanalyze, vacuum_count, autovacuum_count, analyze_count,
             autoanalyze_count)
as
SELECT pg_stat_all_tables.relid,
       pg_stat_all_tables.schemaname,
       pg_stat_all_tables.relname,
       pg_stat_all_tables.seq_scan,
       pg_stat_all_tables.seq_tup_read,
       pg_stat_all_tables.idx_scan,
       pg_stat_all_tables.idx_tup_fetch,
       pg_stat_all_tables.n_tup_ins,
       pg_stat_all_tables.n_tup_upd,
       pg_stat_all_tables.n_tup_del,
       pg_stat_all_tables.n_tup_hot_upd,
       pg_stat_all_tables.n_live_tup,
       pg_stat_all_tables.n_dead_tup,
       pg_stat_all_tables.n_mod_since_analyze,
       pg_stat_all_tables.n_ins_since_vacuum,
       pg_stat_all_tables.last_vacuum,
       pg_stat_all_tables.last_autovacuum,
       pg_stat_all_tables.last_analyze,
       pg_stat_all_tables.last_autoanalyze,
       pg_stat_all_tables.vacuum_count,
       pg_stat_all_tables.autovacuum_count,
       pg_stat_all_tables.analyze_count,
       pg_stat_all_tables.autoanalyze_count
FROM pg_stat_all_tables
WHERE (pg_stat_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_user_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_user_tables to public;

create view pg_catalog.pg_stat_xact_user_tables
            (relid, schemaname, relname, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins, n_tup_upd,
             n_tup_del, n_tup_hot_upd)
as
SELECT pg_stat_xact_all_tables.relid,
       pg_stat_xact_all_tables.schemaname,
       pg_stat_xact_all_tables.relname,
       pg_stat_xact_all_tables.seq_scan,
       pg_stat_xact_all_tables.seq_tup_read,
       pg_stat_xact_all_tables.idx_scan,
       pg_stat_xact_all_tables.idx_tup_fetch,
       pg_stat_xact_all_tables.n_tup_ins,
       pg_stat_xact_all_tables.n_tup_upd,
       pg_stat_xact_all_tables.n_tup_del,
       pg_stat_xact_all_tables.n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE (pg_stat_xact_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_xact_user_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_xact_user_tables to public;

create view pg_catalog.pg_statio_all_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT c.oid                                                                                        AS relid,
       n.nspname                                                                                    AS schemaname,
       c.relname,
       pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)                            AS heap_blks_read,
       pg_stat_get_blocks_hit(c.oid)                                                                AS heap_blks_hit,
       sum(pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))::bigint AS idx_blks_read,
       sum(pg_stat_get_blocks_hit(i.indexrelid))::bigint                                            AS idx_blks_hit,
       pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)                            AS toast_blks_read,
       pg_stat_get_blocks_hit(t.oid)                                                                AS toast_blks_hit,
       pg_stat_get_blocks_fetched(x.indexrelid) - pg_stat_get_blocks_hit(x.indexrelid)              AS tidx_blks_read,
       pg_stat_get_blocks_hit(x.indexrelid)                                                         AS tidx_blks_hit
FROM pg_class c
         LEFT JOIN pg_index i ON c.oid = i.indrelid
         LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
         LEFT JOIN pg_index x ON t.oid = x.indrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"])
GROUP BY c.oid, n.nspname, c.relname, t.oid, x.indexrelid;

alter table pg_catalog.pg_statio_all_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_all_tables to public;

create view pg_catalog.pg_statio_sys_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE (pg_statio_all_tables.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_tables.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_sys_tables to public;

create view pg_catalog.pg_statio_user_tables
            (relid, schemaname, relname, heap_blks_read, heap_blks_hit, idx_blks_read, idx_blks_hit, toast_blks_read,
             toast_blks_hit, tidx_blks_read, tidx_blks_hit)
as
SELECT pg_statio_all_tables.relid,
       pg_statio_all_tables.schemaname,
       pg_statio_all_tables.relname,
       pg_statio_all_tables.heap_blks_read,
       pg_statio_all_tables.heap_blks_hit,
       pg_statio_all_tables.idx_blks_read,
       pg_statio_all_tables.idx_blks_hit,
       pg_statio_all_tables.toast_blks_read,
       pg_statio_all_tables.toast_blks_hit,
       pg_statio_all_tables.tidx_blks_read,
       pg_statio_all_tables.tidx_blks_hit
FROM pg_statio_all_tables
WHERE (pg_statio_all_tables.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_tables.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_tables
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_user_tables to public;

create view pg_catalog.pg_stat_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT c.oid                              AS relid,
       i.oid                              AS indexrelid,
       n.nspname                          AS schemaname,
       c.relname,
       i.relname                          AS indexrelname,
       pg_stat_get_numscans(i.oid)        AS idx_scan,
       pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,
       pg_stat_get_tuples_fetched(i.oid)  AS idx_tup_fetch
FROM pg_class c
         JOIN pg_index x ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]);

alter table pg_catalog.pg_stat_all_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_all_indexes to public;

create view pg_catalog.pg_stat_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE (pg_stat_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_stat_all_indexes.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_sys_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_sys_indexes to public;

create view pg_catalog.pg_stat_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch) as
SELECT pg_stat_all_indexes.relid,
       pg_stat_all_indexes.indexrelid,
       pg_stat_all_indexes.schemaname,
       pg_stat_all_indexes.relname,
       pg_stat_all_indexes.indexrelname,
       pg_stat_all_indexes.idx_scan,
       pg_stat_all_indexes.idx_tup_read,
       pg_stat_all_indexes.idx_tup_fetch
FROM pg_stat_all_indexes
WHERE (pg_stat_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_stat_all_indexes.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_stat_user_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_user_indexes to public;

create view pg_catalog.pg_statio_all_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT c.oid                                                             AS relid,
       i.oid                                                             AS indexrelid,
       n.nspname                                                         AS schemaname,
       c.relname,
       i.relname                                                         AS indexrelname,
       pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid) AS idx_blks_read,
       pg_stat_get_blocks_hit(i.oid)                                     AS idx_blks_hit
FROM pg_class c
         JOIN pg_index x ON c.oid = x.indrelid
         JOIN pg_class i ON i.oid = x.indexrelid
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = ANY (ARRAY ['r'::"char", 't'::"char", 'm'::"char"]);

alter table pg_catalog.pg_statio_all_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_all_indexes to public;

create view pg_catalog.pg_statio_sys_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE (pg_statio_all_indexes.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_indexes.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_sys_indexes to public;

create view pg_catalog.pg_statio_user_indexes
            (relid, indexrelid, schemaname, relname, indexrelname, idx_blks_read, idx_blks_hit) as
SELECT pg_statio_all_indexes.relid,
       pg_statio_all_indexes.indexrelid,
       pg_statio_all_indexes.schemaname,
       pg_statio_all_indexes.relname,
       pg_statio_all_indexes.indexrelname,
       pg_statio_all_indexes.idx_blks_read,
       pg_statio_all_indexes.idx_blks_hit
FROM pg_statio_all_indexes
WHERE (pg_statio_all_indexes.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_indexes.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_indexes
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_user_indexes to public;

create view pg_catalog.pg_statio_all_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT c.oid                                                             AS relid,
       n.nspname                                                         AS schemaname,
       c.relname,
       pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid) AS blks_read,
       pg_stat_get_blocks_hit(c.oid)                                     AS blks_hit
FROM pg_class c
         LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'S'::"char";

alter table pg_catalog.pg_statio_all_sequences
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_all_sequences to public;

create view pg_catalog.pg_statio_sys_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE (pg_statio_all_sequences.schemaname = ANY (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
   OR pg_statio_all_sequences.schemaname ~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_sys_sequences
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_sys_sequences to public;

create view pg_catalog.pg_statio_user_sequences(relid, schemaname, relname, blks_read, blks_hit) as
SELECT pg_statio_all_sequences.relid,
       pg_statio_all_sequences.schemaname,
       pg_statio_all_sequences.relname,
       pg_statio_all_sequences.blks_read,
       pg_statio_all_sequences.blks_hit
FROM pg_statio_all_sequences
WHERE (pg_statio_all_sequences.schemaname <> ALL (ARRAY ['pg_catalog'::name, 'information_schema'::name]))
  AND pg_statio_all_sequences.schemaname !~ '^pg_toast'::text;

alter table pg_catalog.pg_statio_user_sequences
    owner to "kim-uijin";

grant select on pg_catalog.pg_statio_user_sequences to public;

create view pg_catalog.pg_stat_activity
            (datid, datname, pid, leader_pid, usesysid, usename, application_name, client_addr, client_hostname,
             client_port, backend_start, xact_start, query_start, state_change, wait_event_type, wait_event, state,
             backend_xid, backend_xmin, query_id, query, backend_type)
as
SELECT s.datid,
       d.datname,
       s.pid,
       s.leader_pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.xact_start,
       s.query_start,
       s.state_change,
       s.wait_event_type,
       s.wait_event,
       s.state,
       s.backend_xid,
       s.backend_xmin,
       s.query_id,
       s.query,
       s.backend_type
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn,
                                           ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid,
                                           query_id)
         LEFT JOIN pg_database d ON s.datid = d.oid
         LEFT JOIN pg_authid u ON s.usesysid = u.oid;

alter table pg_catalog.pg_stat_activity
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_activity to public;

create view pg_catalog.pg_stat_replication
            (pid, usesysid, usename, application_name, client_addr, client_hostname, client_port, backend_start,
             backend_xmin, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag,
             sync_priority, sync_state, reply_time)
as
SELECT s.pid,
       s.usesysid,
       u.rolname AS usename,
       s.application_name,
       s.client_addr,
       s.client_hostname,
       s.client_port,
       s.backend_start,
       s.backend_xmin,
       w.state,
       w.sent_lsn,
       w.write_lsn,
       w.flush_lsn,
       w.replay_lsn,
       w.write_lag,
       w.flush_lag,
       w.replay_lag,
       w.sync_priority,
       w.sync_state,
       w.reply_time
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn,
                                           ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid,
                                           query_id)
         JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag,
                                          replay_lag, sync_priority, sync_state, reply_time) ON s.pid = w.pid
         LEFT JOIN pg_authid u ON s.usesysid = u.oid;

alter table pg_catalog.pg_stat_replication
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_replication to public;

create view pg_catalog.pg_stat_slru
            (name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset) as
SELECT s.name,
       s.blks_zeroed,
       s.blks_hit,
       s.blks_read,
       s.blks_written,
       s.blks_exists,
       s.flushes,
       s.truncates,
       s.stats_reset
FROM pg_stat_get_slru() s(name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates,
                          stats_reset);

alter table pg_catalog.pg_stat_slru
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_slru to public;

create view pg_catalog.pg_stat_wal_receiver
            (pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli,
             last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host,
             sender_port, conninfo)
as
SELECT s.pid,
       s.status,
       s.receive_start_lsn,
       s.receive_start_tli,
       s.written_lsn,
       s.flushed_lsn,
       s.received_tli,
       s.last_msg_send_time,
       s.last_msg_receipt_time,
       s.latest_end_lsn,
       s.latest_end_time,
       s.slot_name,
       s.sender_host,
       s.sender_port,
       s.conninfo
FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn,
                                  received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
                                  latest_end_time, slot_name, sender_host, sender_port, conninfo)
WHERE s.pid IS NOT NULL;

alter table pg_catalog.pg_stat_wal_receiver
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_wal_receiver to public;

create view pg_catalog.pg_stat_subscription
            (subid, subname, pid, relid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn,
             latest_end_time) as
SELECT su.oid AS subid,
       su.subname,
       st.pid,
       st.relid,
       st.received_lsn,
       st.last_msg_send_time,
       st.last_msg_receipt_time,
       st.latest_end_lsn,
       st.latest_end_time
FROM pg_subscription su
         LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, received_lsn, last_msg_send_time,
                                                          last_msg_receipt_time, latest_end_lsn, latest_end_time)
                   ON st.subid = su.oid;

alter table pg_catalog.pg_stat_subscription
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_subscription to public;

create view pg_catalog.pg_stat_ssl(pid, ssl, version, cipher, bits, client_dn, client_serial, issuer_dn) as
SELECT s.pid,
       s.ssl,
       s.sslversion        AS version,
       s.sslcipher         AS cipher,
       s.sslbits           AS bits,
       s.ssl_client_dn     AS client_dn,
       s.ssl_client_serial AS client_serial,
       s.ssl_issuer_dn     AS issuer_dn
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn,
                                           ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid,
                                           query_id)
WHERE s.client_port IS NOT NULL;

alter table pg_catalog.pg_stat_ssl
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_ssl to public;

create view pg_catalog.pg_stat_gssapi(pid, gss_authenticated, principal, encrypted) as
SELECT s.pid,
       s.gss_auth  AS gss_authenticated,
       s.gss_princ AS principal,
       s.gss_enc   AS encrypted
FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type,
                                           wait_event, xact_start, query_start, backend_start, state_change,
                                           client_addr, client_hostname, client_port, backend_xid, backend_xmin,
                                           backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn,
                                           ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, leader_pid,
                                           query_id)
WHERE s.client_port IS NOT NULL;

alter table pg_catalog.pg_stat_gssapi
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_gssapi to public;

create view pg_catalog.pg_replication_slots
            (slot_name, plugin, slot_type, datoid, database, temporary, active, active_pid, xmin, catalog_xmin,
             restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase)
as
SELECT l.slot_name,
       l.plugin,
       l.slot_type,
       l.datoid,
       d.datname AS database,
       l.temporary,
       l.active,
       l.active_pid,
       l.xmin,
       l.catalog_xmin,
       l.restart_lsn,
       l.confirmed_flush_lsn,
       l.wal_status,
       l.safe_wal_size,
       l.two_phase
FROM pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin,
                                  catalog_xmin, restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase)
         LEFT JOIN pg_database d ON l.datoid = d.oid;

alter table pg_catalog.pg_replication_slots
    owner to "kim-uijin";

grant select on pg_catalog.pg_replication_slots to public;

create view pg_catalog.pg_stat_replication_slots
            (slot_name, spill_txns, spill_count, spill_bytes, stream_txns, stream_count, stream_bytes, total_txns,
             total_bytes, stats_reset)
as
SELECT s.slot_name,
       s.spill_txns,
       s.spill_count,
       s.spill_bytes,
       s.stream_txns,
       s.stream_count,
       s.stream_bytes,
       s.total_txns,
       s.total_bytes,
       s.stats_reset
FROM pg_replication_slots r,
     LATERAL pg_stat_get_replication_slot(r.slot_name::text) s(slot_name, spill_txns, spill_count, spill_bytes,
                                                               stream_txns, stream_count, stream_bytes, total_txns,
                                                               total_bytes, stats_reset)
WHERE r.datoid IS NOT NULL;

alter table pg_catalog.pg_stat_replication_slots
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_replication_slots to public;

create view pg_catalog.pg_stat_database
            (datid, datname, numbackends, xact_commit, xact_rollback, blks_read, blks_hit, tup_returned, tup_fetched,
             tup_inserted, tup_updated, tup_deleted, conflicts, temp_files, temp_bytes, deadlocks, checksum_failures,
             checksum_last_failure, blk_read_time, blk_write_time, session_time, active_time, idle_in_transaction_time,
             sessions, sessions_abandoned, sessions_fatal, sessions_killed, stats_reset)
as
SELECT d.oid                                                                   AS datid,
       d.datname,
       CASE
           WHEN d.oid = 0::oid THEN 0
           ELSE pg_stat_get_db_numbackends(d.oid)
           END                                                                 AS numbackends,
       pg_stat_get_db_xact_commit(d.oid)                                       AS xact_commit,
       pg_stat_get_db_xact_rollback(d.oid)                                     AS xact_rollback,
       pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid) AS blks_read,
       pg_stat_get_db_blocks_hit(d.oid)                                        AS blks_hit,
       pg_stat_get_db_tuples_returned(d.oid)                                   AS tup_returned,
       pg_stat_get_db_tuples_fetched(d.oid)                                    AS tup_fetched,
       pg_stat_get_db_tuples_inserted(d.oid)                                   AS tup_inserted,
       pg_stat_get_db_tuples_updated(d.oid)                                    AS tup_updated,
       pg_stat_get_db_tuples_deleted(d.oid)                                    AS tup_deleted,
       pg_stat_get_db_conflict_all(d.oid)                                      AS conflicts,
       pg_stat_get_db_temp_files(d.oid)                                        AS temp_files,
       pg_stat_get_db_temp_bytes(d.oid)                                        AS temp_bytes,
       pg_stat_get_db_deadlocks(d.oid)                                         AS deadlocks,
       pg_stat_get_db_checksum_failures(d.oid)                                 AS checksum_failures,
       pg_stat_get_db_checksum_last_failure(d.oid)                             AS checksum_last_failure,
       pg_stat_get_db_blk_read_time(d.oid)                                     AS blk_read_time,
       pg_stat_get_db_blk_write_time(d.oid)                                    AS blk_write_time,
       pg_stat_get_db_session_time(d.oid)                                      AS session_time,
       pg_stat_get_db_active_time(d.oid)                                       AS active_time,
       pg_stat_get_db_idle_in_transaction_time(d.oid)                          AS idle_in_transaction_time,
       pg_stat_get_db_sessions(d.oid)                                          AS sessions,
       pg_stat_get_db_sessions_abandoned(d.oid)                                AS sessions_abandoned,
       pg_stat_get_db_sessions_fatal(d.oid)                                    AS sessions_fatal,
       pg_stat_get_db_sessions_killed(d.oid)                                   AS sessions_killed,
       pg_stat_get_db_stat_reset_time(d.oid)                                   AS stats_reset
FROM (SELECT 0          AS oid,
             NULL::name AS datname
      UNION ALL
      SELECT pg_database.oid,
             pg_database.datname
      FROM pg_database) d;

alter table pg_catalog.pg_stat_database
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_database to public;

create view pg_catalog.pg_stat_database_conflicts
            (datid, datname, confl_tablespace, confl_lock, confl_snapshot, confl_bufferpin, confl_deadlock) as
SELECT d.oid                                           AS datid,
       d.datname,
       pg_stat_get_db_conflict_tablespace(d.oid)       AS confl_tablespace,
       pg_stat_get_db_conflict_lock(d.oid)             AS confl_lock,
       pg_stat_get_db_conflict_snapshot(d.oid)         AS confl_snapshot,
       pg_stat_get_db_conflict_bufferpin(d.oid)        AS confl_bufferpin,
       pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock
FROM pg_database d;

alter table pg_catalog.pg_stat_database_conflicts
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_database_conflicts to public;

create view pg_catalog.pg_stat_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                  AS funcid,
       n.nspname                              AS schemaname,
       p.proname                              AS funcname,
       pg_stat_get_function_calls(p.oid)      AS calls,
       pg_stat_get_function_total_time(p.oid) AS total_time,
       pg_stat_get_function_self_time(p.oid)  AS self_time
FROM pg_proc p
         LEFT JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prolang <> 12::oid
  AND pg_stat_get_function_calls(p.oid) IS NOT NULL;

alter table pg_catalog.pg_stat_user_functions
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_user_functions to public;

create view pg_catalog.pg_stat_xact_user_functions(funcid, schemaname, funcname, calls, total_time, self_time) as
SELECT p.oid                                       AS funcid,
       n.nspname                                   AS schemaname,
       p.proname                                   AS funcname,
       pg_stat_get_xact_function_calls(p.oid)      AS calls,
       pg_stat_get_xact_function_total_time(p.oid) AS total_time,
       pg_stat_get_xact_function_self_time(p.oid)  AS self_time
FROM pg_proc p
         LEFT JOIN pg_namespace n ON n.oid = p.pronamespace
WHERE p.prolang <> 12::oid
  AND pg_stat_get_xact_function_calls(p.oid) IS NOT NULL;

alter table pg_catalog.pg_stat_xact_user_functions
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_xact_user_functions to public;

create view pg_catalog.pg_stat_archiver
            (archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time,
             stats_reset) as
SELECT s.archived_count,
       s.last_archived_wal,
       s.last_archived_time,
       s.failed_count,
       s.last_failed_wal,
       s.last_failed_time,
       s.stats_reset
FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal,
                              last_failed_time, stats_reset);

alter table pg_catalog.pg_stat_archiver
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_archiver to public;

create view pg_catalog.pg_stat_bgwriter
            (checkpoints_timed, checkpoints_req, checkpoint_write_time, checkpoint_sync_time, buffers_checkpoint,
             buffers_clean, maxwritten_clean, buffers_backend, buffers_backend_fsync, buffers_alloc, stats_reset)
as
SELECT pg_stat_get_bgwriter_timed_checkpoints()       AS checkpoints_timed,
       pg_stat_get_bgwriter_requested_checkpoints()   AS checkpoints_req,
       pg_stat_get_checkpoint_write_time()            AS checkpoint_write_time,
       pg_stat_get_checkpoint_sync_time()             AS checkpoint_sync_time,
       pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint,
       pg_stat_get_bgwriter_buf_written_clean()       AS buffers_clean,
       pg_stat_get_bgwriter_maxwritten_clean()        AS maxwritten_clean,
       pg_stat_get_buf_written_backend()              AS buffers_backend,
       pg_stat_get_buf_fsync_backend()                AS buffers_backend_fsync,
       pg_stat_get_buf_alloc()                        AS buffers_alloc,
       pg_stat_get_bgwriter_stat_reset_time()         AS stats_reset;

alter table pg_catalog.pg_stat_bgwriter
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_bgwriter to public;

create view pg_catalog.pg_stat_wal
            (wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time, wal_sync_time,
             stats_reset) as
SELECT w.wal_records,
       w.wal_fpi,
       w.wal_bytes,
       w.wal_buffers_full,
       w.wal_write,
       w.wal_sync,
       w.wal_write_time,
       w.wal_sync_time,
       w.stats_reset
FROM pg_stat_get_wal() w(wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time,
                         wal_sync_time, stats_reset);

alter table pg_catalog.pg_stat_wal
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_wal to public;

create view pg_catalog.pg_stat_progress_analyze
            (pid, datid, datname, relid, phase, sample_blks_total, sample_blks_scanned, ext_stats_total,
             ext_stats_computed, child_tables_total, child_tables_done, current_child_table_relid)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'acquiring sample rows'::text
           WHEN 2 THEN 'acquiring inherited sample rows'::text
           WHEN 3 THEN 'computing statistics'::text
           WHEN 4 THEN 'computing extended statistics'::text
           WHEN 5 THEN 'finalizing analyze'::text
           ELSE NULL::text
           END       AS phase,
       s.param2      AS sample_blks_total,
       s.param3      AS sample_blks_scanned,
       s.param4      AS ext_stats_total,
       s.param5      AS ext_stats_computed,
       s.param6      AS child_tables_total,
       s.param7      AS child_tables_done,
       s.param8::oid AS current_child_table_relid
FROM pg_stat_get_progress_info('ANALYZE'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                  param7, param8, param9, param10, param11, param12, param13, param14,
                                                  param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_analyze
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_analyze to public;

create view pg_catalog.pg_stat_progress_vacuum
            (pid, datid, datname, relid, phase, heap_blks_total, heap_blks_scanned, heap_blks_vacuumed,
             index_vacuum_count, max_dead_tuples, num_dead_tuples)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'scanning heap'::text
           WHEN 2 THEN 'vacuuming indexes'::text
           WHEN 3 THEN 'vacuuming heap'::text
           WHEN 4 THEN 'cleaning up indexes'::text
           WHEN 5 THEN 'truncating heap'::text
           WHEN 6 THEN 'performing final cleanup'::text
           ELSE NULL::text
           END  AS phase,
       s.param2 AS heap_blks_total,
       s.param3 AS heap_blks_scanned,
       s.param4 AS heap_blks_vacuumed,
       s.param5 AS index_vacuum_count,
       s.param6 AS max_dead_tuples,
       s.param7 AS num_dead_tuples
FROM pg_stat_get_progress_info('VACUUM'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                 param7, param8, param9, param10, param11, param12, param13, param14,
                                                 param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_vacuum
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_vacuum to public;

create view pg_catalog.pg_stat_progress_cluster
            (pid, datid, datname, relid, command, phase, cluster_index_relid, heap_tuples_scanned, heap_tuples_written,
             heap_blks_total, heap_blks_scanned, index_rebuild_count)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param1
           WHEN 1 THEN 'CLUSTER'::text
           WHEN 2 THEN 'VACUUM FULL'::text
           ELSE NULL::text
           END       AS command,
       CASE s.param2
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'seq scanning heap'::text
           WHEN 2 THEN 'index scanning heap'::text
           WHEN 3 THEN 'sorting tuples'::text
           WHEN 4 THEN 'writing new heap'::text
           WHEN 5 THEN 'swapping relation files'::text
           WHEN 6 THEN 'rebuilding index'::text
           WHEN 7 THEN 'performing final cleanup'::text
           ELSE NULL::text
           END       AS phase,
       s.param3::oid AS cluster_index_relid,
       s.param4      AS heap_tuples_scanned,
       s.param5      AS heap_tuples_written,
       s.param6      AS heap_blks_total,
       s.param7      AS heap_blks_scanned,
       s.param8      AS index_rebuild_count
FROM pg_stat_get_progress_info('CLUSTER'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                  param7, param8, param9, param10, param11, param12, param13, param14,
                                                  param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_cluster
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_cluster to public;

create view pg_catalog.pg_stat_progress_create_index
            (pid, datid, datname, relid, index_relid, command, phase, lockers_total, lockers_done, current_locker_pid,
             blocks_total, blocks_done, tuples_total, tuples_done, partitions_total, partitions_done)
as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       s.param7::oid AS index_relid,
       CASE s.param1
           WHEN 1 THEN 'CREATE INDEX'::text
           WHEN 2 THEN 'CREATE INDEX CONCURRENTLY'::text
           WHEN 3 THEN 'REINDEX'::text
           WHEN 4 THEN 'REINDEX CONCURRENTLY'::text
           ELSE NULL::text
           END       AS command,
       CASE s.param10
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'waiting for writers before build'::text
           WHEN 2 THEN 'building index'::text ||
                       COALESCE(': '::text || pg_indexam_progress_phasename(s.param9::oid, s.param11), ''::text)
           WHEN 3 THEN 'waiting for writers before validation'::text
           WHEN 4 THEN 'index validation: scanning index'::text
           WHEN 5 THEN 'index validation: sorting tuples'::text
           WHEN 6 THEN 'index validation: scanning table'::text
           WHEN 7 THEN 'waiting for old snapshots'::text
           WHEN 8 THEN 'waiting for readers before marking dead'::text
           WHEN 9 THEN 'waiting for readers before dropping'::text
           ELSE NULL::text
           END       AS phase,
       s.param4      AS lockers_total,
       s.param5      AS lockers_done,
       s.param6      AS current_locker_pid,
       s.param16     AS blocks_total,
       s.param17     AS blocks_done,
       s.param12     AS tuples_total,
       s.param13     AS tuples_done,
       s.param14     AS partitions_total,
       s.param15     AS partitions_done
FROM pg_stat_get_progress_info('CREATE INDEX'::text) s(pid, datid, relid, param1, param2, param3, param4, param5,
                                                       param6, param7, param8, param9, param10, param11, param12,
                                                       param13, param14, param15, param16, param17, param18, param19,
                                                       param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_create_index
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_create_index to public;

create view pg_catalog.pg_stat_progress_basebackup
            (pid, phase, backup_total, backup_streamed, tablespaces_total, tablespaces_streamed) as
SELECT s.pid,
       CASE s.param1
           WHEN 0 THEN 'initializing'::text
           WHEN 1 THEN 'waiting for checkpoint to finish'::text
           WHEN 2 THEN 'estimating backup size'::text
           WHEN 3 THEN 'streaming database files'::text
           WHEN 4 THEN 'waiting for wal archiving to finish'::text
           WHEN 5 THEN 'transferring wal files'::text
           ELSE NULL::text
           END  AS phase,
       CASE s.param2
           WHEN '-1'::integer THEN NULL::bigint
           ELSE s.param2
           END  AS backup_total,
       s.param3 AS backup_streamed,
       s.param4 AS tablespaces_total,
       s.param5 AS tablespaces_streamed
FROM pg_stat_get_progress_info('BASEBACKUP'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                                     param7, param8, param9, param10, param11, param12, param13,
                                                     param14, param15, param16, param17, param18, param19, param20);

alter table pg_catalog.pg_stat_progress_basebackup
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_basebackup to public;

create view pg_catalog.pg_stat_progress_copy
            (pid, datid, datname, relid, command, type, bytes_processed, bytes_total, tuples_processed,
             tuples_excluded) as
SELECT s.pid,
       s.datid,
       d.datname,
       s.relid,
       CASE s.param5
           WHEN 1 THEN 'COPY FROM'::text
           WHEN 2 THEN 'COPY TO'::text
           ELSE NULL::text
           END  AS command,
       CASE s.param6
           WHEN 1 THEN 'FILE'::text
           WHEN 2 THEN 'PROGRAM'::text
           WHEN 3 THEN 'PIPE'::text
           WHEN 4 THEN 'CALLBACK'::text
           ELSE NULL::text
           END  AS type,
       s.param1 AS bytes_processed,
       s.param2 AS bytes_total,
       s.param3 AS tuples_processed,
       s.param4 AS tuples_excluded
FROM pg_stat_get_progress_info('COPY'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6,
                                               param7, param8, param9, param10, param11, param12, param13, param14,
                                               param15, param16, param17, param18, param19, param20)
         LEFT JOIN pg_database d ON s.datid = d.oid;

alter table pg_catalog.pg_stat_progress_copy
    owner to "kim-uijin";

grant select on pg_catalog.pg_stat_progress_copy to public;

create view pg_catalog.pg_user_mappings(umid, srvid, srvname, umuser, usename, umoptions) as
SELECT u.oid   AS umid,
       s.oid   AS srvid,
       s.srvname,
       u.umuser,
       CASE
           WHEN u.umuser = 0::oid THEN 'public'::name
           ELSE a.rolname
           END AS usename,
       CASE
           WHEN u.umuser <> 0::oid AND a.rolname = CURRENT_USER AND
                (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) OR
                u.umuser = 0::oid AND pg_has_role(s.srvowner, 'USAGE'::text) OR (SELECT pg_authid.rolsuper
                                                                                 FROM pg_authid
                                                                                 WHERE pg_authid.rolname = CURRENT_USER)
               THEN u.umoptions
           ELSE NULL::text[]
           END AS umoptions
FROM pg_user_mapping u
         JOIN pg_foreign_server s ON u.umserver = s.oid
         LEFT JOIN pg_authid a ON a.oid = u.umuser;

alter table pg_catalog.pg_user_mappings
    owner to "kim-uijin";

grant select on pg_catalog.pg_user_mappings to public;

create view pg_catalog.pg_replication_origin_status(local_id, external_id, remote_lsn, local_lsn) as
SELECT pg_show_replication_origin_status.local_id,
       pg_show_replication_origin_status.external_id,
       pg_show_replication_origin_status.remote_lsn,
       pg_show_replication_origin_status.local_lsn
FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);

alter table pg_catalog.pg_replication_origin_status
    owner to "kim-uijin";

create view information_schema.information_schema_catalog_name(catalog_name) as
SELECT current_database()::information_schema.sql_identifier AS catalog_name;

alter table information_schema.information_schema_catalog_name
    owner to "kim-uijin";

grant select on information_schema.information_schema_catalog_name to public;

create view information_schema.applicable_roles(grantee, role_name, is_grantable) as
SELECT a.rolname::information_schema.sql_identifier AS grantee,
       b.rolname::information_schema.sql_identifier AS role_name,
       CASE
           WHEN m.admin_option THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no        AS is_grantable
FROM (SELECT pg_auth_members.member,
             pg_auth_members.roleid,
             pg_auth_members.admin_option
      FROM pg_auth_members
      UNION
      SELECT pg_database.datdba,
             pg_authid.oid,
             false AS bool
      FROM pg_database,
           pg_authid
      WHERE pg_database.datname = current_database()
        AND pg_authid.rolname = 'pg_database_owner'::name) m
         JOIN pg_authid a ON m.member = a.oid
         JOIN pg_authid b ON m.roleid = b.oid
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.applicable_roles
    owner to "kim-uijin";

grant select on information_schema.applicable_roles to public;

create view information_schema.administrable_role_authorizations(grantee, role_name, is_grantable) as
SELECT applicable_roles.grantee,
       applicable_roles.role_name,
       applicable_roles.is_grantable
FROM information_schema.applicable_roles
WHERE applicable_roles.is_grantable::text = 'YES'::text;

alter table information_schema.administrable_role_authorizations
    owner to "kim-uijin";

grant select on information_schema.administrable_role_authorizations to public;

create view information_schema.attributes
            (udt_catalog, udt_schema, udt_name, attribute_name, ordinal_position, attribute_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             attribute_udt_catalog, attribute_udt_schema, attribute_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, is_derived_reference_attribute)
as
SELECT current_database()::information_schema.sql_identifier                                                                           AS udt_catalog,
       nc.nspname::information_schema.sql_identifier                                                                                   AS udt_schema,
       c.relname::information_schema.sql_identifier                                                                                    AS udt_name,
       a.attname::information_schema.sql_identifier                                                                                    AS attribute_name,
       a.attnum::information_schema.cardinal_number                                                                                    AS ordinal_position,
       pg_get_expr(ad.adbin, ad.adrelid)::information_schema.character_data                                                            AS attribute_default,
       CASE
           WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text
           ELSE 'YES'::text
           END::information_schema.yes_or_no                                                                                           AS is_nullable,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                                                                      AS data_type,
       information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                              information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                                  AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                                  AS collation_name,
       information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS numeric_precision,
       information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                      information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,
       information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number      AS datetime_precision,
       information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                                               AS interval_precision,
       current_database()::information_schema.sql_identifier                                                                           AS attribute_udt_catalog,
       nt.nspname::information_schema.sql_identifier                                                                                   AS attribute_udt_schema,
       t.typname::information_schema.sql_identifier                                                                                    AS attribute_udt_name,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       a.attnum::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       'NO'::character varying::information_schema.yes_or_no                                                                           AS is_derived_reference_attribute
FROM pg_attribute a
         LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
         JOIN (pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid
         JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE a.attnum > 0
  AND NOT a.attisdropped
  AND c.relkind = 'c'::"char"
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_type_privilege(c.reltype, 'USAGE'::text));

alter table information_schema.attributes
    owner to "kim-uijin";

grant select on information_schema.attributes to public;

create view information_schema.character_sets
            (character_set_catalog, character_set_schema, character_set_name, character_repertoire, form_of_use,
             default_collate_catalog, default_collate_schema, default_collate_name)
as
SELECT NULL::name::information_schema.sql_identifier            AS character_set_catalog,
       NULL::name::information_schema.sql_identifier            AS character_set_schema,
       getdatabaseencoding()::information_schema.sql_identifier AS character_set_name,
       CASE
           WHEN getdatabaseencoding() = 'UTF8'::name THEN 'UCS'::name
           ELSE getdatabaseencoding()
           END::information_schema.sql_identifier               AS character_repertoire,
       getdatabaseencoding()::information_schema.sql_identifier AS form_of_use,
       current_database()::information_schema.sql_identifier    AS default_collate_catalog,
       nc.nspname::information_schema.sql_identifier            AS default_collate_schema,
       c.collname::information_schema.sql_identifier            AS default_collate_name
FROM pg_database d
         LEFT JOIN (pg_collation c
    JOIN pg_namespace nc ON c.collnamespace = nc.oid) ON d.datcollate = c.collcollate AND d.datctype = c.collctype
WHERE d.datname = current_database()
ORDER BY (char_length(c.collname::text)) DESC, c.collname
LIMIT 1;

alter table information_schema.character_sets
    owner to "kim-uijin";

grant select on information_schema.character_sets to public;

create view information_schema.check_constraint_routine_usage
            (constraint_catalog, constraint_schema, constraint_name, specific_catalog, specific_schema,
             specific_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS constraint_catalog,
                nc.nspname::information_schema.sql_identifier                      AS constraint_schema,
                c.conname::information_schema.sql_identifier                       AS constraint_name,
                current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name
FROM pg_namespace nc,
     pg_constraint c,
     pg_depend d,
     pg_proc p,
     pg_namespace np
WHERE nc.oid = c.connamespace
  AND c.contype = 'c'::"char"
  AND c.oid = d.objid
  AND d.classid = 'pg_constraint'::regclass::oid
  AND d.refobjid = p.oid
  AND d.refclassid = 'pg_proc'::regclass::oid
  AND p.pronamespace = np.oid
  AND pg_has_role(p.proowner, 'USAGE'::text);

alter table information_schema.check_constraint_routine_usage
    owner to "kim-uijin";

grant select on information_schema.check_constraint_routine_usage to public;

create view information_schema.check_constraints(constraint_catalog, constraint_schema, constraint_name, check_clause) as
SELECT current_database()::information_schema.sql_identifier                              AS constraint_catalog,
       rs.nspname::information_schema.sql_identifier                                      AS constraint_schema,
       con.conname::information_schema.sql_identifier                                     AS constraint_name,
       SUBSTRING(pg_get_constraintdef(con.oid) FROM 7)::information_schema.character_data AS check_clause
FROM pg_constraint con
         LEFT JOIN pg_namespace rs ON rs.oid = con.connamespace
         LEFT JOIN pg_class c ON c.oid = con.conrelid
         LEFT JOIN pg_type t ON t.oid = con.contypid
WHERE pg_has_role(COALESCE(c.relowner, t.typowner), 'USAGE'::text)
  AND con.contype = 'c'::"char"
UNION
SELECT current_database()::information_schema.sql_identifier                        AS constraint_catalog,
       n.nspname::information_schema.sql_identifier                                 AS constraint_schema,
       (((((n.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) ||
        '_not_null'::text)::information_schema.sql_identifier                       AS constraint_name,
       (a.attname::text || ' IS NOT NULL'::text)::information_schema.character_data AS check_clause
FROM pg_namespace n,
     pg_class r,
     pg_attribute a
WHERE n.oid = r.relnamespace
  AND r.oid = a.attrelid
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND a.attnotnull
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND pg_has_role(r.relowner, 'USAGE'::text);

alter table information_schema.check_constraints
    owner to "kim-uijin";

grant select on information_schema.check_constraints to public;

create view information_schema.collations(collation_catalog, collation_schema, collation_name, pad_attribute) as
SELECT current_database()::information_schema.sql_identifier          AS collation_catalog,
       nc.nspname::information_schema.sql_identifier                  AS collation_schema,
       c.collname::information_schema.sql_identifier                  AS collation_name,
       'NO PAD'::character varying::information_schema.character_data AS pad_attribute
FROM pg_collation c,
     pg_namespace nc
WHERE c.collnamespace = nc.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]));

alter table information_schema.collations
    owner to "kim-uijin";

grant select on information_schema.collations to public;

create view information_schema.collation_character_set_applicability
            (collation_catalog, collation_schema, collation_name, character_set_catalog, character_set_schema,
             character_set_name) as
SELECT current_database()::information_schema.sql_identifier    AS collation_catalog,
       nc.nspname::information_schema.sql_identifier            AS collation_schema,
       c.collname::information_schema.sql_identifier            AS collation_name,
       NULL::name::information_schema.sql_identifier            AS character_set_catalog,
       NULL::name::information_schema.sql_identifier            AS character_set_schema,
       getdatabaseencoding()::information_schema.sql_identifier AS character_set_name
FROM pg_collation c,
     pg_namespace nc
WHERE c.collnamespace = nc.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]));

alter table information_schema.collation_character_set_applicability
    owner to "kim-uijin";

grant select on information_schema.collation_character_set_applicability to public;

create view information_schema.column_column_usage
            (table_catalog, table_schema, table_name, column_name, dependent_column) as
SELECT DISTINCT current_database()::information_schema.sql_identifier AS table_catalog,
                n.nspname::information_schema.sql_identifier          AS table_schema,
                c.relname::information_schema.sql_identifier          AS table_name,
                ac.attname::information_schema.sql_identifier         AS column_name,
                ad.attname::information_schema.sql_identifier         AS dependent_column
FROM pg_namespace n,
     pg_class c,
     pg_depend d,
     pg_attribute ac,
     pg_attribute ad
WHERE n.oid = c.relnamespace
  AND c.oid = ac.attrelid
  AND c.oid = ad.attrelid
  AND d.classid = 'pg_class'::regclass::oid
  AND d.refclassid = 'pg_class'::regclass::oid
  AND d.objid = d.refobjid
  AND c.oid = d.objid
  AND d.objsubid = ad.attnum
  AND d.refobjsubid = ac.attnum
  AND ad.attgenerated <> ''::"char"
  AND pg_has_role(c.relowner, 'USAGE'::text);

alter table information_schema.column_column_usage
    owner to "kim-uijin";

grant select on information_schema.column_column_usage to public;

create view information_schema.column_domain_usage
            (domain_catalog, domain_schema, domain_name, table_catalog, table_schema, table_name, column_name) as
SELECT current_database()::information_schema.sql_identifier AS domain_catalog,
       nt.nspname::information_schema.sql_identifier         AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       a.attname::information_schema.sql_identifier          AS column_name
FROM pg_type t,
     pg_namespace nt,
     pg_class c,
     pg_namespace nc,
     pg_attribute a
WHERE t.typnamespace = nt.oid
  AND c.relnamespace = nc.oid
  AND a.attrelid = c.oid
  AND a.atttypid = t.oid
  AND t.typtype = 'd'::"char"
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND pg_has_role(t.typowner, 'USAGE'::text);

alter table information_schema.column_domain_usage
    owner to "kim-uijin";

grant select on information_schema.column_domain_usage to public;

create view information_schema.column_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
SELECT u_grantor.rolname::information_schema.sql_identifier  AS grantor,
       grantee.rolname::information_schema.sql_identifier    AS grantee,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       x.relname::information_schema.sql_identifier          AS table_name,
       x.attname::information_schema.sql_identifier          AS column_name,
       x.prtype::information_schema.character_data           AS privilege_type,
       CASE
           WHEN pg_has_role(x.grantee, x.relowner, 'USAGE'::text) OR x.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_grantable
FROM (SELECT pr_c.grantor,
             pr_c.grantee,
             a.attname,
             pr_c.relname,
             pr_c.relnamespace,
             pr_c.prtype,
             pr_c.grantable,
             pr_c.relowner
      FROM (SELECT pg_class.oid,
                   pg_class.relname,
                   pg_class.relnamespace,
                   pg_class.relowner,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).grantor                         AS grantor,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
                   (aclexplode(COALESCE(pg_class.relacl,
                                        acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
            FROM pg_class
            WHERE pg_class.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"])) pr_c(oid,
                                                                                                            relname,
                                                                                                            relnamespace,
                                                                                                            relowner,
                                                                                                            grantor,
                                                                                                            grantee,
                                                                                                            prtype,
                                                                                                            grantable),
           pg_attribute a
      WHERE a.attrelid = pr_c.oid
        AND a.attnum > 0
        AND NOT a.attisdropped
      UNION
      SELECT pr_a.grantor,
             pr_a.grantee,
             pr_a.attname,
             c.relname,
             c.relnamespace,
             pr_a.prtype,
             pr_a.grantable,
             c.relowner
      FROM (SELECT a.attrelid,
                   a.attname,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantor        AS grantor,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).grantee        AS grantee,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).privilege_type AS privilege_type,
                   (aclexplode(COALESCE(a.attacl, acldefault('c'::"char", cc.relowner)))).is_grantable   AS is_grantable
            FROM pg_attribute a
                     JOIN pg_class cc ON a.attrelid = cc.oid
            WHERE a.attnum > 0
              AND NOT a.attisdropped) pr_a(attrelid, attname, grantor, grantee, prtype, grantable),
           pg_class c
      WHERE pr_a.attrelid = c.oid
        AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))) x,
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE x.relnamespace = nc.oid
  AND x.grantee = grantee.oid
  AND x.grantor = u_grantor.oid
  AND (x.prtype = ANY (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'REFERENCES'::text]))
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.column_privileges
    owner to "kim-uijin";

grant select on information_schema.column_privileges to public;

create view information_schema.column_udt_usage
            (udt_catalog, udt_schema, udt_name, table_catalog, table_schema, table_name, column_name) as
SELECT current_database()::information_schema.sql_identifier                AS udt_catalog,
       COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier AS udt_schema,
       COALESCE(bt.typname, t.typname)::information_schema.sql_identifier   AS udt_name,
       current_database()::information_schema.sql_identifier                AS table_catalog,
       nc.nspname::information_schema.sql_identifier                        AS table_schema,
       c.relname::information_schema.sql_identifier                         AS table_name,
       a.attname::information_schema.sql_identifier                         AS column_name
FROM pg_attribute a,
     pg_class c,
     pg_namespace nc,
     pg_type t
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         LEFT JOIN (pg_type bt
         JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid
WHERE a.attrelid = c.oid
  AND a.atttypid = t.oid
  AND nc.oid = c.relnamespace
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND pg_has_role(COALESCE(bt.typowner, t.typowner), 'USAGE'::text);

alter table information_schema.column_udt_usage
    owner to "kim-uijin";

grant select on information_schema.column_udt_usage to public;

create view information_schema.columns
            (table_catalog, table_schema, table_name, column_name, ordinal_position, column_default, is_nullable,
             data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_precision_radix,
             numeric_scale, datetime_precision, interval_type, interval_precision, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             domain_catalog, domain_schema, domain_name, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema,
             scope_name, maximum_cardinality, dtd_identifier, is_self_referencing, is_identity, identity_generation,
             identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle, is_generated,
             generation_expression, is_updatable)
as
SELECT current_database()::information_schema.sql_identifier                                                                           AS table_catalog,
       nc.nspname::information_schema.sql_identifier                                                                                   AS table_schema,
       c.relname::information_schema.sql_identifier                                                                                    AS table_name,
       a.attname::information_schema.sql_identifier                                                                                    AS column_name,
       a.attnum::information_schema.cardinal_number                                                                                    AS ordinal_position,
       CASE
           WHEN a.attgenerated = ''::"char" THEN pg_get_expr(ad.adbin, ad.adrelid)
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS column_default,
       CASE
           WHEN a.attnotnull OR t.typtype = 'd'::"char" AND t.typnotnull THEN 'NO'::text
           ELSE 'YES'::text
           END::information_schema.yes_or_no                                                                                           AS is_nullable,
       CASE
           WHEN t.typtype = 'd'::"char" THEN
               CASE
                   WHEN bt.typelem <> 0::oid AND bt.typlen = '-1'::integer THEN 'ARRAY'::text
                   WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)
                   ELSE 'USER-DEFINED'::text
                   END
           ELSE
               CASE
                   WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
                   WHEN nt.nspname = 'pg_catalog'::name THEN format_type(a.atttypid, NULL::integer)
                   ELSE 'USER-DEFINED'::text
                   END
           END::information_schema.character_data                                                                                      AS data_type,
       information_schema._pg_char_max_length(information_schema._pg_truetypid(a.*, t.*),
                                              information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS character_octet_length,
       information_schema._pg_numeric_precision(information_schema._pg_truetypid(a.*, t.*),
                                                information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number       AS numeric_precision,
       information_schema._pg_numeric_precision_radix(information_schema._pg_truetypid(a.*, t.*),
                                                      information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number AS numeric_precision_radix,
       information_schema._pg_numeric_scale(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(information_schema._pg_truetypid(a.*, t.*),
                                                 information_schema._pg_truetypmod(a.*, t.*))::information_schema.cardinal_number      AS datetime_precision,
       information_schema._pg_interval_type(information_schema._pg_truetypid(a.*, t.*),
                                            information_schema._pg_truetypmod(a.*, t.*))::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                                               AS interval_precision,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                                  AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                                  AS collation_name,
       CASE
           WHEN t.typtype = 'd'::"char" THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_catalog,
       CASE
           WHEN t.typtype = 'd'::"char" THEN nt.nspname
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_schema,
       CASE
           WHEN t.typtype = 'd'::"char" THEN t.typname
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                                      AS domain_name,
       current_database()::information_schema.sql_identifier                                                                           AS udt_catalog,
       COALESCE(nbt.nspname, nt.nspname)::information_schema.sql_identifier                                                            AS udt_schema,
       COALESCE(bt.typname, t.typname)::information_schema.sql_identifier                                                              AS udt_name,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                                   AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                                               AS maximum_cardinality,
       a.attnum::information_schema.sql_identifier                                                                                     AS dtd_identifier,
       'NO'::character varying::information_schema.yes_or_no                                                                           AS is_self_referencing,
       CASE
           WHEN a.attidentity = ANY (ARRAY ['a'::"char", 'd'::"char"]) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS is_identity,
       CASE a.attidentity
           WHEN 'a'::"char" THEN 'ALWAYS'::text
           WHEN 'd'::"char" THEN 'BY DEFAULT'::text
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS identity_generation,
       seq.seqstart::information_schema.character_data                                                                                 AS identity_start,
       seq.seqincrement::information_schema.character_data                                                                             AS identity_increment,
       seq.seqmax::information_schema.character_data                                                                                   AS identity_maximum,
       seq.seqmin::information_schema.character_data                                                                                   AS identity_minimum,
       CASE
           WHEN seq.seqcycle THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS identity_cycle,
       CASE
           WHEN a.attgenerated <> ''::"char" THEN 'ALWAYS'::text
           ELSE 'NEVER'::text
           END::information_schema.character_data                                                                                      AS is_generated,
       CASE
           WHEN a.attgenerated <> ''::"char" THEN pg_get_expr(ad.adbin, ad.adrelid)
           ELSE NULL::text
           END::information_schema.character_data                                                                                      AS generation_expression,
       CASE
           WHEN (c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"])) OR
                (c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                pg_column_is_updatable(c.oid::regclass, a.attnum, false) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                                           AS is_updatable
FROM pg_attribute a
         LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum
         JOIN (pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid) ON a.attrelid = c.oid
         JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON a.atttypid = t.oid
         LEFT JOIN (pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typtype = 'd'::"char" AND t.typbasetype = bt.oid
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON a.attcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
         LEFT JOIN (pg_depend dep
    JOIN pg_sequence seq ON dep.classid = 'pg_class'::regclass::oid AND dep.objid = seq.seqrelid AND
                            dep.deptype = 'i'::"char")
                   ON dep.refclassid = 'pg_class'::regclass::oid AND dep.refobjid = c.oid AND dep.refobjsubid = a.attnum
WHERE NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.columns
    owner to "kim-uijin";

grant select on information_schema.columns to public;

create view information_schema.constraint_column_usage
            (table_catalog, table_schema, table_name, column_name, constraint_catalog, constraint_schema,
             constraint_name) as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       x.tblschema::information_schema.sql_identifier        AS table_schema,
       x.tblname::information_schema.sql_identifier          AS table_name,
       x.colname::information_schema.sql_identifier          AS column_name,
       current_database()::information_schema.sql_identifier AS constraint_catalog,
       x.cstrschema::information_schema.sql_identifier       AS constraint_schema,
       x.cstrname::information_schema.sql_identifier         AS constraint_name
FROM (SELECT DISTINCT nr.nspname,
                      r.relname,
                      r.relowner,
                      a.attname,
                      nc.nspname,
                      c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_depend d,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = a.attrelid
        AND d.refclassid = 'pg_class'::regclass::oid
        AND d.refobjid = r.oid
        AND d.refobjsubid = a.attnum
        AND d.classid = 'pg_constraint'::regclass::oid
        AND d.objid = c.oid
        AND c.connamespace = nc.oid
        AND c.contype = 'c'::"char"
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
        AND NOT a.attisdropped
      UNION ALL
      SELECT nr.nspname,
             r.relname,
             r.relowner,
             a.attname,
             nc.nspname,
             c.conname
      FROM pg_namespace nr,
           pg_class r,
           pg_attribute a,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = a.attrelid
        AND nc.oid = c.connamespace
        AND r.oid =
            CASE c.contype
                WHEN 'f'::"char" THEN c.confrelid
                ELSE c.conrelid
                END
        AND (a.attnum = ANY (
          CASE c.contype
              WHEN 'f'::"char" THEN c.confkey
              ELSE c.conkey
              END))
        AND NOT a.attisdropped
        AND (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"]))
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))) x(tblschema, tblname, tblowner, colname, cstrschema, cstrname)
WHERE pg_has_role(x.tblowner, 'USAGE'::text);

alter table information_schema.constraint_column_usage
    owner to "kim-uijin";

grant select on information_schema.constraint_column_usage to public;

create view information_schema.constraint_table_usage
            (table_catalog, table_schema, table_name, constraint_catalog, constraint_schema, constraint_name) as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       nr.nspname::information_schema.sql_identifier         AS table_schema,
       r.relname::information_schema.sql_identifier          AS table_name,
       current_database()::information_schema.sql_identifier AS constraint_catalog,
       nc.nspname::information_schema.sql_identifier         AS constraint_schema,
       c.conname::information_schema.sql_identifier          AS constraint_name
FROM pg_constraint c,
     pg_namespace nc,
     pg_class r,
     pg_namespace nr
WHERE c.connamespace = nc.oid
  AND r.relnamespace = nr.oid
  AND (c.contype = 'f'::"char" AND c.confrelid = r.oid OR
       (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND c.conrelid = r.oid)
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND pg_has_role(r.relowner, 'USAGE'::text);

alter table information_schema.constraint_table_usage
    owner to "kim-uijin";

grant select on information_schema.constraint_table_usage to public;

create view information_schema.domain_constraints
            (constraint_catalog, constraint_schema, constraint_name, domain_catalog, domain_schema, domain_name,
             is_deferrable, initially_deferred)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       rs.nspname::information_schema.sql_identifier         AS constraint_schema,
       con.conname::information_schema.sql_identifier        AS constraint_name,
       current_database()::information_schema.sql_identifier AS domain_catalog,
       n.nspname::information_schema.sql_identifier          AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name,
       CASE
           WHEN con.condeferrable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_deferrable,
       CASE
           WHEN con.condeferred THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS initially_deferred
FROM pg_namespace rs,
     pg_namespace n,
     pg_constraint con,
     pg_type t
WHERE rs.oid = con.connamespace
  AND n.oid = t.typnamespace
  AND t.oid = con.contypid
  AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));

alter table information_schema.domain_constraints
    owner to "kim-uijin";

grant select on information_schema.domain_constraints to public;

create view information_schema.domain_udt_usage
            (udt_catalog, udt_schema, udt_name, domain_catalog, domain_schema, domain_name) as
SELECT current_database()::information_schema.sql_identifier AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier        AS udt_schema,
       bt.typname::information_schema.sql_identifier         AS udt_name,
       current_database()::information_schema.sql_identifier AS domain_catalog,
       nt.nspname::information_schema.sql_identifier         AS domain_schema,
       t.typname::information_schema.sql_identifier          AS domain_name
FROM pg_type t,
     pg_namespace nt,
     pg_type bt,
     pg_namespace nbt
WHERE t.typnamespace = nt.oid
  AND t.typbasetype = bt.oid
  AND bt.typnamespace = nbt.oid
  AND t.typtype = 'd'::"char"
  AND pg_has_role(bt.typowner, 'USAGE'::text);

alter table information_schema.domain_udt_usage
    owner to "kim-uijin";

grant select on information_schema.domain_udt_usage to public;

create view information_schema.domains
            (domain_catalog, domain_schema, domain_name, data_type, character_maximum_length, character_octet_length,
             character_set_catalog, character_set_schema, character_set_name, collation_catalog, collation_schema,
             collation_name, numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision,
             interval_type, interval_precision, domain_default, udt_catalog, udt_schema, udt_name, scope_catalog,
             scope_schema, scope_name, maximum_cardinality, dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier                                                          AS domain_catalog,
       nt.nspname::information_schema.sql_identifier                                                                  AS domain_schema,
       t.typname::information_schema.sql_identifier                                                                   AS domain_name,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(t.typbasetype, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                                                     AS data_type,
       information_schema._pg_char_max_length(t.typbasetype, t.typtypmod)::information_schema.cardinal_number         AS character_maximum_length,
       information_schema._pg_char_octet_length(t.typbasetype,
                                                t.typtypmod)::information_schema.cardinal_number                      AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                                                  AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                                                                     AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                                                                 AS collation_schema,
       co.collname::information_schema.sql_identifier                                                                 AS collation_name,
       information_schema._pg_numeric_precision(t.typbasetype,
                                                t.typtypmod)::information_schema.cardinal_number                      AS numeric_precision,
       information_schema._pg_numeric_precision_radix(t.typbasetype,
                                                      t.typtypmod)::information_schema.cardinal_number                AS numeric_precision_radix,
       information_schema._pg_numeric_scale(t.typbasetype, t.typtypmod)::information_schema.cardinal_number           AS numeric_scale,
       information_schema._pg_datetime_precision(t.typbasetype,
                                                 t.typtypmod)::information_schema.cardinal_number                     AS datetime_precision,
       information_schema._pg_interval_type(t.typbasetype, t.typtypmod)::information_schema.character_data            AS interval_type,
       NULL::integer::information_schema.cardinal_number                                                              AS interval_precision,
       t.typdefault::information_schema.character_data                                                                AS domain_default,
       current_database()::information_schema.sql_identifier                                                          AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier                                                                 AS udt_schema,
       bt.typname::information_schema.sql_identifier                                                                  AS udt_name,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_schema,
       NULL::name::information_schema.sql_identifier                                                                  AS scope_name,
       NULL::integer::information_schema.cardinal_number                                                              AS maximum_cardinality,
       1::information_schema.sql_identifier                                                                           AS dtd_identifier
FROM pg_type t
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN (pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid) ON t.typbasetype = bt.oid AND t.typtype = 'd'::"char"
         LEFT JOIN (pg_collation co
    JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON t.typcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE pg_has_role(t.typowner, 'USAGE'::text)
   OR has_type_privilege(t.oid, 'USAGE'::text);

alter table information_schema.domains
    owner to "kim-uijin";

grant select on information_schema.domains to public;

create view information_schema.enabled_roles(role_name) as
SELECT a.rolname::information_schema.sql_identifier AS role_name
FROM pg_authid a
WHERE pg_has_role(a.oid, 'USAGE'::text);

alter table information_schema.enabled_roles
    owner to "kim-uijin";

grant select on information_schema.enabled_roles to public;

create view information_schema.key_column_usage
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             column_name, ordinal_position, position_in_unique_constraint)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       ss.nc_nspname::information_schema.sql_identifier      AS constraint_schema,
       ss.conname::information_schema.sql_identifier         AS constraint_name,
       current_database()::information_schema.sql_identifier AS table_catalog,
       ss.nr_nspname::information_schema.sql_identifier      AS table_schema,
       ss.relname::information_schema.sql_identifier         AS table_name,
       a.attname::information_schema.sql_identifier          AS column_name,
       (ss.x).n::information_schema.cardinal_number          AS ordinal_position,
       CASE
           WHEN ss.contype = 'f'::"char" THEN information_schema._pg_index_position(ss.conindid, ss.confkey[(ss.x).n])
           ELSE NULL::integer
           END::information_schema.cardinal_number           AS position_in_unique_constraint
FROM pg_attribute a,
     (SELECT r.oid                                        AS roid,
             r.relname,
             r.relowner,
             nc.nspname                                   AS nc_nspname,
             nr.nspname                                   AS nr_nspname,
             c.oid                                        AS coid,
             c.conname,
             c.contype,
             c.conindid,
             c.confkey,
             c.confrelid,
             information_schema._pg_expandarray(c.conkey) AS x
      FROM pg_namespace nr,
           pg_class r,
           pg_namespace nc,
           pg_constraint c
      WHERE nr.oid = r.relnamespace
        AND r.oid = c.conrelid
        AND nc.oid = c.connamespace
        AND (c.contype = ANY (ARRAY ['p'::"char", 'u'::"char", 'f'::"char"]))
        AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
        AND NOT pg_is_other_temp_schema(nr.oid)) ss
WHERE ss.roid = a.attrelid
  AND a.attnum = (ss.x).x
  AND NOT a.attisdropped
  AND (pg_has_role(ss.relowner, 'USAGE'::text) OR
       has_column_privilege(ss.roid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.key_column_usage
    owner to "kim-uijin";

grant select on information_schema.key_column_usage to public;

create view information_schema.parameters
            (specific_catalog, specific_schema, specific_name, ordinal_position, parameter_mode, is_result, as_locator,
             parameter_name, data_type, character_maximum_length, character_octet_length, character_set_catalog,
             character_set_schema, character_set_name, collation_catalog, collation_schema, collation_name,
             numeric_precision, numeric_precision_radix, numeric_scale, datetime_precision, interval_type,
             interval_precision, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, parameter_default)
as
SELECT current_database()::information_schema.sql_identifier                         AS specific_catalog,
       ss.n_nspname::information_schema.sql_identifier                               AS specific_schema,
       nameconcatoid(ss.proname, ss.p_oid)::information_schema.sql_identifier        AS specific_name,
       (ss.x).n::information_schema.cardinal_number                                  AS ordinal_position,
       CASE
           WHEN ss.proargmodes IS NULL THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 'i'::"char" THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 'o'::"char" THEN 'OUT'::text
           WHEN ss.proargmodes[(ss.x).n] = 'b'::"char" THEN 'INOUT'::text
           WHEN ss.proargmodes[(ss.x).n] = 'v'::"char" THEN 'IN'::text
           WHEN ss.proargmodes[(ss.x).n] = 't'::"char" THEN 'OUT'::text
           ELSE NULL::text
           END::information_schema.character_data                                    AS parameter_mode,
       'NO'::character varying::information_schema.yes_or_no                         AS is_result,
       'NO'::character varying::information_schema.yes_or_no                         AS as_locator,
       NULLIF(ss.proargnames[(ss.x).n], ''::text)::information_schema.sql_identifier AS parameter_name,
       CASE
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                                    AS data_type,
       NULL::integer::information_schema.cardinal_number                             AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                             AS character_octet_length,
       NULL::name::information_schema.sql_identifier                                 AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                                 AS character_set_schema,
       NULL::name::information_schema.sql_identifier                                 AS character_set_name,
       NULL::name::information_schema.sql_identifier                                 AS collation_catalog,
       NULL::name::information_schema.sql_identifier                                 AS collation_schema,
       NULL::name::information_schema.sql_identifier                                 AS collation_name,
       NULL::integer::information_schema.cardinal_number                             AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                             AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                             AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                             AS datetime_precision,
       NULL::character varying::information_schema.character_data                    AS interval_type,
       NULL::integer::information_schema.cardinal_number                             AS interval_precision,
       current_database()::information_schema.sql_identifier                         AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                                 AS udt_schema,
       t.typname::information_schema.sql_identifier                                  AS udt_name,
       NULL::name::information_schema.sql_identifier                                 AS scope_catalog,
       NULL::name::information_schema.sql_identifier                                 AS scope_schema,
       NULL::name::information_schema.sql_identifier                                 AS scope_name,
       NULL::integer::information_schema.cardinal_number                             AS maximum_cardinality,
       (ss.x).n::information_schema.sql_identifier                                   AS dtd_identifier,
       CASE
           WHEN pg_has_role(ss.proowner, 'USAGE'::text) THEN pg_get_function_arg_default(ss.p_oid, (ss.x).n)
           ELSE NULL::text
           END::information_schema.character_data                                    AS parameter_default
FROM pg_type t,
     pg_namespace nt,
     (SELECT n.nspname                                                                            AS n_nspname,
             p.proname,
             p.oid                                                                                AS p_oid,
             p.proowner,
             p.proargnames,
             p.proargmodes,
             information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x
      FROM pg_namespace n,
           pg_proc p
      WHERE n.oid = p.pronamespace
        AND (pg_has_role(p.proowner, 'USAGE'::text) OR has_function_privilege(p.oid, 'EXECUTE'::text))) ss
WHERE t.oid = (ss.x).x
  AND t.typnamespace = nt.oid;

alter table information_schema.parameters
    owner to "kim-uijin";

grant select on information_schema.parameters to public;

create view information_schema.referential_constraints
            (constraint_catalog, constraint_schema, constraint_name, unique_constraint_catalog,
             unique_constraint_schema, unique_constraint_name, match_option, update_rule, delete_rule)
as
SELECT current_database()::information_schema.sql_identifier AS constraint_catalog,
       ncon.nspname::information_schema.sql_identifier       AS constraint_schema,
       con.conname::information_schema.sql_identifier        AS constraint_name,
       CASE
           WHEN npkc.nspname IS NULL THEN NULL::name
           ELSE current_database()
           END::information_schema.sql_identifier            AS unique_constraint_catalog,
       npkc.nspname::information_schema.sql_identifier       AS unique_constraint_schema,
       pkc.conname::information_schema.sql_identifier        AS unique_constraint_name,
       CASE con.confmatchtype
           WHEN 'f'::"char" THEN 'FULL'::text
           WHEN 'p'::"char" THEN 'PARTIAL'::text
           WHEN 's'::"char" THEN 'NONE'::text
           ELSE NULL::text
           END::information_schema.character_data            AS match_option,
       CASE con.confupdtype
           WHEN 'c'::"char" THEN 'CASCADE'::text
           WHEN 'n'::"char" THEN 'SET NULL'::text
           WHEN 'd'::"char" THEN 'SET DEFAULT'::text
           WHEN 'r'::"char" THEN 'RESTRICT'::text
           WHEN 'a'::"char" THEN 'NO ACTION'::text
           ELSE NULL::text
           END::information_schema.character_data            AS update_rule,
       CASE con.confdeltype
           WHEN 'c'::"char" THEN 'CASCADE'::text
           WHEN 'n'::"char" THEN 'SET NULL'::text
           WHEN 'd'::"char" THEN 'SET DEFAULT'::text
           WHEN 'r'::"char" THEN 'RESTRICT'::text
           WHEN 'a'::"char" THEN 'NO ACTION'::text
           ELSE NULL::text
           END::information_schema.character_data            AS delete_rule
FROM pg_namespace ncon
         JOIN pg_constraint con ON ncon.oid = con.connamespace
         JOIN pg_class c ON con.conrelid = c.oid AND con.contype = 'f'::"char"
         LEFT JOIN pg_depend d1 ON d1.objid = con.oid AND d1.classid = 'pg_constraint'::regclass::oid AND
                                   d1.refclassid = 'pg_class'::regclass::oid AND d1.refobjsubid = 0
         LEFT JOIN pg_depend d2
                   ON d2.refclassid = 'pg_constraint'::regclass::oid AND d2.classid = 'pg_class'::regclass::oid AND
                      d2.objid = d1.refobjid AND d2.objsubid = 0 AND d2.deptype = 'i'::"char"
         LEFT JOIN pg_constraint pkc
                   ON pkc.oid = d2.refobjid AND (pkc.contype = ANY (ARRAY ['p'::"char", 'u'::"char"])) AND
                      pkc.conrelid = con.confrelid
         LEFT JOIN pg_namespace npkc ON pkc.connamespace = npkc.oid
WHERE pg_has_role(c.relowner, 'USAGE'::text)
   OR has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text)
   OR has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text);

alter table information_schema.referential_constraints
    owner to "kim-uijin";

grant select on information_schema.referential_constraints to public;

create view information_schema.role_column_grants
            (grantor, grantee, table_catalog, table_schema, table_name, column_name, privilege_type, is_grantable) as
SELECT column_privileges.grantor,
       column_privileges.grantee,
       column_privileges.table_catalog,
       column_privileges.table_schema,
       column_privileges.table_name,
       column_privileges.column_name,
       column_privileges.privilege_type,
       column_privileges.is_grantable
FROM information_schema.column_privileges
WHERE (column_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles))
   OR (column_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                           FROM information_schema.enabled_roles));

alter table information_schema.role_column_grants
    owner to "kim-uijin";

grant select on information_schema.role_column_grants to public;

create view information_schema.routine_column_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             table_catalog, table_schema, table_name, column_name)
as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
                current_database()::information_schema.sql_identifier              AS routine_catalog,
                np.nspname::information_schema.sql_identifier                      AS routine_schema,
                p.proname::information_schema.sql_identifier                       AS routine_name,
                current_database()::information_schema.sql_identifier              AS table_catalog,
                nt.nspname::information_schema.sql_identifier                      AS table_schema,
                t.relname::information_schema.sql_identifier                       AS table_name,
                a.attname::information_schema.sql_identifier                       AS column_name
FROM pg_namespace np,
     pg_proc p,
     pg_depend d,
     pg_class t,
     pg_namespace nt,
     pg_attribute a
WHERE np.oid = p.pronamespace
  AND p.oid = d.objid
  AND d.classid = 'pg_proc'::regclass::oid
  AND d.refobjid = t.oid
  AND d.refclassid = 'pg_class'::regclass::oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND t.oid = a.attrelid
  AND d.refobjsubid = a.attnum
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.routine_column_usage
    owner to "kim-uijin";

grant select on information_schema.routine_column_usage to public;

create view information_schema.routine_privileges
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
SELECT u_grantor.rolname::information_schema.sql_identifier               AS grantor,
       grantee.rolname::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       n.nspname::information_schema.sql_identifier                       AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       current_database()::information_schema.sql_identifier              AS routine_catalog,
       n.nspname::information_schema.sql_identifier                       AS routine_schema,
       p.proname::information_schema.sql_identifier                       AS routine_name,
       'EXECUTE'::character varying::information_schema.character_data    AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, p.proowner, 'USAGE'::text) OR p.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_grantable
FROM (SELECT pg_proc.oid,
             pg_proc.proname,
             pg_proc.proowner,
             pg_proc.pronamespace,
             (aclexplode(COALESCE(pg_proc.proacl, acldefault('f'::"char", pg_proc.proowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_proc.proacl,
                                  acldefault('f'::"char", pg_proc.proowner)))).is_grantable                   AS is_grantable
      FROM pg_proc) p(oid, proname, proowner, pronamespace, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE p.pronamespace = n.oid
  AND grantee.oid = p.grantee
  AND u_grantor.oid = p.grantor
  AND p.prtype = 'EXECUTE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.routine_privileges
    owner to "kim-uijin";

grant select on information_schema.routine_privileges to public;

create view information_schema.role_routine_grants
            (grantor, grantee, specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema,
             routine_name, privilege_type, is_grantable)
as
SELECT routine_privileges.grantor,
       routine_privileges.grantee,
       routine_privileges.specific_catalog,
       routine_privileges.specific_schema,
       routine_privileges.specific_name,
       routine_privileges.routine_catalog,
       routine_privileges.routine_schema,
       routine_privileges.routine_name,
       routine_privileges.privilege_type,
       routine_privileges.is_grantable
FROM information_schema.routine_privileges
WHERE (routine_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                            FROM information_schema.enabled_roles))
   OR (routine_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                            FROM information_schema.enabled_roles));

alter table information_schema.role_routine_grants
    owner to "kim-uijin";

grant select on information_schema.role_routine_grants to public;

create view information_schema.routine_routine_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier                AS specific_catalog,
                np.nspname::information_schema.sql_identifier                        AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier   AS specific_name,
                current_database()::information_schema.sql_identifier                AS routine_catalog,
                np1.nspname::information_schema.sql_identifier                       AS routine_schema,
                nameconcatoid(p1.proname, p1.oid)::information_schema.sql_identifier AS routine_name
FROM pg_namespace np,
     pg_proc p,
     pg_depend d,
     pg_proc p1,
     pg_namespace np1
WHERE np.oid = p.pronamespace
  AND p.oid = d.objid
  AND d.classid = 'pg_proc'::regclass::oid
  AND d.refobjid = p1.oid
  AND d.refclassid = 'pg_proc'::regclass::oid
  AND p1.pronamespace = np1.oid
  AND (p.prokind = ANY (ARRAY ['f'::"char", 'p'::"char"]))
  AND (p1.prokind = ANY (ARRAY ['f'::"char", 'p'::"char"]))
  AND pg_has_role(p1.proowner, 'USAGE'::text);

alter table information_schema.routine_routine_usage
    owner to "kim-uijin";

grant select on information_schema.routine_routine_usage to public;

create view information_schema.routine_sequence_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             sequence_catalog, sequence_schema, sequence_name)
as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
                current_database()::information_schema.sql_identifier              AS routine_catalog,
                np.nspname::information_schema.sql_identifier                      AS routine_schema,
                p.proname::information_schema.sql_identifier                       AS routine_name,
                current_database()::information_schema.sql_identifier              AS sequence_catalog,
                ns.nspname::information_schema.sql_identifier                      AS sequence_schema,
                s.relname::information_schema.sql_identifier                       AS sequence_name
FROM pg_namespace np,
     pg_proc p,
     pg_depend d,
     pg_class s,
     pg_namespace ns
WHERE np.oid = p.pronamespace
  AND p.oid = d.objid
  AND d.classid = 'pg_proc'::regclass::oid
  AND d.refobjid = s.oid
  AND d.refclassid = 'pg_class'::regclass::oid
  AND s.relnamespace = ns.oid
  AND s.relkind = 'S'::"char"
  AND pg_has_role(s.relowner, 'USAGE'::text);

alter table information_schema.routine_sequence_usage
    owner to "kim-uijin";

grant select on information_schema.routine_sequence_usage to public;

create view information_schema.routine_table_usage
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             table_catalog, table_schema, table_name)
as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
                current_database()::information_schema.sql_identifier              AS routine_catalog,
                np.nspname::information_schema.sql_identifier                      AS routine_schema,
                p.proname::information_schema.sql_identifier                       AS routine_name,
                current_database()::information_schema.sql_identifier              AS table_catalog,
                nt.nspname::information_schema.sql_identifier                      AS table_schema,
                t.relname::information_schema.sql_identifier                       AS table_name
FROM pg_namespace np,
     pg_proc p,
     pg_depend d,
     pg_class t,
     pg_namespace nt
WHERE np.oid = p.pronamespace
  AND p.oid = d.objid
  AND d.classid = 'pg_proc'::regclass::oid
  AND d.refobjid = t.oid
  AND d.refclassid = 'pg_class'::regclass::oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.routine_table_usage
    owner to "kim-uijin";

grant select on information_schema.routine_table_usage to public;

create view information_schema.routines
            (specific_catalog, specific_schema, specific_name, routine_catalog, routine_schema, routine_name,
             routine_type, module_catalog, module_schema, module_name, udt_catalog, udt_schema, udt_name, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             type_udt_catalog, type_udt_schema, type_udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier, routine_body, routine_definition, external_name, external_language,
             parameter_style, is_deterministic, sql_data_access, is_null_call, sql_path, schema_level_routine,
             max_dynamic_result_sets, is_user_defined_cast, is_implicitly_invocable, security_type,
             to_sql_specific_catalog, to_sql_specific_schema, to_sql_specific_name, as_locator, created, last_altered,
             new_savepoint_level, is_udt_dependent, result_cast_from_data_type, result_cast_as_locator,
             result_cast_char_max_length, result_cast_char_octet_length, result_cast_char_set_catalog,
             result_cast_char_set_schema, result_cast_char_set_name, result_cast_collation_catalog,
             result_cast_collation_schema, result_cast_collation_name, result_cast_numeric_precision,
             result_cast_numeric_precision_radix, result_cast_numeric_scale, result_cast_datetime_precision,
             result_cast_interval_type, result_cast_interval_precision, result_cast_type_udt_catalog,
             result_cast_type_udt_schema, result_cast_type_udt_name, result_cast_scope_catalog,
             result_cast_scope_schema, result_cast_scope_name, result_cast_maximum_cardinality,
             result_cast_dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS specific_catalog,
       n.nspname::information_schema.sql_identifier                       AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       current_database()::information_schema.sql_identifier              AS routine_catalog,
       n.nspname::information_schema.sql_identifier                       AS routine_schema,
       p.proname::information_schema.sql_identifier                       AS routine_name,
       CASE p.prokind
           WHEN 'f'::"char" THEN 'FUNCTION'::text
           WHEN 'p'::"char" THEN 'PROCEDURE'::text
           ELSE NULL::text
           END::information_schema.character_data                         AS routine_type,
       NULL::name::information_schema.sql_identifier                      AS module_catalog,
       NULL::name::information_schema.sql_identifier                      AS module_schema,
       NULL::name::information_schema.sql_identifier                      AS module_name,
       NULL::name::information_schema.sql_identifier                      AS udt_catalog,
       NULL::name::information_schema.sql_identifier                      AS udt_schema,
       NULL::name::information_schema.sql_identifier                      AS udt_name,
       CASE
           WHEN p.prokind = 'p'::"char" THEN NULL::text
           WHEN t.typelem <> 0::oid AND t.typlen = '-1'::integer THEN 'ARRAY'::text
           WHEN nt.nspname = 'pg_catalog'::name THEN format_type(t.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       NULL::name::information_schema.sql_identifier                      AS collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS collation_schema,
       NULL::name::information_schema.sql_identifier                      AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       CASE
           WHEN nt.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                         AS type_udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS type_udt_schema,
       t.typname::information_schema.sql_identifier                       AS type_udt_name,
       NULL::name::information_schema.sql_identifier                      AS scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS scope_schema,
       NULL::name::information_schema.sql_identifier                      AS scope_name,
       NULL::integer::information_schema.cardinal_number                  AS maximum_cardinality,
       CASE
           WHEN p.prokind <> 'p'::"char" THEN 0
           ELSE NULL::integer
           END::information_schema.sql_identifier                         AS dtd_identifier,
       CASE
           WHEN l.lanname = 'sql'::name THEN 'SQL'::text
           ELSE 'EXTERNAL'::text
           END::information_schema.character_data                         AS routine_body,
       CASE
           WHEN pg_has_role(p.proowner, 'USAGE'::text) THEN p.prosrc
           ELSE NULL::text
           END::information_schema.character_data                         AS routine_definition,
       CASE
           WHEN l.lanname = 'c'::name THEN p.prosrc
           ELSE NULL::text
           END::information_schema.character_data                         AS external_name,
       upper(l.lanname::text)::information_schema.character_data          AS external_language,
       'GENERAL'::character varying::information_schema.character_data    AS parameter_style,
       CASE
           WHEN p.provolatile = 'i'::"char" THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_deterministic,
       'MODIFIES'::character varying::information_schema.character_data   AS sql_data_access,
       CASE
           WHEN p.prokind <> 'p'::"char" THEN
               CASE
                   WHEN p.proisstrict THEN 'YES'::text
                   ELSE 'NO'::text
                   END
           ELSE NULL::text
           END::information_schema.yes_or_no                              AS is_null_call,
       NULL::character varying::information_schema.character_data         AS sql_path,
       'YES'::character varying::information_schema.yes_or_no             AS schema_level_routine,
       0::information_schema.cardinal_number                              AS max_dynamic_result_sets,
       NULL::character varying::information_schema.yes_or_no              AS is_user_defined_cast,
       NULL::character varying::information_schema.yes_or_no              AS is_implicitly_invocable,
       CASE
           WHEN p.prosecdef THEN 'DEFINER'::text
           ELSE 'INVOKER'::text
           END::information_schema.character_data                         AS security_type,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_catalog,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_schema,
       NULL::name::information_schema.sql_identifier                      AS to_sql_specific_name,
       'NO'::character varying::information_schema.yes_or_no              AS as_locator,
       NULL::timestamp with time zone::information_schema.time_stamp      AS created,
       NULL::timestamp with time zone::information_schema.time_stamp      AS last_altered,
       NULL::character varying::information_schema.yes_or_no              AS new_savepoint_level,
       'NO'::character varying::information_schema.yes_or_no              AS is_udt_dependent,
       NULL::character varying::information_schema.character_data         AS result_cast_from_data_type,
       NULL::character varying::information_schema.yes_or_no              AS result_cast_as_locator,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_char_max_length,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_char_octet_length,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_char_set_name,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_collation_name,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_datetime_precision,
       NULL::character varying::information_schema.character_data         AS result_cast_interval_type,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_interval_precision,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_type_udt_name,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_schema,
       NULL::name::information_schema.sql_identifier                      AS result_cast_scope_name,
       NULL::integer::information_schema.cardinal_number                  AS result_cast_maximum_cardinality,
       NULL::name::information_schema.sql_identifier                      AS result_cast_dtd_identifier
FROM pg_namespace n
         JOIN pg_proc p ON n.oid = p.pronamespace
         JOIN pg_language l ON p.prolang = l.oid
         LEFT JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON p.prorettype = t.oid AND p.prokind <> 'p'::"char"
WHERE pg_has_role(p.proowner, 'USAGE'::text)
   OR has_function_privilege(p.oid, 'EXECUTE'::text);

alter table information_schema.routines
    owner to "kim-uijin";

grant select on information_schema.routines to public;

create view information_schema.schemata
            (catalog_name, schema_name, schema_owner, default_character_set_catalog, default_character_set_schema,
             default_character_set_name, sql_path)
as
SELECT current_database()::information_schema.sql_identifier      AS catalog_name,
       n.nspname::information_schema.sql_identifier               AS schema_name,
       u.rolname::information_schema.sql_identifier               AS schema_owner,
       NULL::name::information_schema.sql_identifier              AS default_character_set_catalog,
       NULL::name::information_schema.sql_identifier              AS default_character_set_schema,
       NULL::name::information_schema.sql_identifier              AS default_character_set_name,
       NULL::character varying::information_schema.character_data AS sql_path
FROM pg_namespace n,
     pg_authid u
WHERE n.nspowner = u.oid
  AND (pg_has_role(n.nspowner, 'USAGE'::text) OR has_schema_privilege(n.oid, 'CREATE, USAGE'::text));

alter table information_schema.schemata
    owner to "kim-uijin";

grant select on information_schema.schemata to public;

create view information_schema.sequences
            (sequence_catalog, sequence_schema, sequence_name, data_type, numeric_precision, numeric_precision_radix,
             numeric_scale, start_value, minimum_value, maximum_value, increment, cycle_option)
as
SELECT current_database()::information_schema.sql_identifier                                                   AS sequence_catalog,
       nc.nspname::information_schema.sql_identifier                                                           AS sequence_schema,
       c.relname::information_schema.sql_identifier                                                            AS sequence_name,
       format_type(s.seqtypid, NULL::integer)::information_schema.character_data                               AS data_type,
       information_schema._pg_numeric_precision(s.seqtypid, '-1'::integer)::information_schema.cardinal_number AS numeric_precision,
       2::information_schema.cardinal_number                                                                   AS numeric_precision_radix,
       0::information_schema.cardinal_number                                                                   AS numeric_scale,
       s.seqstart::information_schema.character_data                                                           AS start_value,
       s.seqmin::information_schema.character_data                                                             AS minimum_value,
       s.seqmax::information_schema.character_data                                                             AS maximum_value,
       s.seqincrement::information_schema.character_data                                                       AS increment,
       CASE
           WHEN s.seqcycle THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                                                   AS cycle_option
FROM pg_namespace nc,
     pg_class c,
     pg_sequence s
WHERE c.relnamespace = nc.oid
  AND c.relkind = 'S'::"char"
  AND NOT (EXISTS (SELECT 1
                   FROM pg_depend
                   WHERE pg_depend.classid = 'pg_class'::regclass::oid
                     AND pg_depend.objid = c.oid
                     AND pg_depend.deptype = 'i'::"char"))
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND c.oid = s.seqrelid
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR has_sequence_privilege(c.oid, 'SELECT, UPDATE, USAGE'::text));

alter table information_schema.sequences
    owner to "kim-uijin";

grant select on information_schema.sequences to public;

create view information_schema.table_constraints
            (constraint_catalog, constraint_schema, constraint_name, table_catalog, table_schema, table_name,
             constraint_type, is_deferrable, initially_deferred, enforced)
as
SELECT current_database()::information_schema.sql_identifier  AS constraint_catalog,
       nc.nspname::information_schema.sql_identifier          AS constraint_schema,
       c.conname::information_schema.sql_identifier           AS constraint_name,
       current_database()::information_schema.sql_identifier  AS table_catalog,
       nr.nspname::information_schema.sql_identifier          AS table_schema,
       r.relname::information_schema.sql_identifier           AS table_name,
       CASE c.contype
           WHEN 'c'::"char" THEN 'CHECK'::text
           WHEN 'f'::"char" THEN 'FOREIGN KEY'::text
           WHEN 'p'::"char" THEN 'PRIMARY KEY'::text
           WHEN 'u'::"char" THEN 'UNIQUE'::text
           ELSE NULL::text
           END::information_schema.character_data             AS constraint_type,
       CASE
           WHEN c.condeferrable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                  AS is_deferrable,
       CASE
           WHEN c.condeferred THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                  AS initially_deferred,
       'YES'::character varying::information_schema.yes_or_no AS enforced
FROM pg_namespace nc,
     pg_namespace nr,
     pg_constraint c,
     pg_class r
WHERE nc.oid = c.connamespace
  AND nr.oid = r.relnamespace
  AND c.conrelid = r.oid
  AND (c.contype <> ALL (ARRAY ['t'::"char", 'x'::"char"]))
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nr.oid)
  AND (pg_has_role(r.relowner, 'USAGE'::text) OR
       has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text))
UNION ALL
SELECT current_database()::information_schema.sql_identifier         AS constraint_catalog,
       nr.nspname::information_schema.sql_identifier                 AS constraint_schema,
       (((((nr.oid::text || '_'::text) || r.oid::text) || '_'::text) || a.attnum::text) ||
        '_not_null'::text)::information_schema.sql_identifier        AS constraint_name,
       current_database()::information_schema.sql_identifier         AS table_catalog,
       nr.nspname::information_schema.sql_identifier                 AS table_schema,
       r.relname::information_schema.sql_identifier                  AS table_name,
       'CHECK'::character varying::information_schema.character_data AS constraint_type,
       'NO'::character varying::information_schema.yes_or_no         AS is_deferrable,
       'NO'::character varying::information_schema.yes_or_no         AS initially_deferred,
       'YES'::character varying::information_schema.yes_or_no        AS enforced
FROM pg_namespace nr,
     pg_class r,
     pg_attribute a
WHERE nr.oid = r.relnamespace
  AND r.oid = a.attrelid
  AND a.attnotnull
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (r.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nr.oid)
  AND (pg_has_role(r.relowner, 'USAGE'::text) OR
       has_table_privilege(r.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(r.oid, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.table_constraints
    owner to "kim-uijin";

grant select on information_schema.table_constraints to public;

create view information_schema.table_privileges
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
SELECT u_grantor.rolname::information_schema.sql_identifier  AS grantor,
       grantee.rolname::information_schema.sql_identifier    AS grantee,
       current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       c.prtype::information_schema.character_data           AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_grantable,
       CASE
           WHEN c.prtype = 'SELECT'::text THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS with_hierarchy
FROM (SELECT pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relkind,
             pg_class.relowner,
             (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
      FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
     pg_namespace nc,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE c.relnamespace = nc.oid
  AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND c.grantee = grantee.oid
  AND c.grantor = u_grantor.oid
  AND (c.prtype = ANY
       (ARRAY ['INSERT'::text, 'SELECT'::text, 'UPDATE'::text, 'DELETE'::text, 'TRUNCATE'::text, 'REFERENCES'::text, 'TRIGGER'::text]))
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.table_privileges
    owner to "kim-uijin";

grant select on information_schema.table_privileges to public;

create view information_schema.role_table_grants
            (grantor, grantee, table_catalog, table_schema, table_name, privilege_type, is_grantable, with_hierarchy) as
SELECT table_privileges.grantor,
       table_privileges.grantee,
       table_privileges.table_catalog,
       table_privileges.table_schema,
       table_privileges.table_name,
       table_privileges.privilege_type,
       table_privileges.is_grantable,
       table_privileges.with_hierarchy
FROM information_schema.table_privileges
WHERE (table_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles))
   OR (table_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles));

alter table information_schema.role_table_grants
    owner to "kim-uijin";

grant select on information_schema.role_table_grants to public;

create view information_schema.tables
            (table_catalog, table_schema, table_name, table_type, self_referencing_column_name, reference_generation,
             user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, is_insertable_into, is_typed,
             commit_action)
as
SELECT current_database()::information_schema.sql_identifier      AS table_catalog,
       nc.nspname::information_schema.sql_identifier              AS table_schema,
       c.relname::information_schema.sql_identifier               AS table_name,
       CASE
           WHEN nc.oid = pg_my_temp_schema() THEN 'LOCAL TEMPORARY'::text
           WHEN c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"]) THEN 'BASE TABLE'::text
           WHEN c.relkind = 'v'::"char" THEN 'VIEW'::text
           WHEN c.relkind = 'f'::"char" THEN 'FOREIGN'::text
           ELSE NULL::text
           END::information_schema.character_data                 AS table_type,
       NULL::name::information_schema.sql_identifier              AS self_referencing_column_name,
       NULL::character varying::information_schema.character_data AS reference_generation,
       CASE
           WHEN t.typname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                 AS user_defined_type_catalog,
       nt.nspname::information_schema.sql_identifier              AS user_defined_type_schema,
       t.typname::information_schema.sql_identifier               AS user_defined_type_name,
       CASE
           WHEN (c.relkind = ANY (ARRAY ['r'::"char", 'p'::"char"])) OR
                (c.relkind = ANY (ARRAY ['v'::"char", 'f'::"char"])) AND
                (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                      AS is_insertable_into,
       CASE
           WHEN t.typname IS NOT NULL THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                      AS is_typed,
       NULL::character varying::information_schema.character_data AS commit_action
FROM pg_namespace nc
         JOIN pg_class c ON nc.oid = c.relnamespace
         LEFT JOIN (pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid) ON c.reloftype = t.oid
WHERE (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.tables
    owner to "kim-uijin";

grant select on information_schema.tables to public;

create view information_schema.transforms
            (udt_catalog, udt_schema, udt_name, specific_catalog, specific_schema, specific_name, group_name,
             transform_type) as
SELECT current_database()::information_schema.sql_identifier              AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       np.nspname::information_schema.sql_identifier                      AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       l.lanname::information_schema.sql_identifier                       AS group_name,
       'FROM SQL'::character varying::information_schema.character_data   AS transform_type
FROM pg_type t
         JOIN pg_transform x ON t.oid = x.trftype
         JOIN pg_language l ON x.trflang = l.oid
         JOIN pg_proc p ON x.trffromsql::oid = p.oid
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN pg_namespace np ON p.pronamespace = np.oid
UNION
SELECT current_database()::information_schema.sql_identifier              AS udt_catalog,
       nt.nspname::information_schema.sql_identifier                      AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       current_database()::information_schema.sql_identifier              AS specific_catalog,
       np.nspname::information_schema.sql_identifier                      AS specific_schema,
       nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name,
       l.lanname::information_schema.sql_identifier                       AS group_name,
       'TO SQL'::character varying::information_schema.character_data     AS transform_type
FROM pg_type t
         JOIN pg_transform x ON t.oid = x.trftype
         JOIN pg_language l ON x.trflang = l.oid
         JOIN pg_proc p ON x.trftosql::oid = p.oid
         JOIN pg_namespace nt ON t.typnamespace = nt.oid
         JOIN pg_namespace np ON p.pronamespace = np.oid
ORDER BY 1, 2, 3, 7, 8;

alter table information_schema.transforms
    owner to "kim-uijin";

create view information_schema.triggered_update_columns
            (trigger_catalog, trigger_schema, trigger_name, event_object_catalog, event_object_schema,
             event_object_table, event_object_column)
as
SELECT current_database()::information_schema.sql_identifier AS trigger_catalog,
       n.nspname::information_schema.sql_identifier          AS trigger_schema,
       t.tgname::information_schema.sql_identifier           AS trigger_name,
       current_database()::information_schema.sql_identifier AS event_object_catalog,
       n.nspname::information_schema.sql_identifier          AS event_object_schema,
       c.relname::information_schema.sql_identifier          AS event_object_table,
       a.attname::information_schema.sql_identifier          AS event_object_column
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (SELECT ta0.tgoid,
             (ta0.tgat).x AS tgattnum,
             (ta0.tgat).n AS tgattpos
      FROM (SELECT pg_trigger.oid                                        AS tgoid,
                   information_schema._pg_expandarray(pg_trigger.tgattr) AS tgat
            FROM pg_trigger) ta0) ta,
     pg_attribute a
WHERE n.oid = c.relnamespace
  AND c.oid = t.tgrelid
  AND t.oid = ta.tgoid
  AND a.attrelid = t.tgrelid
  AND a.attnum = ta.tgattnum
  AND NOT t.tgisinternal
  AND NOT pg_is_other_temp_schema(n.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.triggered_update_columns
    owner to "kim-uijin";

grant select on information_schema.triggered_update_columns to public;

create view information_schema.triggers
            (trigger_catalog, trigger_schema, trigger_name, event_manipulation, event_object_catalog,
             event_object_schema, event_object_table, action_order, action_condition, action_statement,
             action_orientation, action_timing, action_reference_old_table, action_reference_new_table,
             action_reference_old_row, action_reference_new_row, created)
as
SELECT current_database()::information_schema.sql_identifier                                                                                                                                                                               AS trigger_catalog,
       n.nspname::information_schema.sql_identifier                                                                                                                                                                                        AS trigger_schema,
       t.tgname::information_schema.sql_identifier                                                                                                                                                                                         AS trigger_name,
       em.text::information_schema.character_data                                                                                                                                                                                          AS event_manipulation,
       current_database()::information_schema.sql_identifier                                                                                                                                                                               AS event_object_catalog,
       n.nspname::information_schema.sql_identifier                                                                                                                                                                                        AS event_object_schema,
       c.relname::information_schema.sql_identifier                                                                                                                                                                                        AS event_object_table,
       rank()
       OVER (PARTITION BY (n.nspname::information_schema.sql_identifier), (c.relname::information_schema.sql_identifier), em.num, (t.tgtype::integer & 1), (t.tgtype::integer & 66) ORDER BY t.tgname)::information_schema.cardinal_number AS action_order,
       CASE
           WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN (regexp_match(pg_get_triggerdef(t.oid),
                                                                          '.{35,} WHEN \((.+)\) EXECUTE FUNCTION'::text))[1]
           ELSE NULL::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_condition,
       SUBSTRING(pg_get_triggerdef(t.oid) FROM
                 POSITION(('EXECUTE FUNCTION'::text) IN (SUBSTRING(pg_get_triggerdef(t.oid) FROM 48))) +
                 47)::information_schema.character_data                                                                                                                                                                                    AS action_statement,
       CASE t.tgtype::integer & 1
           WHEN 1 THEN 'ROW'::text
           ELSE 'STATEMENT'::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_orientation,
       CASE t.tgtype::integer & 66
           WHEN 2 THEN 'BEFORE'::text
           WHEN 64 THEN 'INSTEAD OF'::text
           ELSE 'AFTER'::text
           END::information_schema.character_data                                                                                                                                                                                          AS action_timing,
       t.tgoldtable::information_schema.sql_identifier                                                                                                                                                                                     AS action_reference_old_table,
       t.tgnewtable::information_schema.sql_identifier                                                                                                                                                                                     AS action_reference_new_table,
       NULL::name::information_schema.sql_identifier                                                                                                                                                                                       AS action_reference_old_row,
       NULL::name::information_schema.sql_identifier                                                                                                                                                                                       AS action_reference_new_row,
       NULL::timestamp with time zone::information_schema.time_stamp                                                                                                                                                                       AS created
FROM pg_namespace n,
     pg_class c,
     pg_trigger t,
     (VALUES (4, 'INSERT'::text), (8, 'DELETE'::text), (16, 'UPDATE'::text)) em(num, text)
WHERE n.oid = c.relnamespace
  AND c.oid = t.tgrelid
  AND (t.tgtype::integer & em.num) <> 0
  AND NOT t.tgisinternal
  AND NOT pg_is_other_temp_schema(n.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.triggers
    owner to "kim-uijin";

grant select on information_schema.triggers to public;

create view information_schema.udt_privileges
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
SELECT u_grantor.rolname::information_schema.sql_identifier               AS grantor,
       grantee.rolname::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier              AS udt_catalog,
       n.nspname::information_schema.sql_identifier                       AS udt_schema,
       t.typname::information_schema.sql_identifier                       AS udt_name,
       'TYPE USAGE'::character varying::information_schema.character_data AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                              AS is_grantable
FROM (SELECT pg_type.oid,
             pg_type.typname,
             pg_type.typnamespace,
             pg_type.typtype,
             pg_type.typowner,
             (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).is_grantable                   AS is_grantable
      FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE t.typnamespace = n.oid
  AND t.typtype = 'c'::"char"
  AND t.grantee = grantee.oid
  AND t.grantor = u_grantor.oid
  AND t.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.udt_privileges
    owner to "kim-uijin";

grant select on information_schema.udt_privileges to public;

create view information_schema.role_udt_grants
            (grantor, grantee, udt_catalog, udt_schema, udt_name, privilege_type, is_grantable) as
SELECT udt_privileges.grantor,
       udt_privileges.grantee,
       udt_privileges.udt_catalog,
       udt_privileges.udt_schema,
       udt_privileges.udt_name,
       udt_privileges.privilege_type,
       udt_privileges.is_grantable
FROM information_schema.udt_privileges
WHERE (udt_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                        FROM information_schema.enabled_roles))
   OR (udt_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                        FROM information_schema.enabled_roles));

alter table information_schema.role_udt_grants
    owner to "kim-uijin";

grant select on information_schema.role_udt_grants to public;

create view information_schema.usage_privileges
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
SELECT u.rolname::information_schema.sql_identifier                      AS grantor,
       'PUBLIC'::name::information_schema.sql_identifier                 AS grantee,
       current_database()::information_schema.sql_identifier             AS object_catalog,
       n.nspname::information_schema.sql_identifier                      AS object_schema,
       c.collname::information_schema.sql_identifier                     AS object_name,
       'COLLATION'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data     AS privilege_type,
       'NO'::character varying::information_schema.yes_or_no             AS is_grantable
FROM pg_authid u,
     pg_namespace n,
     pg_collation c
WHERE u.oid = c.collowner
  AND c.collnamespace = n.oid
  AND (c.collencoding = ANY (ARRAY ['-1'::integer, (SELECT pg_database.encoding
                                                    FROM pg_database
                                                    WHERE pg_database.datname = current_database())]))
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier           AS grantor,
       grantee.rolname::information_schema.sql_identifier             AS grantee,
       current_database()::information_schema.sql_identifier          AS object_catalog,
       n.nspname::information_schema.sql_identifier                   AS object_schema,
       t.typname::information_schema.sql_identifier                   AS object_name,
       'DOMAIN'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data  AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, t.typowner, 'USAGE'::text) OR t.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                          AS is_grantable
FROM (SELECT pg_type.oid,
             pg_type.typname,
             pg_type.typnamespace,
             pg_type.typtype,
             pg_type.typowner,
             (aclexplode(COALESCE(pg_type.typacl, acldefault('T'::"char", pg_type.typowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).grantee                        AS grantee,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).privilege_type                 AS privilege_type,
             (aclexplode(COALESCE(pg_type.typacl,
                                  acldefault('T'::"char", pg_type.typowner)))).is_grantable                   AS is_grantable
      FROM pg_type) t(oid, typname, typnamespace, typtype, typowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE t.typnamespace = n.oid
  AND t.typtype = 'd'::"char"
  AND t.grantee = grantee.oid
  AND t.grantor = u_grantor.oid
  AND t.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier                         AS grantor,
       grantee.rolname::information_schema.sql_identifier                           AS grantee,
       current_database()::information_schema.sql_identifier                        AS object_catalog,
       ''::name::information_schema.sql_identifier                                  AS object_schema,
       fdw.fdwname::information_schema.sql_identifier                               AS object_name,
       'FOREIGN DATA WRAPPER'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data                AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, fdw.fdwowner, 'USAGE'::text) OR fdw.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                        AS is_grantable
FROM (SELECT pg_foreign_data_wrapper.fdwname,
             pg_foreign_data_wrapper.fdwowner,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).grantee        AS grantee,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).privilege_type AS privilege_type,
             (aclexplode(COALESCE(pg_foreign_data_wrapper.fdwacl,
                                  acldefault('F'::"char", pg_foreign_data_wrapper.fdwowner)))).is_grantable   AS is_grantable
      FROM pg_foreign_data_wrapper) fdw(fdwname, fdwowner, grantor, grantee, prtype, grantable),
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE u_grantor.oid = fdw.grantor
  AND grantee.oid = fdw.grantee
  AND fdw.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier                   AS grantor,
       grantee.rolname::information_schema.sql_identifier                     AS grantee,
       current_database()::information_schema.sql_identifier                  AS object_catalog,
       ''::name::information_schema.sql_identifier                            AS object_schema,
       srv.srvname::information_schema.sql_identifier                         AS object_name,
       'FOREIGN SERVER'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data          AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, srv.srvowner, 'USAGE'::text) OR srv.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                                  AS is_grantable
FROM (SELECT pg_foreign_server.srvname,
             pg_foreign_server.srvowner,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).grantee        AS grantee,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).privilege_type AS privilege_type,
             (aclexplode(COALESCE(pg_foreign_server.srvacl,
                                  acldefault('S'::"char", pg_foreign_server.srvowner)))).is_grantable   AS is_grantable
      FROM pg_foreign_server) srv(srvname, srvowner, grantor, grantee, prtype, grantable),
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE u_grantor.oid = srv.grantor
  AND grantee.oid = srv.grantee
  AND srv.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name)
UNION ALL
SELECT u_grantor.rolname::information_schema.sql_identifier             AS grantor,
       grantee.rolname::information_schema.sql_identifier               AS grantee,
       current_database()::information_schema.sql_identifier            AS object_catalog,
       n.nspname::information_schema.sql_identifier                     AS object_schema,
       c.relname::information_schema.sql_identifier                     AS object_name,
       'SEQUENCE'::character varying::information_schema.character_data AS object_type,
       'USAGE'::character varying::information_schema.character_data    AS privilege_type,
       CASE
           WHEN pg_has_role(grantee.oid, c.relowner, 'USAGE'::text) OR c.grantable THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                            AS is_grantable
FROM (SELECT pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relkind,
             pg_class.relowner,
             (aclexplode(COALESCE(pg_class.relacl, acldefault('r'::"char", pg_class.relowner)))).grantor        AS grantor,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).grantee                         AS grantee,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).privilege_type                  AS privilege_type,
             (aclexplode(COALESCE(pg_class.relacl,
                                  acldefault('r'::"char", pg_class.relowner)))).is_grantable                    AS is_grantable
      FROM pg_class) c(oid, relname, relnamespace, relkind, relowner, grantor, grantee, prtype, grantable),
     pg_namespace n,
     pg_authid u_grantor,
     (SELECT pg_authid.oid,
             pg_authid.rolname
      FROM pg_authid
      UNION ALL
      SELECT 0::oid AS oid,
             'PUBLIC'::name) grantee(oid, rolname)
WHERE c.relnamespace = n.oid
  AND c.relkind = 'S'::"char"
  AND c.grantee = grantee.oid
  AND c.grantor = u_grantor.oid
  AND c.prtype = 'USAGE'::text
  AND (pg_has_role(u_grantor.oid, 'USAGE'::text) OR pg_has_role(grantee.oid, 'USAGE'::text) OR
       grantee.rolname = 'PUBLIC'::name);

alter table information_schema.usage_privileges
    owner to "kim-uijin";

grant select on information_schema.usage_privileges to public;

create view information_schema.role_usage_grants
            (grantor, grantee, object_catalog, object_schema, object_name, object_type, privilege_type, is_grantable) as
SELECT usage_privileges.grantor,
       usage_privileges.grantee,
       usage_privileges.object_catalog,
       usage_privileges.object_schema,
       usage_privileges.object_name,
       usage_privileges.object_type,
       usage_privileges.privilege_type,
       usage_privileges.is_grantable
FROM information_schema.usage_privileges
WHERE (usage_privileges.grantor::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles))
   OR (usage_privileges.grantee::name IN (SELECT enabled_roles.role_name
                                          FROM information_schema.enabled_roles));

alter table information_schema.role_usage_grants
    owner to "kim-uijin";

grant select on information_schema.role_usage_grants to public;

create view information_schema.user_defined_types
            (user_defined_type_catalog, user_defined_type_schema, user_defined_type_name, user_defined_type_category,
             is_instantiable, is_final, ordering_form, ordering_category, ordering_routine_catalog,
             ordering_routine_schema, ordering_routine_name, reference_type, data_type, character_maximum_length,
             character_octet_length, character_set_catalog, character_set_schema, character_set_name, collation_catalog,
             collation_schema, collation_name, numeric_precision, numeric_precision_radix, numeric_scale,
             datetime_precision, interval_type, interval_precision, source_dtd_identifier, ref_dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS user_defined_type_catalog,
       n.nspname::information_schema.sql_identifier                       AS user_defined_type_schema,
       c.relname::information_schema.sql_identifier                       AS user_defined_type_name,
       'STRUCTURED'::character varying::information_schema.character_data AS user_defined_type_category,
       'YES'::character varying::information_schema.yes_or_no             AS is_instantiable,
       NULL::character varying::information_schema.yes_or_no              AS is_final,
       NULL::character varying::information_schema.character_data         AS ordering_form,
       NULL::character varying::information_schema.character_data         AS ordering_category,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_catalog,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_schema,
       NULL::name::information_schema.sql_identifier                      AS ordering_routine_name,
       NULL::character varying::information_schema.character_data         AS reference_type,
       NULL::character varying::information_schema.character_data         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       NULL::name::information_schema.sql_identifier                      AS collation_catalog,
       NULL::name::information_schema.sql_identifier                      AS collation_schema,
       NULL::name::information_schema.sql_identifier                      AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       NULL::name::information_schema.sql_identifier                      AS source_dtd_identifier,
       NULL::name::information_schema.sql_identifier                      AS ref_dtd_identifier
FROM pg_namespace n,
     pg_class c,
     pg_type t
WHERE n.oid = c.relnamespace
  AND t.typrelid = c.oid
  AND c.relkind = 'c'::"char"
  AND (pg_has_role(t.typowner, 'USAGE'::text) OR has_type_privilege(t.oid, 'USAGE'::text));

alter table information_schema.user_defined_types
    owner to "kim-uijin";

grant select on information_schema.user_defined_types to public;

create view information_schema.view_column_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name, column_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,
                nv.nspname::information_schema.sql_identifier         AS view_schema,
                v.relname::information_schema.sql_identifier          AS view_name,
                current_database()::information_schema.sql_identifier AS table_catalog,
                nt.nspname::information_schema.sql_identifier         AS table_schema,
                t.relname::information_schema.sql_identifier          AS table_name,
                a.attname::information_schema.sql_identifier          AS column_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt,
     pg_attribute a
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dt.objid
  AND dv.refobjid <> dt.refobjid
  AND dt.classid = 'pg_rewrite'::regclass::oid
  AND dt.refclassid = 'pg_class'::regclass::oid
  AND dt.refobjid = t.oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND t.oid = a.attrelid
  AND dt.refobjsubid = a.attnum
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.view_column_usage
    owner to "kim-uijin";

grant select on information_schema.view_column_usage to public;

create view information_schema.view_routine_usage
            (table_catalog, table_schema, table_name, specific_catalog, specific_schema, specific_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier              AS table_catalog,
                nv.nspname::information_schema.sql_identifier                      AS table_schema,
                v.relname::information_schema.sql_identifier                       AS table_name,
                current_database()::information_schema.sql_identifier              AS specific_catalog,
                np.nspname::information_schema.sql_identifier                      AS specific_schema,
                nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS specific_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dp,
     pg_proc p,
     pg_namespace np
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dp.objid
  AND dp.classid = 'pg_rewrite'::regclass::oid
  AND dp.refclassid = 'pg_proc'::regclass::oid
  AND dp.refobjid = p.oid
  AND p.pronamespace = np.oid
  AND pg_has_role(p.proowner, 'USAGE'::text);

alter table information_schema.view_routine_usage
    owner to "kim-uijin";

grant select on information_schema.view_routine_usage to public;

create view information_schema.view_table_usage
            (view_catalog, view_schema, view_name, table_catalog, table_schema, table_name) as
SELECT DISTINCT current_database()::information_schema.sql_identifier AS view_catalog,
                nv.nspname::information_schema.sql_identifier         AS view_schema,
                v.relname::information_schema.sql_identifier          AS view_name,
                current_database()::information_schema.sql_identifier AS table_catalog,
                nt.nspname::information_schema.sql_identifier         AS table_schema,
                t.relname::information_schema.sql_identifier          AS table_name
FROM pg_namespace nv,
     pg_class v,
     pg_depend dv,
     pg_depend dt,
     pg_class t,
     pg_namespace nt
WHERE nv.oid = v.relnamespace
  AND v.relkind = 'v'::"char"
  AND v.oid = dv.refobjid
  AND dv.refclassid = 'pg_class'::regclass::oid
  AND dv.classid = 'pg_rewrite'::regclass::oid
  AND dv.deptype = 'i'::"char"
  AND dv.objid = dt.objid
  AND dv.refobjid <> dt.refobjid
  AND dt.classid = 'pg_rewrite'::regclass::oid
  AND dt.refclassid = 'pg_class'::regclass::oid
  AND dt.refobjid = t.oid
  AND t.relnamespace = nt.oid
  AND (t.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'p'::"char"]))
  AND pg_has_role(t.relowner, 'USAGE'::text);

alter table information_schema.view_table_usage
    owner to "kim-uijin";

grant select on information_schema.view_table_usage to public;

create view information_schema.views
            (table_catalog, table_schema, table_name, view_definition, check_option, is_updatable, is_insertable_into,
             is_trigger_updatable, is_trigger_deletable, is_trigger_insertable_into)
as
SELECT current_database()::information_schema.sql_identifier AS table_catalog,
       nc.nspname::information_schema.sql_identifier         AS table_schema,
       c.relname::information_schema.sql_identifier          AS table_name,
       CASE
           WHEN pg_has_role(c.relowner, 'USAGE'::text) THEN pg_get_viewdef(c.oid)
           ELSE NULL::text
           END::information_schema.character_data            AS view_definition,
       CASE
           WHEN 'check_option=cascaded'::text = ANY (c.reloptions) THEN 'CASCADED'::text
           WHEN 'check_option=local'::text = ANY (c.reloptions) THEN 'LOCAL'::text
           ELSE 'NONE'::text
           END::information_schema.character_data            AS check_option,
       CASE
           WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 20) = 20 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_updatable,
       CASE
           WHEN (pg_relation_is_updatable(c.oid::regclass, false) & 8) = 8 THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_insertable_into,
       CASE
           WHEN (EXISTS (SELECT 1
                         FROM pg_trigger
                         WHERE pg_trigger.tgrelid = c.oid
                           AND (pg_trigger.tgtype::integer & 81) = 81)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_updatable,
       CASE
           WHEN (EXISTS (SELECT 1
                         FROM pg_trigger
                         WHERE pg_trigger.tgrelid = c.oid
                           AND (pg_trigger.tgtype::integer & 73) = 73)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_deletable,
       CASE
           WHEN (EXISTS (SELECT 1
                         FROM pg_trigger
                         WHERE pg_trigger.tgrelid = c.oid
                           AND (pg_trigger.tgtype::integer & 69) = 69)) THEN 'YES'::text
           ELSE 'NO'::text
           END::information_schema.yes_or_no                 AS is_trigger_insertable_into
FROM pg_namespace nc,
     pg_class c
WHERE c.relnamespace = nc.oid
  AND c.relkind = 'v'::"char"
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text));

alter table information_schema.views
    owner to "kim-uijin";

grant select on information_schema.views to public;

create view information_schema.data_type_privileges
            (object_catalog, object_schema, object_name, object_type, dtd_identifier) as
SELECT current_database()::information_schema.sql_identifier AS object_catalog,
       x.objschema                                           AS object_schema,
       x.objname                                             AS object_name,
       x.objtype::information_schema.character_data          AS object_type,
       x.objdtdid                                            AS dtd_identifier
FROM (SELECT attributes.udt_schema,
             attributes.udt_name,
             'USER-DEFINED TYPE'::text AS text,
             attributes.dtd_identifier
      FROM information_schema.attributes
      UNION ALL
      SELECT columns.table_schema,
             columns.table_name,
             'TABLE'::text AS text,
             columns.dtd_identifier
      FROM information_schema.columns
      UNION ALL
      SELECT domains.domain_schema,
             domains.domain_name,
             'DOMAIN'::text AS text,
             domains.dtd_identifier
      FROM information_schema.domains
      UNION ALL
      SELECT parameters.specific_schema,
             parameters.specific_name,
             'ROUTINE'::text AS text,
             parameters.dtd_identifier
      FROM information_schema.parameters
      UNION ALL
      SELECT routines.specific_schema,
             routines.specific_name,
             'ROUTINE'::text AS text,
             routines.dtd_identifier
      FROM information_schema.routines) x(objschema, objname, objtype, objdtdid);

alter table information_schema.data_type_privileges
    owner to "kim-uijin";

grant select on information_schema.data_type_privileges to public;

create view information_schema.element_types
            (object_catalog, object_schema, object_name, object_type, collection_type_identifier, data_type,
             character_maximum_length, character_octet_length, character_set_catalog, character_set_schema,
             character_set_name, collation_catalog, collation_schema, collation_name, numeric_precision,
             numeric_precision_radix, numeric_scale, datetime_precision, interval_type, interval_precision,
             domain_default, udt_catalog, udt_schema, udt_name, scope_catalog, scope_schema, scope_name,
             maximum_cardinality, dtd_identifier)
as
SELECT current_database()::information_schema.sql_identifier              AS object_catalog,
       n.nspname::information_schema.sql_identifier                       AS object_schema,
       x.objname                                                          AS object_name,
       x.objtype::information_schema.character_data                       AS object_type,
       x.objdtdid::information_schema.sql_identifier                      AS collection_type_identifier,
       CASE
           WHEN nbt.nspname = 'pg_catalog'::name THEN format_type(bt.oid, NULL::integer)
           ELSE 'USER-DEFINED'::text
           END::information_schema.character_data                         AS data_type,
       NULL::integer::information_schema.cardinal_number                  AS character_maximum_length,
       NULL::integer::information_schema.cardinal_number                  AS character_octet_length,
       NULL::name::information_schema.sql_identifier                      AS character_set_catalog,
       NULL::name::information_schema.sql_identifier                      AS character_set_schema,
       NULL::name::information_schema.sql_identifier                      AS character_set_name,
       CASE
           WHEN nco.nspname IS NOT NULL THEN current_database()
           ELSE NULL::name
           END::information_schema.sql_identifier                         AS collation_catalog,
       nco.nspname::information_schema.sql_identifier                     AS collation_schema,
       co.collname::information_schema.sql_identifier                     AS collation_name,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision,
       NULL::integer::information_schema.cardinal_number                  AS numeric_precision_radix,
       NULL::integer::information_schema.cardinal_number                  AS numeric_scale,
       NULL::integer::information_schema.cardinal_number                  AS datetime_precision,
       NULL::character varying::information_schema.character_data         AS interval_type,
       NULL::integer::information_schema.cardinal_number                  AS interval_precision,
       NULL::character varying::information_schema.character_data         AS domain_default,
       current_database()::information_schema.sql_identifier              AS udt_catalog,
       nbt.nspname::information_schema.sql_identifier                     AS udt_schema,
       bt.typname::information_schema.sql_identifier                      AS udt_name,
       NULL::name::information_schema.sql_identifier                      AS scope_catalog,
       NULL::name::information_schema.sql_identifier                      AS scope_schema,
       NULL::name::information_schema.sql_identifier                      AS scope_name,
       NULL::integer::information_schema.cardinal_number                  AS maximum_cardinality,
       ('a'::text || x.objdtdid::text)::information_schema.sql_identifier AS dtd_identifier
FROM pg_namespace n,
     pg_type at,
     pg_namespace nbt,
     pg_type bt,
     (SELECT c.relnamespace,
             c.relname::information_schema.sql_identifier AS relname,
             CASE
                 WHEN c.relkind = 'c'::"char" THEN 'USER-DEFINED TYPE'::text
                 ELSE 'TABLE'::text
                 END                                      AS "case",
             a.attnum,
             a.atttypid,
             a.attcollation
      FROM pg_class c,
           pg_attribute a
      WHERE c.oid = a.attrelid
        AND (c.relkind = ANY (ARRAY ['r'::"char", 'v'::"char", 'f'::"char", 'c'::"char", 'p'::"char"]))
        AND a.attnum > 0
        AND NOT a.attisdropped
      UNION ALL
      SELECT t.typnamespace,
             t.typname::information_schema.sql_identifier AS typname,
             'DOMAIN'::text                               AS text,
             1,
             t.typbasetype,
             t.typcollation
      FROM pg_type t
      WHERE t.typtype = 'd'::"char"
      UNION ALL
      SELECT ss.pronamespace,
             nameconcatoid(ss.proname, ss.oid)::information_schema.sql_identifier AS nameconcatoid,
             'ROUTINE'::text                                                      AS text,
             (ss.x).n                                                             AS n,
             (ss.x).x                                                             AS x,
             0
      FROM (SELECT p.pronamespace,
                   p.proname,
                   p.oid,
                   information_schema._pg_expandarray(COALESCE(p.proallargtypes, p.proargtypes::oid[])) AS x
            FROM pg_proc p) ss
      UNION ALL
      SELECT p.pronamespace,
             nameconcatoid(p.proname, p.oid)::information_schema.sql_identifier AS nameconcatoid,
             'ROUTINE'::text                                                    AS text,
             0,
             p.prorettype,
             0
      FROM pg_proc p) x(objschema, objname, objtype, objdtdid, objtypeid, objcollation)
         LEFT JOIN (pg_collation co
         JOIN pg_namespace nco ON co.collnamespace = nco.oid)
                   ON x.objcollation = co.oid AND (nco.nspname <> 'pg_catalog'::name OR co.collname <> 'default'::name)
WHERE n.oid = x.objschema
  AND at.oid = x.objtypeid
  AND at.typelem <> 0::oid
  AND at.typlen = '-1'::integer
  AND at.typelem = bt.oid
  AND nbt.oid = bt.typnamespace
  AND ((n.nspname, x.objname::name, x.objtype, x.objdtdid::information_schema.sql_identifier::name) IN
       (SELECT data_type_privileges.object_schema,
               data_type_privileges.object_name,
               data_type_privileges.object_type,
               data_type_privileges.dtd_identifier
        FROM information_schema.data_type_privileges));

alter table information_schema.element_types
    owner to "kim-uijin";

grant select on information_schema.element_types to public;

create view information_schema._pg_foreign_table_columns(nspname, relname, attname, attfdwoptions) as
SELECT n.nspname,
       c.relname,
       a.attname,
       a.attfdwoptions
FROM pg_foreign_table t,
     pg_authid u,
     pg_namespace n,
     pg_class c,
     pg_attribute a
WHERE u.oid = c.relowner
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_column_privilege(c.oid, a.attnum, 'SELECT, INSERT, UPDATE, REFERENCES'::text))
  AND n.oid = c.relnamespace
  AND c.oid = t.ftrelid
  AND c.relkind = 'f'::"char"
  AND a.attrelid = c.oid
  AND a.attnum > 0;

alter table information_schema._pg_foreign_table_columns
    owner to "kim-uijin";

create view information_schema.column_options
            (table_catalog, table_schema, table_name, column_name, option_name, option_value) as
SELECT current_database()::information_schema.sql_identifier                                  AS table_catalog,
       c.nspname::information_schema.sql_identifier                                           AS table_schema,
       c.relname::information_schema.sql_identifier                                           AS table_name,
       c.attname::information_schema.sql_identifier                                           AS column_name,
       (pg_options_to_table(c.attfdwoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(c.attfdwoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_table_columns c;

alter table information_schema.column_options
    owner to "kim-uijin";

grant select on information_schema.column_options to public;

create view information_schema._pg_foreign_data_wrappers
            (oid, fdwowner, fdwoptions, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             authorization_identifier, foreign_data_wrapper_language)
as
SELECT w.oid,
       w.fdwowner,
       w.fdwoptions,
       current_database()::information_schema.sql_identifier     AS foreign_data_wrapper_catalog,
       w.fdwname::information_schema.sql_identifier              AS foreign_data_wrapper_name,
       u.rolname::information_schema.sql_identifier              AS authorization_identifier,
       'c'::character varying::information_schema.character_data AS foreign_data_wrapper_language
FROM pg_foreign_data_wrapper w,
     pg_authid u
WHERE u.oid = w.fdwowner
  AND (pg_has_role(w.fdwowner, 'USAGE'::text) OR has_foreign_data_wrapper_privilege(w.oid, 'USAGE'::text));

alter table information_schema._pg_foreign_data_wrappers
    owner to "kim-uijin";

create view information_schema.foreign_data_wrapper_options
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, option_name, option_value) as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       (pg_options_to_table(w.fdwoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(w.fdwoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrapper_options
    owner to "kim-uijin";

grant select on information_schema.foreign_data_wrapper_options to public;

create view information_schema.foreign_data_wrappers
            (foreign_data_wrapper_catalog, foreign_data_wrapper_name, authorization_identifier, library_name,
             foreign_data_wrapper_language)
as
SELECT w.foreign_data_wrapper_catalog,
       w.foreign_data_wrapper_name,
       w.authorization_identifier,
       NULL::character varying::information_schema.character_data AS library_name,
       w.foreign_data_wrapper_language
FROM information_schema._pg_foreign_data_wrappers w;

alter table information_schema.foreign_data_wrappers
    owner to "kim-uijin";

grant select on information_schema.foreign_data_wrappers to public;

create view information_schema._pg_foreign_servers
            (oid, srvoptions, foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog,
             foreign_data_wrapper_name, foreign_server_type, foreign_server_version, authorization_identifier)
as
SELECT s.oid,
       s.srvoptions,
       current_database()::information_schema.sql_identifier AS foreign_server_catalog,
       s.srvname::information_schema.sql_identifier          AS foreign_server_name,
       current_database()::information_schema.sql_identifier AS foreign_data_wrapper_catalog,
       w.fdwname::information_schema.sql_identifier          AS foreign_data_wrapper_name,
       s.srvtype::information_schema.character_data          AS foreign_server_type,
       s.srvversion::information_schema.character_data       AS foreign_server_version,
       u.rolname::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u
WHERE w.oid = s.srvfdw
  AND u.oid = s.srvowner
  AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text));

alter table information_schema._pg_foreign_servers
    owner to "kim-uijin";

create view information_schema.foreign_server_options
            (foreign_server_catalog, foreign_server_name, option_name, option_value) as
SELECT s.foreign_server_catalog,
       s.foreign_server_name,
       (pg_options_to_table(s.srvoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(s.srvoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_servers s;

alter table information_schema.foreign_server_options
    owner to "kim-uijin";

grant select on information_schema.foreign_server_options to public;

create view information_schema.foreign_servers
            (foreign_server_catalog, foreign_server_name, foreign_data_wrapper_catalog, foreign_data_wrapper_name,
             foreign_server_type, foreign_server_version, authorization_identifier)
as
SELECT _pg_foreign_servers.foreign_server_catalog,
       _pg_foreign_servers.foreign_server_name,
       _pg_foreign_servers.foreign_data_wrapper_catalog,
       _pg_foreign_servers.foreign_data_wrapper_name,
       _pg_foreign_servers.foreign_server_type,
       _pg_foreign_servers.foreign_server_version,
       _pg_foreign_servers.authorization_identifier
FROM information_schema._pg_foreign_servers;

alter table information_schema.foreign_servers
    owner to "kim-uijin";

grant select on information_schema.foreign_servers to public;

create view information_schema._pg_foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, ftoptions, foreign_server_catalog,
             foreign_server_name, authorization_identifier)
as
SELECT current_database()::information_schema.sql_identifier AS foreign_table_catalog,
       n.nspname::information_schema.sql_identifier          AS foreign_table_schema,
       c.relname::information_schema.sql_identifier          AS foreign_table_name,
       t.ftoptions,
       current_database()::information_schema.sql_identifier AS foreign_server_catalog,
       s.srvname::information_schema.sql_identifier          AS foreign_server_name,
       u.rolname::information_schema.sql_identifier          AS authorization_identifier
FROM pg_foreign_table t,
     pg_foreign_server s,
     pg_foreign_data_wrapper w,
     pg_authid u,
     pg_namespace n,
     pg_class c
WHERE w.oid = s.srvfdw
  AND u.oid = c.relowner
  AND (pg_has_role(c.relowner, 'USAGE'::text) OR
       has_table_privilege(c.oid, 'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'::text) OR
       has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES'::text))
  AND n.oid = c.relnamespace
  AND c.oid = t.ftrelid
  AND c.relkind = 'f'::"char"
  AND s.oid = t.ftserver;

alter table information_schema._pg_foreign_tables
    owner to "kim-uijin";

create view information_schema.foreign_table_options
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, option_name, option_value) as
SELECT t.foreign_table_catalog,
       t.foreign_table_schema,
       t.foreign_table_name,
       (pg_options_to_table(t.ftoptions)).option_name::information_schema.sql_identifier  AS option_name,
       (pg_options_to_table(t.ftoptions)).option_value::information_schema.character_data AS option_value
FROM information_schema._pg_foreign_tables t;

alter table information_schema.foreign_table_options
    owner to "kim-uijin";

grant select on information_schema.foreign_table_options to public;

create view information_schema.foreign_tables
            (foreign_table_catalog, foreign_table_schema, foreign_table_name, foreign_server_catalog,
             foreign_server_name) as
SELECT _pg_foreign_tables.foreign_table_catalog,
       _pg_foreign_tables.foreign_table_schema,
       _pg_foreign_tables.foreign_table_name,
       _pg_foreign_tables.foreign_server_catalog,
       _pg_foreign_tables.foreign_server_name
FROM information_schema._pg_foreign_tables;

alter table information_schema.foreign_tables
    owner to "kim-uijin";

grant select on information_schema.foreign_tables to public;

create view information_schema._pg_user_mappings
            (oid, umoptions, umuser, authorization_identifier, foreign_server_catalog, foreign_server_name, srvowner) as
SELECT um.oid,
       um.umoptions,
       um.umuser,
       COALESCE(u.rolname, 'PUBLIC'::name)::information_schema.sql_identifier AS authorization_identifier,
       s.foreign_server_catalog,
       s.foreign_server_name,
       s.authorization_identifier                                             AS srvowner
FROM pg_user_mapping um
         LEFT JOIN pg_authid u ON u.oid = um.umuser,
     information_schema._pg_foreign_servers s
WHERE s.oid = um.umserver;

alter table information_schema._pg_user_mappings
    owner to "kim-uijin";

create view information_schema.user_mapping_options
            (authorization_identifier, foreign_server_catalog, foreign_server_name, option_name, option_value) as
SELECT um.authorization_identifier,
       um.foreign_server_catalog,
       um.foreign_server_name,
       opts.option_name::information_schema.sql_identifier AS option_name,
       CASE
           WHEN um.umuser <> 0::oid AND um.authorization_identifier::name = CURRENT_USER OR
                um.umuser = 0::oid AND pg_has_role(um.srvowner::name, 'USAGE'::text) OR (SELECT pg_authid.rolsuper
                                                                                         FROM pg_authid
                                                                                         WHERE pg_authid.rolname = CURRENT_USER)
               THEN opts.option_value
           ELSE NULL::text
           END::information_schema.character_data          AS option_value
FROM information_schema._pg_user_mappings um,
     LATERAL pg_options_to_table(um.umoptions) opts(option_name, option_value);

alter table information_schema.user_mapping_options
    owner to "kim-uijin";

grant select on information_schema.user_mapping_options to public;

create view information_schema.user_mappings(authorization_identifier, foreign_server_catalog, foreign_server_name) as
SELECT _pg_user_mappings.authorization_identifier,
       _pg_user_mappings.foreign_server_catalog,
       _pg_user_mappings.foreign_server_name
FROM information_schema._pg_user_mappings;

alter table information_schema.user_mappings
    owner to "kim-uijin";

grant select on information_schema.user_mappings to public;

create function pg_catalog.heap_tableam_handler(internal) returns table_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.heap_tableam_handler(internal) is 'row-oriented heap table access method handler';

alter function pg_catalog.heap_tableam_handler(internal) owner to "kim-uijin";

create function pg_catalog.byteaout(bytea) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaout(bytea) is 'I/O';

alter function pg_catalog.byteaout(bytea) owner to "kim-uijin";

create function pg_catalog.charout("char") returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charout("char") is 'I/O';

alter function pg_catalog.charout("char") owner to "kim-uijin";

create function pg_catalog.namein(cstring) returns name
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namein(cstring) is 'I/O';

alter function pg_catalog.namein(cstring) owner to "kim-uijin";

create function pg_catalog.nameout(name) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameout(name) is 'I/O';

alter function pg_catalog.nameout(name) owner to "kim-uijin";

create function pg_catalog.int2in(cstring) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2in(cstring) is 'I/O';

alter function pg_catalog.int2in(cstring) owner to "kim-uijin";

create function pg_catalog.int2out(smallint) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2out(smallint) is 'I/O';

alter function pg_catalog.int2out(smallint) owner to "kim-uijin";

create function pg_catalog.int2vectorin(cstring) returns int2vector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorin(cstring) is 'I/O';

alter function pg_catalog.int2vectorin(cstring) owner to "kim-uijin";

create function pg_catalog.int2vectorout(int2vector) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorout(int2vector) is 'I/O';

alter function pg_catalog.int2vectorout(int2vector) owner to "kim-uijin";

create function pg_catalog.int4in(cstring) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4in(cstring) is 'I/O';

alter function pg_catalog.int4in(cstring) owner to "kim-uijin";

create function pg_catalog.int4out(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4out(integer) is 'I/O';

alter function pg_catalog.int4out(integer) owner to "kim-uijin";

create function pg_catalog.regprocin(cstring) returns regproc
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocin(cstring) is 'I/O';

alter function pg_catalog.regprocin(cstring) owner to "kim-uijin";

create function pg_catalog.regprocout(regproc) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocout(regproc) is 'I/O';

alter function pg_catalog.regprocout(regproc) owner to "kim-uijin";

create function pg_catalog.textin(cstring) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textin(cstring) is 'I/O';

alter function pg_catalog.textin(cstring) owner to "kim-uijin";

create function pg_catalog.textout(text) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textout(text) is 'I/O';

alter function pg_catalog.textout(text) owner to "kim-uijin";

create function pg_catalog.tidin(cstring) returns tid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidin(cstring) is 'I/O';

alter function pg_catalog.tidin(cstring) owner to "kim-uijin";

create function pg_catalog.tidout(tid) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidout(tid) is 'I/O';

alter function pg_catalog.tidout(tid) owner to "kim-uijin";

create function pg_catalog.xidin(cstring) returns xid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidin(cstring) is 'I/O';

alter function pg_catalog.xidin(cstring) owner to "kim-uijin";

create function pg_catalog.xidout(xid) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidout(xid) is 'I/O';

alter function pg_catalog.xidout(xid) owner to "kim-uijin";

create function pg_catalog.cidin(cstring) returns cid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidin(cstring) is 'I/O';

alter function pg_catalog.cidin(cstring) owner to "kim-uijin";

create function pg_catalog.cidout(cid) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidout(cid) is 'I/O';

alter function pg_catalog.cidout(cid) owner to "kim-uijin";

create function pg_catalog.oidvectorin(cstring) returns oidvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorin(cstring) is 'I/O';

alter function pg_catalog.oidvectorin(cstring) owner to "kim-uijin";

create function pg_catalog.oidvectorout(oidvector) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorout(oidvector) is 'I/O';

alter function pg_catalog.oidvectorout(oidvector) owner to "kim-uijin";

create function pg_catalog.boollt(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boollt(boolean, boolean) is 'implementation of < operator';

alter function pg_catalog.boollt(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.boolgt(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolgt(boolean, boolean) is 'implementation of > operator';

alter function pg_catalog.boolgt(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.booleq(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booleq(boolean, boolean) is 'implementation of = operator';

alter function pg_catalog.booleq(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.chareq("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chareq("char", "char") is 'implementation of = operator';

alter function pg_catalog.chareq("char", "char") owner to "kim-uijin";

create function pg_catalog.nameeq(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeq(name, name) is 'implementation of = operator';

alter function pg_catalog.nameeq(name, name) owner to "kim-uijin";

create function pg_catalog.int2eq(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2eq(smallint, smallint) is 'implementation of = operator';

alter function pg_catalog.int2eq(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2lt(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2lt(smallint, smallint) is 'implementation of < operator';

alter function pg_catalog.int2lt(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4eq(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4eq(integer, integer) is 'implementation of = operator';

alter function pg_catalog.int4eq(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4lt(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4lt(integer, integer) is 'implementation of < operator';

alter function pg_catalog.int4lt(integer, integer) owner to "kim-uijin";

create function pg_catalog.texteq(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteq(text, text) is 'implementation of = operator';

alter function pg_catalog.texteq(text, text) owner to "kim-uijin";

create function pg_catalog.xideq(xid, xid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideq(xid, xid) is 'implementation of = operator';

alter function pg_catalog.xideq(xid, xid) owner to "kim-uijin";

create function pg_catalog.cideq(cid, cid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cideq(cid, cid) is 'implementation of = operator';

alter function pg_catalog.cideq(cid, cid) owner to "kim-uijin";

create function pg_catalog.charne("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charne("char", "char") is 'implementation of <> operator';

alter function pg_catalog.charne("char", "char") owner to "kim-uijin";

create function pg_catalog.charle("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charle("char", "char") is 'implementation of <= operator';

alter function pg_catalog.charle("char", "char") owner to "kim-uijin";

create function pg_catalog.chargt("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chargt("char", "char") is 'implementation of > operator';

alter function pg_catalog.chargt("char", "char") owner to "kim-uijin";

create function pg_catalog.charge("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charge("char", "char") is 'implementation of >= operator';

alter function pg_catalog.charge("char", "char") owner to "kim-uijin";

create function pg_catalog.int4("char") returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4("char") is 'convert char to int4';

alter function pg_catalog.int4("char") owner to "kim-uijin";

create function pg_catalog.char(integer) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(integer) is 'convert int4 to char';

alter function pg_catalog.char(integer) owner to "kim-uijin";

create function pg_catalog.nameregexeq(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexeq(name, text) is 'implementation of ~ operator';

alter function pg_catalog.nameregexeq(name, text) owner to "kim-uijin";

create function pg_catalog.boolne(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolne(boolean, boolean) is 'implementation of <> operator';

alter function pg_catalog.boolne(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.pg_ddl_command_in(cstring) returns pg_ddl_command
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_in(cstring) is 'I/O';

alter function pg_catalog.pg_ddl_command_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_ddl_command_out(pg_ddl_command) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_out(pg_ddl_command) is 'I/O';

alter function pg_catalog.pg_ddl_command_out(pg_ddl_command) owner to "kim-uijin";

create function pg_catalog.pg_ddl_command_recv(internal) returns pg_ddl_command
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_recv(internal) is 'I/O';

alter function pg_catalog.pg_ddl_command_recv(internal) owner to "kim-uijin";

create function pg_catalog.version() returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.version() is 'PostgreSQL version string';

alter function pg_catalog.version() owner to "kim-uijin";

create function pg_catalog.pg_ddl_command_send(pg_ddl_command) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ddl_command_send(pg_ddl_command) is 'I/O';

alter function pg_catalog.pg_ddl_command_send(pg_ddl_command) owner to "kim-uijin";

create function pg_catalog.eqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqsel(internal, oid, internal, integer) is 'restriction selectivity of = and related operators';

alter function pg_catalog.eqsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.neqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqsel(internal, oid, internal, integer) is 'restriction selectivity of <> and related operators';

alter function pg_catalog.neqsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.scalarltsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltsel(internal, oid, internal, integer) is 'restriction selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.scalargtsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtsel(internal, oid, internal, integer) is 'restriction selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of = and related operators';

alter function pg_catalog.eqjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of <> and related operators';

alter function pg_catalog.neqjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of < and related operators on scalar datatypes';

alter function pg_catalog.scalarltjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of > and related operators on scalar datatypes';

alter function pg_catalog.scalargtjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.unknownin(cstring) returns unknown
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownin(cstring) is 'I/O';

alter function pg_catalog.unknownin(cstring) owner to "kim-uijin";

create function pg_catalog.unknownout(unknown) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownout(unknown) is 'I/O';

alter function pg_catalog.unknownout(unknown) owner to "kim-uijin";

create function pg_catalog.box_above_eq(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above_eq(box, box) is 'implementation of >^ operator';

alter function pg_catalog.box_above_eq(box, box) owner to "kim-uijin";

create function pg_catalog.box_below_eq(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below_eq(box, box) is 'implementation of <^ operator';

alter function pg_catalog.box_below_eq(box, box) owner to "kim-uijin";

create function pg_catalog.point_in(cstring) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_in(cstring) is 'I/O';

alter function pg_catalog.point_in(cstring) owner to "kim-uijin";

create function pg_catalog.point_out(point) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_out(point) is 'I/O';

alter function pg_catalog.point_out(point) owner to "kim-uijin";

create function pg_catalog.lseg_in(cstring) returns lseg
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_in(cstring) is 'I/O';

alter function pg_catalog.lseg_in(cstring) owner to "kim-uijin";

create function pg_catalog.lseg_out(lseg) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_out(lseg) is 'I/O';

alter function pg_catalog.lseg_out(lseg) owner to "kim-uijin";

create function pg_catalog.path_in(cstring) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_in(cstring) is 'I/O';

alter function pg_catalog.path_in(cstring) owner to "kim-uijin";

create function pg_catalog.path_out(path) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_out(path) is 'I/O';

alter function pg_catalog.path_out(path) owner to "kim-uijin";

create function pg_catalog.box_in(cstring) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_in(cstring) is 'I/O';

alter function pg_catalog.box_in(cstring) owner to "kim-uijin";

create function pg_catalog.box_out(box) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_out(box) is 'I/O';

alter function pg_catalog.box_out(box) owner to "kim-uijin";

create function pg_catalog.box_overlap(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overlap(box, box) is 'implementation of && operator';

alter function pg_catalog.box_overlap(box, box) owner to "kim-uijin";

create function pg_catalog.box_ge(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_ge(box, box) is 'implementation of >= operator';

alter function pg_catalog.box_ge(box, box) owner to "kim-uijin";

create function pg_catalog.box_gt(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_gt(box, box) is 'implementation of > operator';

alter function pg_catalog.box_gt(box, box) owner to "kim-uijin";

create function pg_catalog.box_eq(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_eq(box, box) is 'implementation of = operator';

alter function pg_catalog.box_eq(box, box) owner to "kim-uijin";

create function pg_catalog.box_lt(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_lt(box, box) is 'implementation of < operator';

alter function pg_catalog.box_lt(box, box) owner to "kim-uijin";

create function pg_catalog.box_le(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_le(box, box) is 'implementation of <= operator';

alter function pg_catalog.box_le(box, box) owner to "kim-uijin";

create function pg_catalog.point_above(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_above(point, point) is 'implementation of |>> operator';

alter function pg_catalog.point_above(point, point) owner to "kim-uijin";

create function pg_catalog.point_left(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_left(point, point) is 'implementation of << operator';

alter function pg_catalog.point_left(point, point) owner to "kim-uijin";

create function pg_catalog.point_right(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_right(point, point) is 'implementation of >> operator';

alter function pg_catalog.point_right(point, point) owner to "kim-uijin";

create function pg_catalog.point_below(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_below(point, point) is 'implementation of <<| operator';

alter function pg_catalog.point_below(point, point) owner to "kim-uijin";

create function pg_catalog.point_eq(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_eq(point, point) is 'implementation of ~= operator';

alter function pg_catalog.point_eq(point, point) owner to "kim-uijin";

create function pg_catalog.on_pb(point, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pb(point, box) is 'implementation of <@ operator';

alter function pg_catalog.on_pb(point, box) owner to "kim-uijin";

create function pg_catalog.on_ppath(point, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ppath(point, path) is 'implementation of <@ operator';

alter function pg_catalog.on_ppath(point, path) owner to "kim-uijin";

create function pg_catalog.box_center(box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_center(box) is 'implementation of @@ operator';

alter function pg_catalog.box_center(box) owner to "kim-uijin";

create function pg_catalog.areasel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areasel(internal, oid, internal, integer) is 'restriction selectivity for area-comparison operators';

alter function pg_catalog.areasel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for area-comparison operators';

alter function pg_catalog.areajoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.int4mul(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mul(integer, integer) is 'implementation of * operator';

alter function pg_catalog.int4mul(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4ne(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ne(integer, integer) is 'implementation of <> operator';

alter function pg_catalog.int4ne(integer, integer) owner to "kim-uijin";

create function pg_catalog.int2ne(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ne(smallint, smallint) is 'implementation of <> operator';

alter function pg_catalog.int2ne(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2gt(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2gt(smallint, smallint) is 'implementation of > operator';

alter function pg_catalog.int2gt(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4gt(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4gt(integer, integer) is 'implementation of > operator';

alter function pg_catalog.int4gt(integer, integer) owner to "kim-uijin";

create function pg_catalog.int2le(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2le(smallint, smallint) is 'implementation of <= operator';

alter function pg_catalog.int2le(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4le(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4le(integer, integer) is 'implementation of <= operator';

alter function pg_catalog.int4le(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4ge(integer, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4ge(integer, integer) is 'implementation of >= operator';

alter function pg_catalog.int4ge(integer, integer) owner to "kim-uijin";

create function pg_catalog.int2ge(smallint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2ge(smallint, smallint) is 'implementation of >= operator';

alter function pg_catalog.int2ge(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2mul(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mul(smallint, smallint) is 'implementation of * operator';

alter function pg_catalog.int2mul(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2div(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2div(smallint, smallint) is 'implementation of / operator';

alter function pg_catalog.int2div(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4div(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4div(integer, integer) is 'implementation of / operator';

alter function pg_catalog.int4div(integer, integer) owner to "kim-uijin";

create function pg_catalog.int2mod(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mod(smallint, smallint) is 'implementation of % operator';

alter function pg_catalog.int2mod(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4mod(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mod(integer, integer) is 'implementation of % operator';

alter function pg_catalog.int4mod(integer, integer) owner to "kim-uijin";

create function pg_catalog.textne(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textne(text, text) is 'implementation of <> operator';

alter function pg_catalog.textne(text, text) owner to "kim-uijin";

create function pg_catalog.int24eq(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24eq(smallint, integer) is 'implementation of = operator';

alter function pg_catalog.int24eq(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42eq(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42eq(integer, smallint) is 'implementation of = operator';

alter function pg_catalog.int42eq(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24lt(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24lt(smallint, integer) is 'implementation of < operator';

alter function pg_catalog.int24lt(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42lt(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42lt(integer, smallint) is 'implementation of < operator';

alter function pg_catalog.int42lt(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24gt(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24gt(smallint, integer) is 'implementation of > operator';

alter function pg_catalog.int24gt(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42gt(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42gt(integer, smallint) is 'implementation of > operator';

alter function pg_catalog.int42gt(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24ne(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ne(smallint, integer) is 'implementation of <> operator';

alter function pg_catalog.int24ne(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42ne(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ne(integer, smallint) is 'implementation of <> operator';

alter function pg_catalog.int42ne(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24le(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24le(smallint, integer) is 'implementation of <= operator';

alter function pg_catalog.int24le(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42le(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42le(integer, smallint) is 'implementation of <= operator';

alter function pg_catalog.int42le(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24ge(smallint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24ge(smallint, integer) is 'implementation of >= operator';

alter function pg_catalog.int24ge(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42ge(integer, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42ge(integer, smallint) is 'implementation of >= operator';

alter function pg_catalog.int42ge(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24mul(smallint, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mul(smallint, integer) is 'implementation of * operator';

alter function pg_catalog.int24mul(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42mul(integer, smallint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mul(integer, smallint) is 'implementation of * operator';

alter function pg_catalog.int42mul(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int24div(smallint, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24div(smallint, integer) is 'implementation of / operator';

alter function pg_catalog.int24div(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42div(integer, smallint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42div(integer, smallint) is 'implementation of / operator';

alter function pg_catalog.int42div(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int2pl(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2pl(smallint, smallint) is 'implementation of + operator';

alter function pg_catalog.int2pl(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4pl(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4pl(integer, integer) is 'implementation of + operator';

alter function pg_catalog.int4pl(integer, integer) owner to "kim-uijin";

create function pg_catalog.int24pl(smallint, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24pl(smallint, integer) is 'implementation of + operator';

alter function pg_catalog.int24pl(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42pl(integer, smallint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42pl(integer, smallint) is 'implementation of + operator';

alter function pg_catalog.int42pl(integer, smallint) owner to "kim-uijin";

create function pg_catalog.int2mi(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2mi(smallint, smallint) is 'implementation of - operator';

alter function pg_catalog.int2mi(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int4mi(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4mi(integer, integer) is 'implementation of - operator';

alter function pg_catalog.int4mi(integer, integer) owner to "kim-uijin";

create function pg_catalog.int24mi(smallint, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int24mi(smallint, integer) is 'implementation of - operator';

alter function pg_catalog.int24mi(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int42mi(integer, smallint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int42mi(integer, smallint) is 'implementation of - operator';

alter function pg_catalog.int42mi(integer, smallint) owner to "kim-uijin";

create function pg_catalog.oideq(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oideq(oid, oid) is 'implementation of = operator';

alter function pg_catalog.oideq(oid, oid) owner to "kim-uijin";

create function pg_catalog.oidne(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidne(oid, oid) is 'implementation of <> operator';

alter function pg_catalog.oidne(oid, oid) owner to "kim-uijin";

create function pg_catalog.box_same(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_same(box, box) is 'implementation of ~= operator';

alter function pg_catalog.box_same(box, box) owner to "kim-uijin";

create function pg_catalog.box_contain(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain(box, box) is 'implementation of @> operator';

alter function pg_catalog.box_contain(box, box) owner to "kim-uijin";

create function pg_catalog.box_left(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_left(box, box) is 'implementation of << operator';

alter function pg_catalog.box_left(box, box) owner to "kim-uijin";

create function pg_catalog.box_overleft(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overleft(box, box) is 'implementation of &< operator';

alter function pg_catalog.box_overleft(box, box) owner to "kim-uijin";

create function pg_catalog.box_overright(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overright(box, box) is 'implementation of &> operator';

alter function pg_catalog.box_overright(box, box) owner to "kim-uijin";

create function pg_catalog.box_right(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_right(box, box) is 'implementation of >> operator';

alter function pg_catalog.box_right(box, box) owner to "kim-uijin";

create function pg_catalog.box_contained(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contained(box, box) is 'implementation of <@ operator';

alter function pg_catalog.box_contained(box, box) owner to "kim-uijin";

create function pg_catalog.box_contain_pt(box, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_contain_pt(box, point) is 'implementation of @> operator';

alter function pg_catalog.box_contain_pt(box, point) owner to "kim-uijin";

create function pg_catalog.pg_node_tree_in(cstring) returns pg_node_tree
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_in(cstring) is 'I/O';

alter function pg_catalog.pg_node_tree_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_node_tree_out(pg_node_tree) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_out(pg_node_tree) is 'I/O';

alter function pg_catalog.pg_node_tree_out(pg_node_tree) owner to "kim-uijin";

create function pg_catalog.pg_node_tree_recv(internal) returns pg_node_tree
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_recv(internal) is 'I/O';

alter function pg_catalog.pg_node_tree_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_node_tree_send(pg_node_tree) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_node_tree_send(pg_node_tree) is 'I/O';

alter function pg_catalog.pg_node_tree_send(pg_node_tree) owner to "kim-uijin";

create function pg_catalog.float4in(cstring) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4in(cstring) is 'I/O';

alter function pg_catalog.float4in(cstring) owner to "kim-uijin";

create function pg_catalog.float4out(real) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4out(real) is 'I/O';

alter function pg_catalog.float4out(real) owner to "kim-uijin";

create function pg_catalog.float4mul(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mul(real, real) is 'implementation of * operator';

alter function pg_catalog.float4mul(real, real) owner to "kim-uijin";

create function pg_catalog.float4div(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4div(real, real) is 'implementation of / operator';

alter function pg_catalog.float4div(real, real) owner to "kim-uijin";

create function pg_catalog.float4pl(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4pl(real, real) is 'implementation of + operator';

alter function pg_catalog.float4pl(real, real) owner to "kim-uijin";

create function pg_catalog.float4mi(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4mi(real, real) is 'implementation of - operator';

alter function pg_catalog.float4mi(real, real) owner to "kim-uijin";

create function pg_catalog.float4um(real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4um(real) is 'implementation of - operator';

alter function pg_catalog.float4um(real) owner to "kim-uijin";

create function pg_catalog.float4abs(real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4abs(real) is 'implementation of @ operator';

alter function pg_catalog.float4abs(real) owner to "kim-uijin";

create function pg_catalog.float4_accum(double precision[], real) returns double precision[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4_accum(double precision[], real) is 'aggregate transition function';

alter function pg_catalog.float4_accum(double precision[], real) owner to "kim-uijin";

create function pg_catalog.float4larger(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4larger(real, real) is 'larger of two';

alter function pg_catalog.float4larger(real, real) owner to "kim-uijin";

create function pg_catalog.float4smaller(real, real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4smaller(real, real) is 'smaller of two';

alter function pg_catalog.float4smaller(real, real) owner to "kim-uijin";

create function pg_catalog.int4um(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4um(integer) is 'implementation of - operator';

alter function pg_catalog.int4um(integer) owner to "kim-uijin";

create function pg_catalog.int2um(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2um(smallint) is 'implementation of - operator';

alter function pg_catalog.int2um(smallint) owner to "kim-uijin";

create function pg_catalog.float8in(cstring) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8in(cstring) is 'I/O';

alter function pg_catalog.float8in(cstring) owner to "kim-uijin";

create function pg_catalog.float8out(double precision) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8out(double precision) is 'I/O';

alter function pg_catalog.float8out(double precision) owner to "kim-uijin";

create function pg_catalog.float8mul(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mul(double precision, double precision) is 'implementation of * operator';

alter function pg_catalog.float8mul(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8div(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8div(double precision, double precision) is 'implementation of / operator';

alter function pg_catalog.float8div(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8pl(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8pl(double precision, double precision) is 'implementation of + operator';

alter function pg_catalog.float8pl(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8mi(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8mi(double precision, double precision) is 'implementation of - operator';

alter function pg_catalog.float8mi(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8um(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8um(double precision) is 'implementation of - operator';

alter function pg_catalog.float8um(double precision) owner to "kim-uijin";

create function pg_catalog.float8abs(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8abs(double precision) is 'implementation of @ operator';

alter function pg_catalog.float8abs(double precision) owner to "kim-uijin";

create function pg_catalog.float8_accum(double precision[], double precision) returns double precision[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_accum(double precision[], double precision) is 'aggregate transition function';

alter function pg_catalog.float8_accum(double precision[], double precision) owner to "kim-uijin";

create function pg_catalog.float8larger(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8larger(double precision, double precision) is 'larger of two';

alter function pg_catalog.float8larger(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8smaller(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8smaller(double precision, double precision) is 'smaller of two';

alter function pg_catalog.float8smaller(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.lseg_center(lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_center(lseg) is 'implementation of @@ operator';

alter function pg_catalog.lseg_center(lseg) owner to "kim-uijin";

create function pg_catalog.path_center(path) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_center(path) is 'implementation of @@ operator';

alter function pg_catalog.path_center(path) owner to "kim-uijin";

create function pg_catalog.poly_center(polygon) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_center(polygon) is 'implementation of @@ operator';

alter function pg_catalog.poly_center(polygon) owner to "kim-uijin";

create function pg_catalog.dround(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dround(double precision) is 'round to nearest integer';

alter function pg_catalog.dround(double precision) owner to "kim-uijin";

create function pg_catalog.dtrunc(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dtrunc(double precision) is 'truncate to integer';

alter function pg_catalog.dtrunc(double precision) owner to "kim-uijin";

create function pg_catalog.dsqrt(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsqrt(double precision) is 'implementation of |/ operator';

alter function pg_catalog.dsqrt(double precision) owner to "kim-uijin";

create function pg_catalog.dcbrt(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dcbrt(double precision) is 'implementation of ||/ operator';

alter function pg_catalog.dcbrt(double precision) owner to "kim-uijin";

create function pg_catalog.dpow(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dpow(double precision, double precision) is 'implementation of ^ operator';

alter function pg_catalog.dpow(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.dexp(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dexp(double precision) is 'natural exponential (e^x)';

alter function pg_catalog.dexp(double precision) owner to "kim-uijin";

create function pg_catalog.dlog1(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog1(double precision) is 'natural logarithm';

alter function pg_catalog.dlog1(double precision) owner to "kim-uijin";

create function pg_catalog.float8(smallint) returns double precision
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(smallint) is 'convert int2 to float8';

alter function pg_catalog.float8(smallint) owner to "kim-uijin";

create function pg_catalog.float4(smallint) returns real
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(smallint) is 'convert int2 to float4';

alter function pg_catalog.float4(smallint) owner to "kim-uijin";

create function pg_catalog.int2(double precision) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(double precision) is 'convert float8 to int2';

alter function pg_catalog.int2(double precision) owner to "kim-uijin";

create function pg_catalog.int2(real) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(real) is 'convert float4 to int2';

alter function pg_catalog.int2(real) owner to "kim-uijin";

create function pg_catalog.line_distance(line, line) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_distance(line, line) is 'implementation of <-> operator';

alter function pg_catalog.line_distance(line, line) owner to "kim-uijin";

create function pg_catalog.nameeqtext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameeqtext(name, text) is 'implementation of = operator';

alter function pg_catalog.nameeqtext(name, text) owner to "kim-uijin";

create function pg_catalog.namelttext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelttext(name, text) is 'implementation of < operator';

alter function pg_catalog.namelttext(name, text) owner to "kim-uijin";

create function pg_catalog.nameletext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameletext(name, text) is 'implementation of <= operator';

alter function pg_catalog.nameletext(name, text) owner to "kim-uijin";

create function pg_catalog.namegetext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegetext(name, text) is 'implementation of >= operator';

alter function pg_catalog.namegetext(name, text) owner to "kim-uijin";

create function pg_catalog.namegttext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegttext(name, text) is 'implementation of > operator';

alter function pg_catalog.namegttext(name, text) owner to "kim-uijin";

create function pg_catalog.namenetext(name, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenetext(name, text) is 'implementation of <> operator';

alter function pg_catalog.namenetext(name, text) owner to "kim-uijin";

create function pg_catalog.btnametextcmp(name, text) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnametextcmp(name, text) is 'less-equal-greater';

alter function pg_catalog.btnametextcmp(name, text) owner to "kim-uijin";

create function pg_catalog.texteqname(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texteqname(text, name) is 'implementation of = operator';

alter function pg_catalog.texteqname(text, name) owner to "kim-uijin";

create function pg_catalog.textltname(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textltname(text, name) is 'implementation of < operator';

alter function pg_catalog.textltname(text, name) owner to "kim-uijin";

create function pg_catalog.textlename(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlename(text, name) is 'implementation of <= operator';

alter function pg_catalog.textlename(text, name) owner to "kim-uijin";

create function pg_catalog.textgename(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgename(text, name) is 'implementation of >= operator';

alter function pg_catalog.textgename(text, name) owner to "kim-uijin";

create function pg_catalog.textgtname(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textgtname(text, name) is 'implementation of > operator';

alter function pg_catalog.textgtname(text, name) owner to "kim-uijin";

create function pg_catalog.textnename(text, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnename(text, name) is 'implementation of <> operator';

alter function pg_catalog.textnename(text, name) owner to "kim-uijin";

create function pg_catalog.bttextnamecmp(text, name) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextnamecmp(text, name) is 'less-equal-greater';

alter function pg_catalog.bttextnamecmp(text, name) owner to "kim-uijin";

create function pg_catalog.nameconcatoid(name, oid) returns name
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameconcatoid(name, oid) is 'concatenate name and oid';

alter function pg_catalog.nameconcatoid(name, oid) owner to "kim-uijin";

create function pg_catalog.table_am_handler_in(cstring) returns table_am_handler
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_in(cstring) is 'I/O';

alter function pg_catalog.table_am_handler_in(cstring) owner to "kim-uijin";

create function pg_catalog.table_am_handler_out(table_am_handler) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_am_handler_out(table_am_handler) is 'I/O';

alter function pg_catalog.table_am_handler_out(table_am_handler) owner to "kim-uijin";

create function pg_catalog.timeofday() returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timeofday() is 'current date and time - increments during transactions';

alter function pg_catalog.timeofday() owner to "kim-uijin";

create function pg_catalog.pg_nextoid(regclass, name, regclass) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_nextoid(regclass, name, regclass) is 'return the next oid for a system table';

alter function pg_catalog.pg_nextoid(regclass, name, regclass) owner to "kim-uijin";

create function pg_catalog.float8_combine(double precision[], double precision[]) returns double precision[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_combine(double precision[], double precision[]) is 'aggregate combine function';

alter function pg_catalog.float8_combine(double precision[], double precision[]) owner to "kim-uijin";

create function pg_catalog.inter_sl(lseg, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sl(lseg, line) is 'implementation of ?# operator';

alter function pg_catalog.inter_sl(lseg, line) owner to "kim-uijin";

create function pg_catalog.inter_lb(line, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_lb(line, box) is 'implementation of ?# operator';

alter function pg_catalog.inter_lb(line, box) owner to "kim-uijin";

create function pg_catalog.float48mul(real, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mul(real, double precision) is 'implementation of * operator';

alter function pg_catalog.float48mul(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48div(real, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48div(real, double precision) is 'implementation of / operator';

alter function pg_catalog.float48div(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48pl(real, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48pl(real, double precision) is 'implementation of + operator';

alter function pg_catalog.float48pl(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48mi(real, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48mi(real, double precision) is 'implementation of - operator';

alter function pg_catalog.float48mi(real, double precision) owner to "kim-uijin";

create function pg_catalog.float84mul(double precision, real) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mul(double precision, real) is 'implementation of * operator';

alter function pg_catalog.float84mul(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84div(double precision, real) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84div(double precision, real) is 'implementation of / operator';

alter function pg_catalog.float84div(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84pl(double precision, real) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84pl(double precision, real) is 'implementation of + operator';

alter function pg_catalog.float84pl(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84mi(double precision, real) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84mi(double precision, real) is 'implementation of - operator';

alter function pg_catalog.float84mi(double precision, real) owner to "kim-uijin";

create function pg_catalog.float4eq(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4eq(real, real) is 'implementation of = operator';

alter function pg_catalog.float4eq(real, real) owner to "kim-uijin";

create function pg_catalog.float4ne(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ne(real, real) is 'implementation of <> operator';

alter function pg_catalog.float4ne(real, real) owner to "kim-uijin";

create function pg_catalog.float4lt(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4lt(real, real) is 'implementation of < operator';

alter function pg_catalog.float4lt(real, real) owner to "kim-uijin";

create function pg_catalog.float4le(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4le(real, real) is 'implementation of <= operator';

alter function pg_catalog.float4le(real, real) owner to "kim-uijin";

create function pg_catalog.float4gt(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4gt(real, real) is 'implementation of > operator';

alter function pg_catalog.float4gt(real, real) owner to "kim-uijin";

create function pg_catalog.float4ge(real, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4ge(real, real) is 'implementation of >= operator';

alter function pg_catalog.float4ge(real, real) owner to "kim-uijin";

create function pg_catalog.float8eq(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8eq(double precision, double precision) is 'implementation of = operator';

alter function pg_catalog.float8eq(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8ne(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ne(double precision, double precision) is 'implementation of <> operator';

alter function pg_catalog.float8ne(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8lt(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8lt(double precision, double precision) is 'implementation of < operator';

alter function pg_catalog.float8lt(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8le(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8le(double precision, double precision) is 'implementation of <= operator';

alter function pg_catalog.float8le(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8gt(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8gt(double precision, double precision) is 'implementation of > operator';

alter function pg_catalog.float8gt(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8ge(double precision, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8ge(double precision, double precision) is 'implementation of >= operator';

alter function pg_catalog.float8ge(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float48eq(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48eq(real, double precision) is 'implementation of = operator';

alter function pg_catalog.float48eq(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48ne(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ne(real, double precision) is 'implementation of <> operator';

alter function pg_catalog.float48ne(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48lt(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48lt(real, double precision) is 'implementation of < operator';

alter function pg_catalog.float48lt(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48le(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48le(real, double precision) is 'implementation of <= operator';

alter function pg_catalog.float48le(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48gt(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48gt(real, double precision) is 'implementation of > operator';

alter function pg_catalog.float48gt(real, double precision) owner to "kim-uijin";

create function pg_catalog.float48ge(real, double precision) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float48ge(real, double precision) is 'implementation of >= operator';

alter function pg_catalog.float48ge(real, double precision) owner to "kim-uijin";

create function pg_catalog.float84eq(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84eq(double precision, real) is 'implementation of = operator';

alter function pg_catalog.float84eq(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84ne(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ne(double precision, real) is 'implementation of <> operator';

alter function pg_catalog.float84ne(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84lt(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84lt(double precision, real) is 'implementation of < operator';

alter function pg_catalog.float84lt(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84le(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84le(double precision, real) is 'implementation of <= operator';

alter function pg_catalog.float84le(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84gt(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84gt(double precision, real) is 'implementation of > operator';

alter function pg_catalog.float84gt(double precision, real) owner to "kim-uijin";

create function pg_catalog.float84ge(double precision, real) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float84ge(double precision, real) is 'implementation of >= operator';

alter function pg_catalog.float84ge(double precision, real) owner to "kim-uijin";

create function pg_catalog.float8(real) returns double precision
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(real) is 'convert float4 to float8';

alter function pg_catalog.float8(real) owner to "kim-uijin";

create function pg_catalog.float4(double precision) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(double precision) is 'convert float8 to float4';

alter function pg_catalog.float4(double precision) owner to "kim-uijin";

create function pg_catalog.int4(smallint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(smallint) is 'convert int2 to int4';

alter function pg_catalog.int4(smallint) owner to "kim-uijin";

create function pg_catalog.int2(integer) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(integer) is 'convert int4 to int2';

alter function pg_catalog.int2(integer) owner to "kim-uijin";

create function pg_catalog.pg_jit_available() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_jit_available() is 'Is JIT compilation available in this session?';

alter function pg_catalog.pg_jit_available() owner to "kim-uijin";

create function pg_catalog.float8(integer) returns double precision
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(integer) is 'convert int4 to float8';

alter function pg_catalog.float8(integer) owner to "kim-uijin";

create function pg_catalog.int4(double precision) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(double precision) is 'convert float8 to int4';

alter function pg_catalog.int4(double precision) owner to "kim-uijin";

create function pg_catalog.float4(integer) returns real
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(integer) is 'convert int4 to float4';

alter function pg_catalog.float4(integer) owner to "kim-uijin";

create function pg_catalog.int4(real) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(real) is 'convert float4 to int4';

alter function pg_catalog.int4(real) owner to "kim-uijin";

create function pg_catalog.width_bucket(double precision, double precision, double precision, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(double precision, double precision, double precision, integer) is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(double precision, double precision, double precision, integer) owner to "kim-uijin";

create function pg_catalog.json_in(cstring) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_in(cstring) is 'I/O';

alter function pg_catalog.json_in(cstring) owner to "kim-uijin";

create function pg_catalog.json_out(json) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_out(json) is 'I/O';

alter function pg_catalog.json_out(json) owner to "kim-uijin";

create function pg_catalog.json_recv(internal) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_recv(internal) is 'I/O';

alter function pg_catalog.json_recv(internal) owner to "kim-uijin";

create function pg_catalog.json_send(json) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_send(json) is 'I/O';

alter function pg_catalog.json_send(json) owner to "kim-uijin";

create function pg_catalog.index_am_handler_in(cstring) returns index_am_handler
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_in(cstring) is 'I/O';

alter function pg_catalog.index_am_handler_in(cstring) owner to "kim-uijin";

create function pg_catalog.index_am_handler_out(index_am_handler) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.index_am_handler_out(index_am_handler) is 'I/O';

alter function pg_catalog.index_am_handler_out(index_am_handler) owner to "kim-uijin";

create function pg_catalog.hashmacaddr8(macaddr8) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8(macaddr8) is 'hash';

alter function pg_catalog.hashmacaddr8(macaddr8) owner to "kim-uijin";

create function pg_catalog.hash_aclitem(aclitem) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem(aclitem) is 'hash';

alter function pg_catalog.hash_aclitem(aclitem) owner to "kim-uijin";

create function pg_catalog.bthandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bthandler(internal) is 'btree index access method handler';

alter function pg_catalog.bthandler(internal) owner to "kim-uijin";

create function pg_catalog.hashhandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashhandler(internal) is 'hash index access method handler';

alter function pg_catalog.hashhandler(internal) owner to "kim-uijin";

create function pg_catalog.gisthandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gisthandler(internal) is 'gist index access method handler';

alter function pg_catalog.gisthandler(internal) owner to "kim-uijin";

create function pg_catalog.ginhandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginhandler(internal) is 'gin index access method handler';

alter function pg_catalog.ginhandler(internal) owner to "kim-uijin";

create function pg_catalog.spghandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spghandler(internal) is 'spgist index access method handler';

alter function pg_catalog.spghandler(internal) owner to "kim-uijin";

create function pg_catalog.brinhandler(internal) returns index_am_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brinhandler(internal) is 'brin index access method handler';

alter function pg_catalog.brinhandler(internal) owner to "kim-uijin";

create function pg_catalog.scalarlesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlesel(internal, oid, internal, integer) is 'restriction selectivity of <= and related operators on scalar datatypes';

alter function pg_catalog.scalarlesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.scalargesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargesel(internal, oid, internal, integer) is 'restriction selectivity of >= and related operators on scalar datatypes';

alter function pg_catalog.scalargesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.amvalidate(oid) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.amvalidate(oid) is 'validate an operator class';

alter function pg_catalog.amvalidate(oid) owner to "kim-uijin";

create function pg_catalog.poly_same(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_same(polygon, polygon) is 'implementation of ~= operator';

alter function pg_catalog.poly_same(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_contain(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain(polygon, polygon) is 'implementation of @> operator';

alter function pg_catalog.poly_contain(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_left(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_left(polygon, polygon) is 'implementation of << operator';

alter function pg_catalog.poly_left(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_overleft(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overleft(polygon, polygon) is 'implementation of &< operator';

alter function pg_catalog.poly_overleft(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_overright(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overright(polygon, polygon) is 'implementation of &> operator';

alter function pg_catalog.poly_overright(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_right(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_right(polygon, polygon) is 'implementation of >> operator';

alter function pg_catalog.poly_right(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_contained(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contained(polygon, polygon) is 'implementation of <@ operator';

alter function pg_catalog.poly_contained(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_overlap(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overlap(polygon, polygon) is 'implementation of && operator';

alter function pg_catalog.poly_overlap(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_in(cstring) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_in(cstring) is 'I/O';

alter function pg_catalog.poly_in(cstring) owner to "kim-uijin";

create function pg_catalog.poly_out(polygon) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_out(polygon) is 'I/O';

alter function pg_catalog.poly_out(polygon) owner to "kim-uijin";

create function pg_catalog.btint2cmp(smallint, smallint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2cmp(smallint, smallint) is 'less-equal-greater';

alter function pg_catalog.btint2cmp(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.btint4cmp(integer, integer) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4cmp(integer, integer) is 'less-equal-greater';

alter function pg_catalog.btint4cmp(integer, integer) owner to "kim-uijin";

create function pg_catalog.btfloat4cmp(real, real) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4cmp(real, real) is 'less-equal-greater';

alter function pg_catalog.btfloat4cmp(real, real) owner to "kim-uijin";

create function pg_catalog.btfloat8cmp(double precision, double precision) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8cmp(double precision, double precision) is 'less-equal-greater';

alter function pg_catalog.btfloat8cmp(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.btoidcmp(oid, oid) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidcmp(oid, oid) is 'less-equal-greater';

alter function pg_catalog.btoidcmp(oid, oid) owner to "kim-uijin";

create function pg_catalog.dist_bp(box, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bp(box, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_bp(box, point) owner to "kim-uijin";

create function pg_catalog.btcharcmp("char", "char") returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btcharcmp("char", "char") is 'less-equal-greater';

alter function pg_catalog.btcharcmp("char", "char") owner to "kim-uijin";

create function pg_catalog.btnamecmp(name, name) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamecmp(name, name) is 'less-equal-greater';

alter function pg_catalog.btnamecmp(name, name) owner to "kim-uijin";

create function pg_catalog.bttextcmp(text, text) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextcmp(text, text) is 'less-equal-greater';

alter function pg_catalog.bttextcmp(text, text) owner to "kim-uijin";

create function pg_catalog.lseg_distance(lseg, lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_distance(lseg, lseg) is 'implementation of <-> operator';

alter function pg_catalog.lseg_distance(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_interpt(lseg, lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_interpt(lseg, lseg) is 'implementation of # operator';

alter function pg_catalog.lseg_interpt(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.dist_ps(point, lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ps(point, lseg) is 'implementation of <-> operator';

alter function pg_catalog.dist_ps(point, lseg) owner to "kim-uijin";

create function pg_catalog.dist_pb(point, box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pb(point, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_pb(point, box) owner to "kim-uijin";

create function pg_catalog.dist_sb(lseg, box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sb(lseg, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_sb(lseg, box) owner to "kim-uijin";

create function pg_catalog.close_ps(point, lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ps(point, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_ps(point, lseg) owner to "kim-uijin";

create function pg_catalog.close_pb(point, box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pb(point, box) is 'implementation of ## operator';

alter function pg_catalog.close_pb(point, box) owner to "kim-uijin";

create function pg_catalog.close_sb(lseg, box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sb(lseg, box) is 'implementation of ## operator';

alter function pg_catalog.close_sb(lseg, box) owner to "kim-uijin";

create function pg_catalog.on_ps(point, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_ps(point, lseg) is 'implementation of <@ operator';

alter function pg_catalog.on_ps(point, lseg) owner to "kim-uijin";

create function pg_catalog.path_distance(path, path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_distance(path, path) is 'implementation of <-> operator';

alter function pg_catalog.path_distance(path, path) owner to "kim-uijin";

create function pg_catalog.dist_ppath(point, path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppath(point, path) is 'implementation of <-> operator';

alter function pg_catalog.dist_ppath(point, path) owner to "kim-uijin";

create function pg_catalog.on_sb(lseg, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sb(lseg, box) is 'implementation of <@ operator';

alter function pg_catalog.on_sb(lseg, box) owner to "kim-uijin";

create function pg_catalog.inter_sb(lseg, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inter_sb(lseg, box) is 'implementation of ?# operator';

alter function pg_catalog.inter_sb(lseg, box) owner to "kim-uijin";

create function pg_catalog.string_to_array(text, text, text) returns text[]
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(text, text, text) is 'split delimited text, with null string';

alter function pg_catalog.string_to_array(text, text, text) owner to "kim-uijin";

create function pg_catalog.cash_cmp(money, money) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_cmp(money, money) is 'less-equal-greater';

alter function pg_catalog.cash_cmp(money, money) owner to "kim-uijin";

create function pg_catalog.array_append(anycompatiblearray, anycompatible) returns anycompatiblearray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_append(anycompatiblearray, anycompatible) is 'append element onto end of array';

alter function pg_catalog.array_append(anycompatiblearray, anycompatible) owner to "kim-uijin";

create function pg_catalog.array_prepend(anycompatible, anycompatiblearray) returns anycompatiblearray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_prepend(anycompatible, anycompatiblearray) is 'prepend element onto front of array';

alter function pg_catalog.array_prepend(anycompatible, anycompatiblearray) owner to "kim-uijin";

create function pg_catalog.dist_sp(lseg, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sp(lseg, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_sp(lseg, point) owner to "kim-uijin";

create function pg_catalog.dist_bs(box, lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bs(box, lseg) is 'implementation of <-> operator';

alter function pg_catalog.dist_bs(box, lseg) owner to "kim-uijin";

create function pg_catalog.btarraycmp(anyarray, anyarray) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btarraycmp(anyarray, anyarray) is 'less-equal-greater';

alter function pg_catalog.btarraycmp(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.array_cat(anycompatiblearray, anycompatiblearray) returns anycompatiblearray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_cat(anycompatiblearray, anycompatiblearray) is 'implementation of || operator';

alter function pg_catalog.array_cat(anycompatiblearray, anycompatiblearray) owner to "kim-uijin";

create function pg_catalog.array_to_string(anyarray, text, text) returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(anyarray, text, text) is 'concatenate array elements, using delimiter and null string, into text';

alter function pg_catalog.array_to_string(anyarray, text, text) owner to "kim-uijin";

create function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of <= and related operators on scalar datatypes';

alter function pg_catalog.scalarlejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.array_ne(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ne(anyarray, anyarray) is 'implementation of <> operator';

alter function pg_catalog.array_ne(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.array_lt(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lt(anyarray, anyarray) is 'implementation of < operator';

alter function pg_catalog.array_lt(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.array_gt(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_gt(anyarray, anyarray) is 'implementation of > operator';

alter function pg_catalog.array_gt(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.array_le(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_le(anyarray, anyarray) is 'implementation of <= operator';

alter function pg_catalog.array_le(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.string_to_array(text, text) returns text[]
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_to_array(text, text) is 'split delimited text';

alter function pg_catalog.string_to_array(text, text) owner to "kim-uijin";

create function pg_catalog.array_to_string(anyarray, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_string(anyarray, text) is 'concatenate array elements, using delimiter, into text';

alter function pg_catalog.array_to_string(anyarray, text) owner to "kim-uijin";

create function pg_catalog.array_ge(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ge(anyarray, anyarray) is 'implementation of >= operator';

alter function pg_catalog.array_ge(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of >= and related operators on scalar datatypes';

alter function pg_catalog.scalargejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.hashmacaddr(macaddr) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr(macaddr) is 'hash';

alter function pg_catalog.hashmacaddr(macaddr) owner to "kim-uijin";

create function pg_catalog.hashtext(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtext(text) is 'hash';

alter function pg_catalog.hashtext(text) owner to "kim-uijin";

create function pg_catalog.text(char) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(char) is 'convert char(n) to text';

alter function pg_catalog.text(char) owner to "kim-uijin";

create function pg_catalog.btoidvectorcmp(oidvector, oidvector) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidvectorcmp(oidvector, oidvector) is 'less-equal-greater';

alter function pg_catalog.btoidvectorcmp(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.text(name) returns text
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(name) is 'convert name to text';

alter function pg_catalog.text(name) owner to "kim-uijin";

create function pg_catalog.name(text) returns name
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(text) is 'convert text to name';

alter function pg_catalog.name(text) owner to "kim-uijin";

create function pg_catalog.bpchar(name, unknown, unknown) returns char
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(name, unknown, unknown) is 'convert name to char(n)';

alter function pg_catalog.bpchar(name, unknown, unknown) owner to "kim-uijin";

create function pg_catalog.name(char) returns name
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(char) is 'convert char(n) to name';

alter function pg_catalog.name(char) owner to "kim-uijin";

create function pg_catalog.dist_pathp(path, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pathp(path, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_pathp(path, point) owner to "kim-uijin";

create function pg_catalog.hashinet(inet) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinet(inet) is 'hash';

alter function pg_catalog.hashinet(inet) owner to "kim-uijin";

create function pg_catalog.hashint4extended(integer, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4extended(integer, bigint) is 'hash';

alter function pg_catalog.hashint4extended(integer, bigint) owner to "kim-uijin";

create function pg_catalog.hash_numeric(numeric) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric(numeric) is 'hash';

alter function pg_catalog.hash_numeric(numeric) owner to "kim-uijin";

create function pg_catalog.macaddr_in(cstring) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_in(cstring) is 'I/O';

alter function pg_catalog.macaddr_in(cstring) owner to "kim-uijin";

create function pg_catalog.macaddr_out(macaddr) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_out(macaddr) is 'I/O';

alter function pg_catalog.macaddr_out(macaddr) owner to "kim-uijin";

create function pg_catalog.num_nulls("any") returns integer
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nulls("any") is 'count the number of NULL arguments';

alter function pg_catalog.num_nulls("any") owner to "kim-uijin";

create function pg_catalog.num_nonnulls("any") returns integer
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.num_nonnulls("any") is 'count the number of non-NULL arguments';

alter function pg_catalog.num_nonnulls("any") owner to "kim-uijin";

create function pg_catalog.hashint2extended(smallint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2extended(smallint, bigint) is 'hash';

alter function pg_catalog.hashint2extended(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.hashint8extended(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8extended(bigint, bigint) is 'hash';

alter function pg_catalog.hashint8extended(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.hashfloat4extended(real, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4extended(real, bigint) is 'hash';

alter function pg_catalog.hashfloat4extended(real, bigint) owner to "kim-uijin";

create function pg_catalog.hashfloat8extended(double precision, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8extended(double precision, bigint) is 'hash';

alter function pg_catalog.hashfloat8extended(double precision, bigint) owner to "kim-uijin";

create function pg_catalog.hashoidextended(oid, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidextended(oid, bigint) is 'hash';

alter function pg_catalog.hashoidextended(oid, bigint) owner to "kim-uijin";

create function pg_catalog.hashcharextended("char", bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashcharextended("char", bigint) is 'hash';

alter function pg_catalog.hashcharextended("char", bigint) owner to "kim-uijin";

create function pg_catalog.hashnameextended(name, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashnameextended(name, bigint) is 'hash';

alter function pg_catalog.hashnameextended(name, bigint) owner to "kim-uijin";

create function pg_catalog.hashtextextended(text, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtextextended(text, bigint) is 'hash';

alter function pg_catalog.hashtextextended(text, bigint) owner to "kim-uijin";

create function pg_catalog.hashint2(smallint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint2(smallint) is 'hash';

alter function pg_catalog.hashint2(smallint) owner to "kim-uijin";

create function pg_catalog.hashint4(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint4(integer) is 'hash';

alter function pg_catalog.hashint4(integer) owner to "kim-uijin";

create function pg_catalog.hashfloat4(real) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat4(real) is 'hash';

alter function pg_catalog.hashfloat4(real) owner to "kim-uijin";

create function pg_catalog.hashfloat8(double precision) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashfloat8(double precision) is 'hash';

alter function pg_catalog.hashfloat8(double precision) owner to "kim-uijin";

create function pg_catalog.hashoid(oid) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoid(oid) is 'hash';

alter function pg_catalog.hashoid(oid) owner to "kim-uijin";

create function pg_catalog.hashchar("char") returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashchar("char") is 'hash';

alter function pg_catalog.hashchar("char") owner to "kim-uijin";

create function pg_catalog.hashname(name) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashname(name) is 'hash';

alter function pg_catalog.hashname(name) owner to "kim-uijin";

create function pg_catalog.hashvarlena(internal) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlena(internal) is 'hash';

alter function pg_catalog.hashvarlena(internal) owner to "kim-uijin";

create function pg_catalog.hashoidvector(oidvector) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvector(oidvector) is 'hash';

alter function pg_catalog.hashoidvector(oidvector) owner to "kim-uijin";

create function pg_catalog.text_larger(text, text) returns text
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_larger(text, text) is 'larger of two';

alter function pg_catalog.text_larger(text, text) owner to "kim-uijin";

create function pg_catalog.text_smaller(text, text) returns text
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_smaller(text, text) is 'smaller of two';

alter function pg_catalog.text_smaller(text, text) owner to "kim-uijin";

create function pg_catalog.int8in(cstring) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8in(cstring) is 'I/O';

alter function pg_catalog.int8in(cstring) owner to "kim-uijin";

create function pg_catalog.int8out(bigint) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8out(bigint) is 'I/O';

alter function pg_catalog.int8out(bigint) owner to "kim-uijin";

create function pg_catalog.int8um(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8um(bigint) is 'implementation of - operator';

alter function pg_catalog.int8um(bigint) owner to "kim-uijin";

create function pg_catalog.int8pl(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8pl(bigint, bigint) is 'implementation of + operator';

alter function pg_catalog.int8pl(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8mi(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mi(bigint, bigint) is 'implementation of - operator';

alter function pg_catalog.int8mi(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8mul(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mul(bigint, bigint) is 'implementation of * operator';

alter function pg_catalog.int8mul(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8div(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8div(bigint, bigint) is 'implementation of / operator';

alter function pg_catalog.int8div(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8eq(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8eq(bigint, bigint) is 'implementation of = operator';

alter function pg_catalog.int8eq(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8ne(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ne(bigint, bigint) is 'implementation of <> operator';

alter function pg_catalog.int8ne(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8lt(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8lt(bigint, bigint) is 'implementation of < operator';

alter function pg_catalog.int8lt(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8gt(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8gt(bigint, bigint) is 'implementation of > operator';

alter function pg_catalog.int8gt(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8le(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8le(bigint, bigint) is 'implementation of <= operator';

alter function pg_catalog.int8le(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8ge(bigint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8ge(bigint, bigint) is 'implementation of >= operator';

alter function pg_catalog.int8ge(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int84eq(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84eq(bigint, integer) is 'implementation of = operator';

alter function pg_catalog.int84eq(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84ne(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ne(bigint, integer) is 'implementation of <> operator';

alter function pg_catalog.int84ne(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84lt(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84lt(bigint, integer) is 'implementation of < operator';

alter function pg_catalog.int84lt(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84gt(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84gt(bigint, integer) is 'implementation of > operator';

alter function pg_catalog.int84gt(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84le(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84le(bigint, integer) is 'implementation of <= operator';

alter function pg_catalog.int84le(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84ge(bigint, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84ge(bigint, integer) is 'implementation of >= operator';

alter function pg_catalog.int84ge(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int4(bigint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bigint) is 'convert int8 to int4';

alter function pg_catalog.int4(bigint) owner to "kim-uijin";

create function pg_catalog.int8(integer) returns bigint
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(integer) is 'convert int4 to int8';

alter function pg_catalog.int8(integer) owner to "kim-uijin";

create function pg_catalog.float8(bigint) returns double precision
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(bigint) is 'convert int8 to float8';

alter function pg_catalog.float8(bigint) owner to "kim-uijin";

create function pg_catalog.int8(double precision) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(double precision) is 'convert float8 to int8';

alter function pg_catalog.int8(double precision) owner to "kim-uijin";

create function pg_catalog.array_larger(anyarray, anyarray) returns anyarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_larger(anyarray, anyarray) is 'larger of two';

alter function pg_catalog.array_larger(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.array_smaller(anyarray, anyarray) returns anyarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_smaller(anyarray, anyarray) is 'smaller of two';

alter function pg_catalog.array_smaller(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.abbrev(inet) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(inet) is 'abbreviated display of inet value';

alter function pg_catalog.abbrev(inet) owner to "kim-uijin";

create function pg_catalog.abbrev(cidr) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abbrev(cidr) is 'abbreviated display of cidr value';

alter function pg_catalog.abbrev(cidr) owner to "kim-uijin";

create function pg_catalog.set_masklen(inet, integer) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(inet, integer) is 'change netmask of inet';

alter function pg_catalog.set_masklen(inet, integer) owner to "kim-uijin";

create function pg_catalog.oidvectorne(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorne(oidvector, oidvector) is 'implementation of <> operator';

alter function pg_catalog.oidvectorne(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.hash_array(anyarray) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array(anyarray) is 'hash';

alter function pg_catalog.hash_array(anyarray) owner to "kim-uijin";

create function pg_catalog.set_masklen(cidr, integer) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_masklen(cidr, integer) is 'change netmask of cidr';

alter function pg_catalog.set_masklen(cidr, integer) owner to "kim-uijin";

create function pg_catalog.pg_indexam_has_property(oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_has_property(oid, text) is 'test property of an index access method';

alter function pg_catalog.pg_indexam_has_property(oid, text) owner to "kim-uijin";

create function pg_catalog.pg_index_has_property(regclass, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_has_property(regclass, text) is 'test property of an index';

alter function pg_catalog.pg_index_has_property(regclass, text) owner to "kim-uijin";

create function pg_catalog.pg_index_column_has_property(regclass, integer, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_index_column_has_property(regclass, integer, text) is 'test property of an index column';

alter function pg_catalog.pg_index_column_has_property(regclass, integer, text) owner to "kim-uijin";

create function pg_catalog.float4(bigint) returns real
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(bigint) is 'convert int8 to float4';

alter function pg_catalog.float4(bigint) owner to "kim-uijin";

create function pg_catalog.int8(real) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(real) is 'convert float4 to int8';

alter function pg_catalog.int8(real) owner to "kim-uijin";

create function pg_catalog.namelt(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelt(name, name) is 'implementation of < operator';

alter function pg_catalog.namelt(name, name) owner to "kim-uijin";

create function pg_catalog.namele(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namele(name, name) is 'implementation of <= operator';

alter function pg_catalog.namele(name, name) owner to "kim-uijin";

create function pg_catalog.namegt(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namegt(name, name) is 'implementation of > operator';

alter function pg_catalog.namegt(name, name) owner to "kim-uijin";

create function pg_catalog.namege(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namege(name, name) is 'implementation of >= operator';

alter function pg_catalog.namege(name, name) owner to "kim-uijin";

create function pg_catalog.namene(name, name) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namene(name, name) is 'implementation of <> operator';

alter function pg_catalog.namene(name, name) owner to "kim-uijin";

create function pg_catalog.bpchar(char, integer, boolean) returns char
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar(char, integer, boolean) is 'adjust char() to typmod length';

alter function pg_catalog.bpchar(char, integer, boolean) owner to "kim-uijin";

create function pg_catalog.varchar(varchar, integer, boolean) returns varchar
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(varchar, integer, boolean) is 'adjust varchar() to typmod length';

alter function pg_catalog.varchar(varchar, integer, boolean) owner to "kim-uijin";

create function pg_catalog.pg_indexam_progress_phasename(oid, bigint) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexam_progress_phasename(oid, bigint) is 'return name of given index build phase';

alter function pg_catalog.pg_indexam_progress_phasename(oid, bigint) owner to "kim-uijin";

create function pg_catalog.oidvectorlt(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorlt(oidvector, oidvector) is 'implementation of < operator';

alter function pg_catalog.oidvectorlt(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.oidvectorle(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorle(oidvector, oidvector) is 'implementation of <= operator';

alter function pg_catalog.oidvectorle(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.oidvectoreq(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectoreq(oidvector, oidvector) is 'implementation of = operator';

alter function pg_catalog.oidvectoreq(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.oidvectorge(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorge(oidvector, oidvector) is 'implementation of >= operator';

alter function pg_catalog.oidvectorge(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.oidvectorgt(oidvector, oidvector) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorgt(oidvector, oidvector) is 'implementation of > operator';

alter function pg_catalog.oidvectorgt(oidvector, oidvector) owner to "kim-uijin";

create function pg_catalog.network(inet) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network(inet) is 'network part of address';

alter function pg_catalog.network(inet) owner to "kim-uijin";

create function pg_catalog.netmask(inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.netmask(inet) is 'netmask of address';

alter function pg_catalog.netmask(inet) owner to "kim-uijin";

create function pg_catalog.masklen(inet) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.masklen(inet) is 'netmask length';

alter function pg_catalog.masklen(inet) owner to "kim-uijin";

create function pg_catalog.broadcast(inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.broadcast(inet) is 'broadcast address of network';

alter function pg_catalog.broadcast(inet) owner to "kim-uijin";

create function pg_catalog.host(inet) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.host(inet) is 'show address octets only';

alter function pg_catalog.host(inet) owner to "kim-uijin";

create function pg_catalog.dist_lp(line, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lp(line, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_lp(line, point) owner to "kim-uijin";

create function pg_catalog.dist_bl(box, line) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_bl(box, line) is 'implementation of <-> operator';

alter function pg_catalog.dist_bl(box, line) owner to "kim-uijin";

create function pg_catalog.dist_ls(line, lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ls(line, lseg) is 'implementation of <-> operator';

alter function pg_catalog.dist_ls(line, lseg) owner to "kim-uijin";

create function pg_catalog.getpgusername() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getpgusername() is 'deprecated, use current_user instead';

alter function pg_catalog.getpgusername() owner to "kim-uijin";

create function pg_catalog.family(inet) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.family(inet) is 'address family (4 for IPv4, 6 for IPv6)';

alter function pg_catalog.family(inet) owner to "kim-uijin";

create function pg_catalog.int2(bigint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(bigint) is 'convert int8 to int2';

alter function pg_catalog.int2(bigint) owner to "kim-uijin";

create function pg_catalog.lo_create(oid) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_create(oid) is 'large object create';

alter function pg_catalog.lo_create(oid) owner to "kim-uijin";

create function pg_catalog.oidlt(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlt(oid, oid) is 'implementation of < operator';

alter function pg_catalog.oidlt(oid, oid) owner to "kim-uijin";

create function pg_catalog.oidle(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidle(oid, oid) is 'implementation of <= operator';

alter function pg_catalog.oidle(oid, oid) owner to "kim-uijin";

create function pg_catalog.octet_length(bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bytea) is 'octet length';

alter function pg_catalog.octet_length(bytea) owner to "kim-uijin";

create function pg_catalog.get_byte(bytea, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_byte(bytea, integer) is 'get byte';

alter function pg_catalog.get_byte(bytea, integer) owner to "kim-uijin";

create function pg_catalog.set_byte(bytea, integer, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_byte(bytea, integer, integer) is 'set byte';

alter function pg_catalog.set_byte(bytea, integer, integer) owner to "kim-uijin";

create function pg_catalog.get_bit(bytea, bigint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bytea, bigint) is 'get bit';

alter function pg_catalog.get_bit(bytea, bigint) owner to "kim-uijin";

create function pg_catalog.set_bit(bytea, bigint, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bytea, bigint, integer) is 'set bit';

alter function pg_catalog.set_bit(bytea, bigint, integer) owner to "kim-uijin";

create function pg_catalog.dist_pl(point, line) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pl(point, line) is 'implementation of <-> operator';

alter function pg_catalog.dist_pl(point, line) owner to "kim-uijin";

create function pg_catalog.dist_lb(line, box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_lb(line, box) is 'implementation of <-> operator';

alter function pg_catalog.dist_lb(line, box) owner to "kim-uijin";

create function pg_catalog.dist_sl(lseg, line) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_sl(lseg, line) is 'implementation of <-> operator';

alter function pg_catalog.dist_sl(lseg, line) owner to "kim-uijin";

create function pg_catalog.dist_cpoly(circle, polygon) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoly(circle, polygon) is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoly(circle, polygon) owner to "kim-uijin";

create function pg_catalog.poly_distance(polygon, polygon) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_distance(polygon, polygon) is 'implementation of <-> operator';

alter function pg_catalog.poly_distance(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.text(inet) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(inet) is 'show all parts of inet/cidr value';

alter function pg_catalog.text(inet) owner to "kim-uijin";

create function pg_catalog.text_lt(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_lt(text, text) is 'implementation of < operator';

alter function pg_catalog.text_lt(text, text) owner to "kim-uijin";

create function pg_catalog.text_le(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_le(text, text) is 'implementation of <= operator';

alter function pg_catalog.text_le(text, text) owner to "kim-uijin";

create function pg_catalog.text_gt(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_gt(text, text) is 'implementation of > operator';

alter function pg_catalog.text_gt(text, text) owner to "kim-uijin";

create function pg_catalog.text_ge(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_ge(text, text) is 'implementation of >= operator';

alter function pg_catalog.text_ge(text, text) owner to "kim-uijin";

create function pg_catalog.array_eq(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_eq(anyarray, anyarray) is 'implementation of = operator';

alter function pg_catalog.array_eq(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog."current_user"() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_user"() is 'current user name';

alter function pg_catalog."current_user"() owner to "kim-uijin";

create function pg_catalog."session_user"() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."session_user"() is 'session user name';

alter function pg_catalog."session_user"() owner to "kim-uijin";

create function pg_catalog.array_dims(anyarray) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_dims(anyarray) is 'array dimensions';

alter function pg_catalog.array_dims(anyarray) owner to "kim-uijin";

create function pg_catalog.array_ndims(anyarray) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_ndims(anyarray) is 'number of array dimensions';

alter function pg_catalog.array_ndims(anyarray) owner to "kim-uijin";

create function pg_catalog.overlay(bytea, bytea, integer, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea, integer, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer, integer) owner to "kim-uijin";

create function pg_catalog.array_in(cstring, oid, integer) returns anyarray
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.array_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.array_out(anyarray) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_out(anyarray) is 'I/O';

alter function pg_catalog.array_out(anyarray) owner to "kim-uijin";

create function pg_catalog.overlay(bytea, bytea, integer, unknown) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bytea, bytea, integer, unknown) is 'substitute portion of string';

alter function pg_catalog.overlay(bytea, bytea, integer, unknown) owner to "kim-uijin";

create function pg_catalog.trunc(macaddr) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr) is 'MACADDR manufacturer fields';

alter function pg_catalog.trunc(macaddr) owner to "kim-uijin";

create function pg_catalog.int8(smallint) returns bigint
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(smallint) is 'convert int2 to int8';

alter function pg_catalog.int8(smallint) owner to "kim-uijin";

create function pg_catalog.lo_import(text) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(text) is 'large object import';

alter function pg_catalog.lo_import(text) owner to "kim-uijin";

create function pg_catalog.lo_export(oid, text) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_export(oid, text) is 'large object export';

alter function pg_catalog.lo_export(oid, text) owner to "kim-uijin";

create function pg_catalog.int4inc(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4inc(integer) is 'increment';

alter function pg_catalog.int4inc(integer) owner to "kim-uijin";

create function pg_catalog.lo_import(text, oid) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_import(text, oid) is 'large object import';

alter function pg_catalog.lo_import(text, oid) owner to "kim-uijin";

create function pg_catalog.int4larger(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4larger(integer, integer) is 'larger of two';

alter function pg_catalog.int4larger(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4smaller(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4smaller(integer, integer) is 'smaller of two';

alter function pg_catalog.int4smaller(integer, integer) owner to "kim-uijin";

create function pg_catalog.int2larger(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2larger(smallint, smallint) is 'larger of two';

alter function pg_catalog.int2larger(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2smaller(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2smaller(smallint, smallint) is 'smaller of two';

alter function pg_catalog.int2smaller(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.hashvarlenaextended(internal, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashvarlenaextended(internal, bigint) is 'hash';

alter function pg_catalog.hashvarlenaextended(internal, bigint) owner to "kim-uijin";

create function pg_catalog.hashoidvectorextended(oidvector, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashoidvectorextended(oidvector, bigint) is 'hash';

alter function pg_catalog.hashoidvectorextended(oidvector, bigint) owner to "kim-uijin";

create function pg_catalog.hash_aclitem_extended(aclitem, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_aclitem_extended(aclitem, bigint) is 'hash';

alter function pg_catalog.hash_aclitem_extended(aclitem, bigint) owner to "kim-uijin";

create function pg_catalog.hashmacaddrextended(macaddr, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddrextended(macaddr, bigint) is 'hash';

alter function pg_catalog.hashmacaddrextended(macaddr, bigint) owner to "kim-uijin";

create function pg_catalog.hashinetextended(inet, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashinetextended(inet, bigint) is 'hash';

alter function pg_catalog.hashinetextended(inet, bigint) owner to "kim-uijin";

create function pg_catalog.hash_numeric_extended(numeric, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_numeric_extended(numeric, bigint) is 'hash';

alter function pg_catalog.hash_numeric_extended(numeric, bigint) owner to "kim-uijin";

create function pg_catalog.hashmacaddr8extended(macaddr8, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashmacaddr8extended(macaddr8, bigint) is 'hash';

alter function pg_catalog.hashmacaddr8extended(macaddr8, bigint) owner to "kim-uijin";

create function pg_catalog.hash_array_extended(anyarray, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_array_extended(anyarray, bigint) is 'hash';

alter function pg_catalog.hash_array_extended(anyarray, bigint) owner to "kim-uijin";

create function pg_catalog.dist_polyc(polygon, circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyc(polygon, circle) is 'implementation of <-> operator';

alter function pg_catalog.dist_polyc(polygon, circle) owner to "kim-uijin";

create function pg_catalog.pg_client_encoding() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_client_encoding() is 'encoding name of current database';

alter function pg_catalog.pg_client_encoding() owner to "kim-uijin";

create function pg_catalog.current_query() returns text
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_query() is 'get the currently executing query';

alter function pg_catalog.current_query() owner to "kim-uijin";

create function pg_catalog.macaddr_eq(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_eq(macaddr, macaddr) is 'implementation of = operator';

alter function pg_catalog.macaddr_eq(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_lt(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_lt(macaddr, macaddr) is 'implementation of < operator';

alter function pg_catalog.macaddr_lt(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_le(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_le(macaddr, macaddr) is 'implementation of <= operator';

alter function pg_catalog.macaddr_le(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_gt(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_gt(macaddr, macaddr) is 'implementation of > operator';

alter function pg_catalog.macaddr_gt(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_ge(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ge(macaddr, macaddr) is 'implementation of >= operator';

alter function pg_catalog.macaddr_ge(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_ne(macaddr, macaddr) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_ne(macaddr, macaddr) is 'implementation of <> operator';

alter function pg_catalog.macaddr_ne(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_cmp(macaddr, macaddr) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_cmp(macaddr, macaddr) is 'less-equal-greater';

alter function pg_catalog.macaddr_cmp(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.int82pl(bigint, smallint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82pl(bigint, smallint) is 'implementation of + operator';

alter function pg_catalog.int82pl(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82mi(bigint, smallint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mi(bigint, smallint) is 'implementation of - operator';

alter function pg_catalog.int82mi(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82mul(bigint, smallint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82mul(bigint, smallint) is 'implementation of * operator';

alter function pg_catalog.int82mul(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82div(bigint, smallint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82div(bigint, smallint) is 'implementation of / operator';

alter function pg_catalog.int82div(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int28pl(smallint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28pl(smallint, bigint) is 'implementation of + operator';

alter function pg_catalog.int28pl(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.btint8cmp(bigint, bigint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8cmp(bigint, bigint) is 'less-equal-greater';

alter function pg_catalog.btint8cmp(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.cash_mul_flt4(money, real) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt4(money, real) is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt4(money, real) owner to "kim-uijin";

create function pg_catalog.cash_div_flt4(money, real) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt4(money, real) is 'implementation of / operator';

alter function pg_catalog.cash_div_flt4(money, real) owner to "kim-uijin";

create function pg_catalog.flt4_mul_cash(real, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt4_mul_cash(real, money) is 'implementation of * operator';

alter function pg_catalog.flt4_mul_cash(real, money) owner to "kim-uijin";

create function pg_catalog.position(text, text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(text, text) is 'position of substring';

alter function pg_catalog.position(text, text) owner to "kim-uijin";

create function pg_catalog.textlike(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike(text, text) is 'implementation of ~~ operator';

alter function pg_catalog.textlike(text, text) owner to "kim-uijin";

create function pg_catalog.textnlike(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textnlike(text, text) is 'implementation of !~~ operator';

alter function pg_catalog.textnlike(text, text) owner to "kim-uijin";

create function pg_catalog.int48eq(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48eq(integer, bigint) is 'implementation of = operator';

alter function pg_catalog.int48eq(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48ne(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ne(integer, bigint) is 'implementation of <> operator';

alter function pg_catalog.int48ne(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48lt(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48lt(integer, bigint) is 'implementation of < operator';

alter function pg_catalog.int48lt(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48gt(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48gt(integer, bigint) is 'implementation of > operator';

alter function pg_catalog.int48gt(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48le(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48le(integer, bigint) is 'implementation of <= operator';

alter function pg_catalog.int48le(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48ge(integer, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48ge(integer, bigint) is 'implementation of >= operator';

alter function pg_catalog.int48ge(integer, bigint) owner to "kim-uijin";

create function pg_catalog.namelike(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namelike(name, text) is 'implementation of ~~ operator';

alter function pg_catalog.namelike(name, text) owner to "kim-uijin";

create function pg_catalog.namenlike(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namenlike(name, text) is 'implementation of !~~ operator';

alter function pg_catalog.namenlike(name, text) owner to "kim-uijin";

create function pg_catalog.bpchar("char") returns char
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar("char") is 'convert char to char(n)';

alter function pg_catalog.bpchar("char") owner to "kim-uijin";

create function pg_catalog.current_database() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_database() is 'name of the current database';

alter function pg_catalog.current_database() owner to "kim-uijin";

create function pg_catalog.int4_mul_cash(integer, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_mul_cash(integer, money) is 'implementation of * operator';

alter function pg_catalog.int4_mul_cash(integer, money) owner to "kim-uijin";

create function pg_catalog.int2_mul_cash(smallint, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_mul_cash(smallint, money) is 'implementation of * operator';

alter function pg_catalog.int2_mul_cash(smallint, money) owner to "kim-uijin";

create function pg_catalog.cash_mul_int4(money, integer) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int4(money, integer) is 'implementation of * operator';

alter function pg_catalog.cash_mul_int4(money, integer) owner to "kim-uijin";

create function pg_catalog.cash_div_int4(money, integer) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int4(money, integer) is 'implementation of / operator';

alter function pg_catalog.cash_div_int4(money, integer) owner to "kim-uijin";

create function pg_catalog.cash_mul_int2(money, smallint) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int2(money, smallint) is 'implementation of * operator';

alter function pg_catalog.cash_mul_int2(money, smallint) owner to "kim-uijin";

create function pg_catalog.cash_div_int2(money, smallint) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int2(money, smallint) is 'implementation of / operator';

alter function pg_catalog.cash_div_int2(money, smallint) owner to "kim-uijin";

create function pg_catalog.strpos(text, text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strpos(text, text) is 'position of substring';

alter function pg_catalog.strpos(text, text) owner to "kim-uijin";

create function pg_catalog.lower(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(text) is 'lowercase';

alter function pg_catalog.lower(text) owner to "kim-uijin";

create function pg_catalog.upper(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(text) is 'uppercase';

alter function pg_catalog.upper(text) owner to "kim-uijin";

create function pg_catalog.initcap(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.initcap(text) is 'capitalize each word';

alter function pg_catalog.initcap(text) owner to "kim-uijin";

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lpad(text, integer, text) is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer, text) owner to "kim-uijin";

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rpad(text, integer, text) is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer, text) owner to "kim-uijin";

create function pg_catalog.ltrim(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(text, text) is 'trim selected characters from left end of string';

alter function pg_catalog.ltrim(text, text) owner to "kim-uijin";

create function pg_catalog.rtrim(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(text, text) is 'trim selected characters from right end of string';

alter function pg_catalog.rtrim(text, text) owner to "kim-uijin";

create function pg_catalog.substr(text, integer, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text, integer, integer) is 'extract portion of string';

alter function pg_catalog.substr(text, integer, integer) owner to "kim-uijin";

create function pg_catalog.translate(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.translate(text, text, text) is 'map a set of characters appearing in string';

alter function pg_catalog.translate(text, text, text) owner to "kim-uijin";

create function pg_catalog.lpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN lpad($1, $2, ' '::text);

comment on function pg_catalog.lpad(text, integer, unknown) is 'left-pad string to length';

alter function pg_catalog.lpad(text, integer, unknown) owner to "kim-uijin";

create function pg_catalog.rpad(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN rpad($1, $2, ' '::text);

comment on function pg_catalog.rpad(text, integer, unknown) is 'right-pad string to length';

alter function pg_catalog.rpad(text, integer, unknown) owner to "kim-uijin";

create function pg_catalog.ltrim(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(text) is 'trim spaces from left end of string';

alter function pg_catalog.ltrim(text) owner to "kim-uijin";

create function pg_catalog.rtrim(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(text) is 'trim spaces from right end of string';

alter function pg_catalog.rtrim(text) owner to "kim-uijin";

create function pg_catalog.substr(text, integer, unknown) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(text, integer, unknown) is 'extract portion of string';

alter function pg_catalog.substr(text, integer, unknown) owner to "kim-uijin";

create function pg_catalog.btrim(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(text, text) is 'trim selected characters from both ends of string';

alter function pg_catalog.btrim(text, text) owner to "kim-uijin";

create function pg_catalog.btrim(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(text) is 'trim spaces from both ends of string';

alter function pg_catalog.btrim(text) owner to "kim-uijin";

create function pg_catalog.cash_in(cstring) returns money
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_in(cstring) is 'I/O';

alter function pg_catalog.cash_in(cstring) owner to "kim-uijin";

create function pg_catalog.cash_out(money) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_out(money) is 'I/O';

alter function pg_catalog.cash_out(money) owner to "kim-uijin";

create function pg_catalog.cash_eq(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_eq(money, money) is 'implementation of = operator';

alter function pg_catalog.cash_eq(money, money) owner to "kim-uijin";

create function pg_catalog.cash_ne(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ne(money, money) is 'implementation of <> operator';

alter function pg_catalog.cash_ne(money, money) owner to "kim-uijin";

create function pg_catalog.cash_lt(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_lt(money, money) is 'implementation of < operator';

alter function pg_catalog.cash_lt(money, money) owner to "kim-uijin";

create function pg_catalog.cash_le(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_le(money, money) is 'implementation of <= operator';

alter function pg_catalog.cash_le(money, money) owner to "kim-uijin";

create function pg_catalog.cash_gt(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_gt(money, money) is 'implementation of > operator';

alter function pg_catalog.cash_gt(money, money) owner to "kim-uijin";

create function pg_catalog.cash_ge(money, money) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_ge(money, money) is 'implementation of >= operator';

alter function pg_catalog.cash_ge(money, money) owner to "kim-uijin";

create function pg_catalog.cash_pl(money, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_pl(money, money) is 'implementation of + operator';

alter function pg_catalog.cash_pl(money, money) owner to "kim-uijin";

create function pg_catalog.cash_mi(money, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mi(money, money) is 'implementation of - operator';

alter function pg_catalog.cash_mi(money, money) owner to "kim-uijin";

create function pg_catalog.cash_mul_flt8(money, double precision) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_flt8(money, double precision) is 'implementation of * operator';

alter function pg_catalog.cash_mul_flt8(money, double precision) owner to "kim-uijin";

create function pg_catalog.cash_div_flt8(money, double precision) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_flt8(money, double precision) is 'implementation of / operator';

alter function pg_catalog.cash_div_flt8(money, double precision) owner to "kim-uijin";

create function pg_catalog.cashlarger(money, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashlarger(money, money) is 'larger of two';

alter function pg_catalog.cashlarger(money, money) owner to "kim-uijin";

create function pg_catalog.cashsmaller(money, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cashsmaller(money, money) is 'smaller of two';

alter function pg_catalog.cashsmaller(money, money) owner to "kim-uijin";

create function pg_catalog.inet_in(cstring) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_in(cstring) is 'I/O';

alter function pg_catalog.inet_in(cstring) owner to "kim-uijin";

create function pg_catalog.inet_out(inet) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_out(inet) is 'I/O';

alter function pg_catalog.inet_out(inet) owner to "kim-uijin";

create function pg_catalog.flt8_mul_cash(double precision, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.flt8_mul_cash(double precision, money) is 'implementation of * operator';

alter function pg_catalog.flt8_mul_cash(double precision, money) owner to "kim-uijin";

create function pg_catalog.network_eq(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_eq(inet, inet) is 'implementation of = operator';

alter function pg_catalog.network_eq(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_lt(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_lt(inet, inet) is 'implementation of < operator';

alter function pg_catalog.network_lt(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_le(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_le(inet, inet) is 'implementation of <= operator';

alter function pg_catalog.network_le(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_gt(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_gt(inet, inet) is 'implementation of > operator';

alter function pg_catalog.network_gt(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_ge(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ge(inet, inet) is 'implementation of >= operator';

alter function pg_catalog.network_ge(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_ne(inet, inet) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_ne(inet, inet) is 'implementation of <> operator';

alter function pg_catalog.network_ne(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_cmp(inet, inet) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_cmp(inet, inet) is 'less-equal-greater';

alter function pg_catalog.network_cmp(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_sub(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sub(inet, inet) is 'implementation of << operator';

alter function pg_catalog.network_sub(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_subeq(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subeq(inet, inet) is 'implementation of <<= operator';

alter function pg_catalog.network_subeq(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_sup(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sup(inet, inet) is 'implementation of >> operator';

alter function pg_catalog.network_sup(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_supeq(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_supeq(inet, inet) is 'implementation of >>= operator';

alter function pg_catalog.network_supeq(inet, inet) owner to "kim-uijin";

create function pg_catalog.cash_words(money) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_words(money) is 'output money amount as words';

alter function pg_catalog.cash_words(money) owner to "kim-uijin";

create function pg_catalog.substring(text, integer, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, integer, integer) is 'extract portion of string';

alter function pg_catalog.substring(text, integer, integer) owner to "kim-uijin";

create function pg_catalog.substring(text, integer, unknown) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, integer, unknown) is 'extract portion of string';

alter function pg_catalog.substring(text, integer, unknown) owner to "kim-uijin";

create function pg_catalog.generate_series(timestamp, timestamp, interval) returns setof setof timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp, timestamp, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp, timestamp, interval) owner to "kim-uijin";

create function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) returns setof setof timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) is 'non-persistent series generator';

alter function pg_catalog.generate_series(timestamp with time zone, timestamp with time zone, interval) owner to "kim-uijin";

create function pg_catalog.mod(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(smallint, smallint) is 'modulus';

alter function pg_catalog.mod(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.mod(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(integer, integer) is 'modulus';

alter function pg_catalog.mod(integer, integer) owner to "kim-uijin";

create function pg_catalog.int28mi(smallint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mi(smallint, bigint) is 'implementation of - operator';

alter function pg_catalog.int28mi(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28mul(smallint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28mul(smallint, bigint) is 'implementation of * operator';

alter function pg_catalog.int28mul(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.char(text) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char(text) is 'convert text to char';

alter function pg_catalog.char(text) owner to "kim-uijin";

create function pg_catalog.int8mod(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8mod(bigint, bigint) is 'implementation of % operator';

alter function pg_catalog.int8mod(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.text("char") returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text("char") is 'convert char to text';

alter function pg_catalog.text("char") owner to "kim-uijin";

create function pg_catalog.mod(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(bigint, bigint) is 'modulus';

alter function pg_catalog.mod(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int28div(smallint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28div(smallint, bigint) is 'implementation of / operator';

alter function pg_catalog.int28div(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.hashint8(bigint) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashint8(bigint) is 'hash';

alter function pg_catalog.hashint8(bigint) owner to "kim-uijin";

create function pg_catalog.lo_open(oid, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_open(oid, integer) is 'large object open';

alter function pg_catalog.lo_open(oid, integer) owner to "kim-uijin";

create function pg_catalog.lo_close(integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_close(integer) is 'large object close';

alter function pg_catalog.lo_close(integer) owner to "kim-uijin";

create function pg_catalog.loread(integer, integer) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.loread(integer, integer) is 'large object read';

alter function pg_catalog.loread(integer, integer) owner to "kim-uijin";

create function pg_catalog.lowrite(integer, bytea) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lowrite(integer, bytea) is 'large object write';

alter function pg_catalog.lowrite(integer, bytea) owner to "kim-uijin";

create function pg_catalog.lo_lseek(integer, integer, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek(integer, integer, integer) is 'large object seek';

alter function pg_catalog.lo_lseek(integer, integer, integer) owner to "kim-uijin";

create function pg_catalog.lo_creat(integer) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_creat(integer) is 'large object create';

alter function pg_catalog.lo_creat(integer) owner to "kim-uijin";

create function pg_catalog.lo_tell(integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell(integer) is 'large object position';

alter function pg_catalog.lo_tell(integer) owner to "kim-uijin";

create function pg_catalog.on_pl(point, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_pl(point, line) is 'implementation of <@ operator';

alter function pg_catalog.on_pl(point, line) owner to "kim-uijin";

create function pg_catalog.on_sl(lseg, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.on_sl(lseg, line) is 'implementation of <@ operator';

alter function pg_catalog.on_sl(lseg, line) owner to "kim-uijin";

create function pg_catalog.close_pl(point, line) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_pl(point, line) is 'implementation of ## operator';

alter function pg_catalog.close_pl(point, line) owner to "kim-uijin";

create function pg_catalog.close_sl(lseg, line) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_sl(lseg, line) is 'implementation of ## operator';

alter function pg_catalog.close_sl(lseg, line) owner to "kim-uijin";

create function pg_catalog.close_lb(line, box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lb(line, box) is 'implementation of ## operator';

alter function pg_catalog.close_lb(line, box) owner to "kim-uijin";

create function pg_catalog.lo_unlink(oid) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_unlink(oid) is 'large object unlink (delete)';

alter function pg_catalog.lo_unlink(oid) owner to "kim-uijin";

create function pg_catalog.hashbpcharextended(char, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpcharextended(char, bigint) is 'hash';

alter function pg_catalog.hashbpcharextended(char, bigint) owner to "kim-uijin";

create function pg_catalog.path_inter(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_inter(path, path) is 'implementation of ?# operator';

alter function pg_catalog.path_inter(path, path) owner to "kim-uijin";

create function pg_catalog.area(box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(box) is 'box area';

alter function pg_catalog.area(box) owner to "kim-uijin";

create function pg_catalog.width(box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width(box) is 'box width';

alter function pg_catalog.width(box) owner to "kim-uijin";

create function pg_catalog.height(box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.height(box) is 'box height';

alter function pg_catalog.height(box) owner to "kim-uijin";

create function pg_catalog.box_distance(box, box) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_distance(box, box) is 'implementation of <-> operator';

alter function pg_catalog.box_distance(box, box) owner to "kim-uijin";

create function pg_catalog.area(path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(path) is 'area of a closed path';

alter function pg_catalog.area(path) owner to "kim-uijin";

create function pg_catalog.box_intersect(box, box) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_intersect(box, box) is 'implementation of # operator';

alter function pg_catalog.box_intersect(box, box) owner to "kim-uijin";

create function pg_catalog.diagonal(box) returns lseg
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diagonal(box) is 'box diagonal';

alter function pg_catalog.diagonal(box) owner to "kim-uijin";

create function pg_catalog.path_n_lt(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_lt(path, path) is 'implementation of < operator';

alter function pg_catalog.path_n_lt(path, path) owner to "kim-uijin";

create function pg_catalog.path_n_gt(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_gt(path, path) is 'implementation of > operator';

alter function pg_catalog.path_n_gt(path, path) owner to "kim-uijin";

create function pg_catalog.path_n_eq(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_eq(path, path) is 'implementation of = operator';

alter function pg_catalog.path_n_eq(path, path) owner to "kim-uijin";

create function pg_catalog.path_n_le(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_le(path, path) is 'implementation of <= operator';

alter function pg_catalog.path_n_le(path, path) owner to "kim-uijin";

create function pg_catalog.path_n_ge(path, path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_n_ge(path, path) is 'implementation of >= operator';

alter function pg_catalog.path_n_ge(path, path) owner to "kim-uijin";

create function pg_catalog.path_length(path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_length(path) is 'implementation of @-@ operator';

alter function pg_catalog.path_length(path) owner to "kim-uijin";

create function pg_catalog.point_ne(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_ne(point, point) is 'implementation of <> operator';

alter function pg_catalog.point_ne(point, point) owner to "kim-uijin";

create function pg_catalog.point_vert(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_vert(point, point) is 'implementation of ?| operator';

alter function pg_catalog.point_vert(point, point) owner to "kim-uijin";

create function pg_catalog.point_horiz(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_horiz(point, point) is 'implementation of ?- operator';

alter function pg_catalog.point_horiz(point, point) owner to "kim-uijin";

create function pg_catalog.point_distance(point, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_distance(point, point) is 'implementation of <-> operator';

alter function pg_catalog.point_distance(point, point) owner to "kim-uijin";

create function pg_catalog.slope(point, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.slope(point, point) is 'slope between points';

alter function pg_catalog.slope(point, point) owner to "kim-uijin";

create function pg_catalog.lseg(point, point) returns lseg
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(point, point) is 'convert points to line segment';

alter function pg_catalog.lseg(point, point) owner to "kim-uijin";

create function pg_catalog.lseg_intersect(lseg, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_intersect(lseg, lseg) is 'implementation of ?# operator';

alter function pg_catalog.lseg_intersect(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_parallel(lseg, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_parallel(lseg, lseg) is 'implementation of ?|| operator';

alter function pg_catalog.lseg_parallel(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_perp(lseg, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_perp(lseg, lseg) is 'implementation of ?-| operator';

alter function pg_catalog.lseg_perp(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_vertical(lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_vertical(lseg) is 'implementation of ?| operator';

alter function pg_catalog.lseg_vertical(lseg) owner to "kim-uijin";

create function pg_catalog.lseg_horizontal(lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_horizontal(lseg) is 'implementation of ?- operator';

alter function pg_catalog.lseg_horizontal(lseg) owner to "kim-uijin";

create function pg_catalog.lseg_eq(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_eq(lseg, lseg) is 'implementation of = operator';

alter function pg_catalog.lseg_eq(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lo_truncate(integer, integer) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate(integer, integer) is 'truncate large object';

alter function pg_catalog.lo_truncate(integer, integer) owner to "kim-uijin";

create function pg_catalog.textlike_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlike_support(internal) is 'planner support for textlike';

alter function pg_catalog.textlike_support(internal) owner to "kim-uijin";

create function pg_catalog.texticregexeq_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq_support(internal) is 'planner support for texticregexeq';

alter function pg_catalog.texticregexeq_support(internal) owner to "kim-uijin";

create function pg_catalog.texticlike_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike_support(internal) is 'planner support for texticlike';

alter function pg_catalog.texticlike_support(internal) owner to "kim-uijin";

create function pg_catalog.timezone(interval, timestamp with time zone) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.gist_point_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_compress(internal) is 'GiST support';

alter function pg_catalog.gist_point_compress(internal) owner to "kim-uijin";

create function pg_catalog.aclitemin(cstring) returns aclitem
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemin(cstring) is 'I/O';

alter function pg_catalog.aclitemin(cstring) owner to "kim-uijin";

create function pg_catalog.aclitemout(aclitem) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemout(aclitem) is 'I/O';

alter function pg_catalog.aclitemout(aclitem) owner to "kim-uijin";

create function pg_catalog.aclinsert(aclitem[], aclitem) returns aclitem[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclinsert(aclitem[], aclitem) is 'add/update ACL item';

alter function pg_catalog.aclinsert(aclitem[], aclitem) owner to "kim-uijin";

create function pg_catalog.aclremove(aclitem[], aclitem) returns aclitem[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclremove(aclitem[], aclitem) is 'remove ACL item';

alter function pg_catalog.aclremove(aclitem[], aclitem) owner to "kim-uijin";

create function pg_catalog.aclcontains(aclitem[], aclitem) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclcontains(aclitem[], aclitem) is 'contains';

alter function pg_catalog.aclcontains(aclitem[], aclitem) owner to "kim-uijin";

create function pg_catalog.getdatabaseencoding() returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.getdatabaseencoding() is 'encoding name of current database';

alter function pg_catalog.getdatabaseencoding() owner to "kim-uijin";

create function pg_catalog.bpcharin(cstring, oid, integer) returns char
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharin(cstring, oid, integer) is 'I/O';

alter function pg_catalog.bpcharin(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.bpcharout(char) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharout(char) is 'I/O';

alter function pg_catalog.bpcharout(char) owner to "kim-uijin";

create function pg_catalog.varcharin(cstring, oid, integer) returns varchar
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharin(cstring, oid, integer) is 'I/O';

alter function pg_catalog.varcharin(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.varcharout(varchar) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharout(varchar) is 'I/O';

alter function pg_catalog.varcharout(varchar) owner to "kim-uijin";

create function pg_catalog.bpchareq(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchareq(char, char) is 'implementation of = operator';

alter function pg_catalog.bpchareq(char, char) owner to "kim-uijin";

create function pg_catalog.bpcharlt(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlt(char, char) is 'implementation of < operator';

alter function pg_catalog.bpcharlt(char, char) owner to "kim-uijin";

create function pg_catalog.bpcharle(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharle(char, char) is 'implementation of <= operator';

alter function pg_catalog.bpcharle(char, char) owner to "kim-uijin";

create function pg_catalog.bpchargt(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchargt(char, char) is 'implementation of > operator';

alter function pg_catalog.bpchargt(char, char) owner to "kim-uijin";

create function pg_catalog.bpcharge(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharge(char, char) is 'implementation of >= operator';

alter function pg_catalog.bpcharge(char, char) owner to "kim-uijin";

create function pg_catalog.bpcharne(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharne(char, char) is 'implementation of <> operator';

alter function pg_catalog.bpcharne(char, char) owner to "kim-uijin";

create function pg_catalog.aclitemeq(aclitem, aclitem) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.aclitemeq(aclitem, aclitem) is 'implementation of = operator';

alter function pg_catalog.aclitemeq(aclitem, aclitem) owner to "kim-uijin";

create function pg_catalog.bpchar_larger(char, char) returns char
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_larger(char, char) is 'larger of two';

alter function pg_catalog.bpchar_larger(char, char) owner to "kim-uijin";

create function pg_catalog.bpchar_smaller(char, char) returns char
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_smaller(char, char) is 'smaller of two';

alter function pg_catalog.bpchar_smaller(char, char) owner to "kim-uijin";

create function pg_catalog.pg_prepared_xact(out transaction xid, out gid text, out prepared timestamp with time zone, out ownerid oid, out dbid oid) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid) is 'view two-phase transactions';

alter function pg_catalog.pg_prepared_xact(out xid, out text, out timestamp with time zone, out oid, out oid) owner to "kim-uijin";

create function pg_catalog.generate_series(integer, integer, integer) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer, integer) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer, integer) owner to "kim-uijin";

create function pg_catalog.generate_series(integer, integer, unknown) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(integer, integer, unknown) is 'non-persistent series generator';

alter function pg_catalog.generate_series(integer, integer, unknown) owner to "kim-uijin";

create function pg_catalog.generate_series(bigint, bigint, bigint) returns setof setof bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint, bigint) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint, bigint) owner to "kim-uijin";

create function pg_catalog.generate_series(bigint, bigint, unknown) returns setof setof bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(bigint, bigint, unknown) is 'non-persistent series generator';

alter function pg_catalog.generate_series(bigint, bigint, unknown) owner to "kim-uijin";

create function pg_catalog.bpcharcmp(char, char) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharcmp(char, char) is 'less-equal-greater';

alter function pg_catalog.bpcharcmp(char, char) owner to "kim-uijin";

create function pg_catalog.regclass(text) returns regclass
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclass(text) is 'convert text to regclass';

alter function pg_catalog.regclass(text) owner to "kim-uijin";

create function pg_catalog.hashbpchar(char) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashbpchar(char) is 'hash';

alter function pg_catalog.hashbpchar(char) owner to "kim-uijin";

create function pg_catalog.format_type(oid, integer) returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format_type(oid, integer) is 'format a type oid and atttypmod to canonical SQL';

alter function pg_catalog.format_type(oid, integer) owner to "kim-uijin";

create function pg_catalog.date_in(cstring) returns date
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_in(cstring) is 'I/O';

alter function pg_catalog.date_in(cstring) owner to "kim-uijin";

create function pg_catalog.date_out(date) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_out(date) is 'I/O';

alter function pg_catalog.date_out(date) owner to "kim-uijin";

create function pg_catalog.date_eq(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq(date, date) is 'implementation of = operator';

alter function pg_catalog.date_eq(date, date) owner to "kim-uijin";

create function pg_catalog.date_lt(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt(date, date) is 'implementation of < operator';

alter function pg_catalog.date_lt(date, date) owner to "kim-uijin";

create function pg_catalog.date_le(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le(date, date) is 'implementation of <= operator';

alter function pg_catalog.date_le(date, date) owner to "kim-uijin";

create function pg_catalog.date_gt(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt(date, date) is 'implementation of > operator';

alter function pg_catalog.date_gt(date, date) owner to "kim-uijin";

create function pg_catalog.date_ge(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge(date, date) is 'implementation of >= operator';

alter function pg_catalog.date_ge(date, date) owner to "kim-uijin";

create function pg_catalog.date_ne(date, date) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne(date, date) is 'implementation of <> operator';

alter function pg_catalog.date_ne(date, date) owner to "kim-uijin";

create function pg_catalog.date_cmp(date, date) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp(date, date) is 'less-equal-greater';

alter function pg_catalog.date_cmp(date, date) owner to "kim-uijin";

create function pg_catalog.time_lt(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_lt(time, time) is 'implementation of < operator';

alter function pg_catalog.time_lt(time, time) owner to "kim-uijin";

create function pg_catalog.time_le(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_le(time, time) is 'implementation of <= operator';

alter function pg_catalog.time_le(time, time) owner to "kim-uijin";

create function pg_catalog.time_gt(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_gt(time, time) is 'implementation of > operator';

alter function pg_catalog.time_gt(time, time) owner to "kim-uijin";

create function pg_catalog.time_ge(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ge(time, time) is 'implementation of >= operator';

alter function pg_catalog.time_ge(time, time) owner to "kim-uijin";

create function pg_catalog.time_ne(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_ne(time, time) is 'implementation of <> operator';

alter function pg_catalog.time_ne(time, time) owner to "kim-uijin";

create function pg_catalog.time_cmp(time, time) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_cmp(time, time) is 'less-equal-greater';

alter function pg_catalog.time_cmp(time, time) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_wal(out wal_records bigint, out wal_fpi bigint, out wal_bytes numeric, out wal_buffers_full bigint, out wal_write bigint, out wal_sync bigint, out wal_write_time double precision, out wal_sync_time double precision, out stats_reset timestamp with time zone) returns record
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal(out bigint, out bigint, out numeric, out bigint, out bigint, out bigint, out double precision, out double precision, out timestamp with time zone) is 'statistics: information about WAL activity';

alter function pg_catalog.pg_stat_get_wal(out bigint, out bigint, out numeric, out bigint, out bigint, out bigint, out double precision, out double precision, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_get_wal_replay_pause_state() returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_wal_replay_pause_state() is 'get wal replay pause state';

alter function pg_catalog.pg_get_wal_replay_pause_state() owner to "kim-uijin";

create function pg_catalog.date_larger(date, date) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_larger(date, date) is 'larger of two';

alter function pg_catalog.date_larger(date, date) owner to "kim-uijin";

create function pg_catalog.date_smaller(date, date) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_smaller(date, date) is 'smaller of two';

alter function pg_catalog.date_smaller(date, date) owner to "kim-uijin";

create function pg_catalog.date_mi(date, date) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi(date, date) is 'implementation of - operator';

alter function pg_catalog.date_mi(date, date) owner to "kim-uijin";

create function pg_catalog.date_pli(date, integer) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pli(date, integer) is 'implementation of + operator';

alter function pg_catalog.date_pli(date, integer) owner to "kim-uijin";

create function pg_catalog.date_mii(date, integer) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mii(date, integer) is 'implementation of - operator';

alter function pg_catalog.date_mii(date, integer) owner to "kim-uijin";

create function pg_catalog.time_in(cstring, oid, integer) returns time
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.time_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.time_out(time) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_out(time) is 'I/O';

alter function pg_catalog.time_out(time) owner to "kim-uijin";

create function pg_catalog.time_eq(time, time) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_eq(time, time) is 'implementation of = operator';

alter function pg_catalog.time_eq(time, time) owner to "kim-uijin";

create function pg_catalog.circle_add_pt(circle, point) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_add_pt(circle, point) is 'implementation of + operator';

alter function pg_catalog.circle_add_pt(circle, point) owner to "kim-uijin";

create function pg_catalog.circle_sub_pt(circle, point) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_sub_pt(circle, point) is 'implementation of - operator';

alter function pg_catalog.circle_sub_pt(circle, point) owner to "kim-uijin";

create function pg_catalog.circle_mul_pt(circle, point) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_mul_pt(circle, point) is 'implementation of * operator';

alter function pg_catalog.circle_mul_pt(circle, point) owner to "kim-uijin";

create function pg_catalog.circle_div_pt(circle, point) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_div_pt(circle, point) is 'implementation of / operator';

alter function pg_catalog.circle_div_pt(circle, point) owner to "kim-uijin";

create function pg_catalog.timestamptz_in(cstring, oid, integer) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timestamptz_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.timestamptz_out(timestamp with time zone) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_out(timestamp with time zone) is 'I/O';

alter function pg_catalog.timestamptz_out(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.to_timestamp(double precision, unknown) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(double precision, unknown) is 'convert UNIX epoch to timestamptz';

alter function pg_catalog.to_timestamp(double precision, unknown) owner to "kim-uijin";

create function pg_catalog.timezone(text, timestamp with time zone) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, timestamp with time zone) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.interval_in(cstring, oid, integer) returns interval
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.interval_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.interval_out(interval) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_out(interval) is 'I/O';

alter function pg_catalog.interval_out(interval) owner to "kim-uijin";

create function pg_catalog.interval_eq(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_eq(interval, interval) is 'implementation of = operator';

alter function pg_catalog.interval_eq(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_ne(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ne(interval, interval) is 'implementation of <> operator';

alter function pg_catalog.interval_ne(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_lt(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_lt(interval, interval) is 'implementation of < operator';

alter function pg_catalog.interval_lt(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_le(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_le(interval, interval) is 'implementation of <= operator';

alter function pg_catalog.interval_le(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_ge(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_ge(interval, interval) is 'implementation of >= operator';

alter function pg_catalog.interval_ge(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_gt(interval, interval) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_gt(interval, interval) is 'implementation of > operator';

alter function pg_catalog.interval_gt(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_um(interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_um(interval) is 'implementation of - operator';

alter function pg_catalog.interval_um(interval) owner to "kim-uijin";

create function pg_catalog.interval_pl(interval, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_pl(interval, interval) is 'implementation of + operator';

alter function pg_catalog.interval_pl(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_mi(interval, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mi(interval, interval) is 'implementation of - operator';

alter function pg_catalog.interval_mi(interval, interval) owner to "kim-uijin";

create function pg_catalog.date_part(text, date) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, timestamp with time zone) is 'extract field from timestamp with time zone';

alter function pg_catalog.date_part(text, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_part(text, interval) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, interval) is 'extract field from interval';

alter function pg_catalog.date_part(text, interval) owner to "kim-uijin";

create function pg_catalog.network_subset_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_subset_support(internal) is 'planner support for network_sub/superset';

alter function pg_catalog.network_subset_support(internal) owner to "kim-uijin";

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date, unknown) is 'convert date to timestamp with time zone';

alter function pg_catalog.timestamptz(date, unknown) owner to "kim-uijin";

create function pg_catalog.justify_hours(interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_hours(interval) is 'promote groups of 24 hours to numbers of days';

alter function pg_catalog.justify_hours(interval) owner to "kim-uijin";

create function pg_catalog.timestamptz(date, time without time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
RETURN (($1 + $2))::timestamp with time zone;

comment on function pg_catalog.timestamptz(date, time) is 'convert date and time to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time) owner to "kim-uijin";

create function pg_catalog.jsonb_path_exists_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath exists test with timezone';

alter function pg_catalog.jsonb_path_exists_tz(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.date(timestamp with time zone) returns date
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp with time zone) is 'convert timestamp with time zone to date';

alter function pg_catalog.date(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns setof setof jsonb
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_path_query_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query with timezone';

alter function pg_catalog.jsonb_path_query_tz(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query_array_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query wrapped into array with timezone';

alter function pg_catalog.jsonb_path_query_array_tz(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(xid) is 'age of a transaction ID, in transactions before current transaction';

alter function pg_catalog.age(xid) owner to "kim-uijin";

create function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) is 'implementation of + operator';

alter function pg_catalog.timestamptz_pl_interval(timestamp with time zone, interval) owner to "kim-uijin";

create function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) is 'implementation of - operator';

alter function pg_catalog.timestamptz_mi_interval(timestamp with time zone, interval) owner to "kim-uijin";

create function pg_catalog.generate_subscripts(anyarray, integer, boolean) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_subscripts(anyarray, integer, boolean) is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer, boolean) owner to "kim-uijin";

create function pg_catalog.generate_subscripts(anyarray, integer, unknown) returns setof setof integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_subscripts(anyarray, integer, unknown) is 'array subscripts generator';

alter function pg_catalog.generate_subscripts(anyarray, integer, unknown) owner to "kim-uijin";

create function pg_catalog.array_fill(anyelement, integer[]) returns anyarray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(anyelement, integer[]) is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer[]) owner to "kim-uijin";

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log10(double precision) is 'base 10 logarithm';

alter function pg_catalog.log10(double precision) owner to "kim-uijin";

create function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) is 'smaller of two';

alter function pg_catalog.timestamptz_smaller(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) is 'larger of two';

alter function pg_catalog.timestamptz_larger(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.interval_smaller(interval, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_smaller(interval, interval) is 'smaller of two';

alter function pg_catalog.interval_smaller(interval, interval) owner to "kim-uijin";

create function pg_catalog.interval_larger(interval, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_larger(interval, interval) is 'larger of two';

alter function pg_catalog.interval_larger(interval, interval) owner to "kim-uijin";

create function pg_catalog.age(timestamp without time zone) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp with time zone, timestamp with time zone) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.interval(interval, integer) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(interval, integer) is 'adjust interval precision';

alter function pg_catalog.interval(interval, integer) owner to "kim-uijin";

create function pg_catalog.obj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT pg_description.description
FROM pg_description
WHERE ((pg_description.objoid = $1) AND (pg_description.classoid = ( SELECT pg_class.oid
                                                                     FROM pg_class
                                                                     WHERE ((pg_class.relname = $2) AND (pg_class.relnamespace = ('pg_catalog'::regnamespace)::oid)))) AND (pg_description.objsubid = 0));
END;

comment on function pg_catalog.obj_description(oid, name) is 'get description for object id and catalog name';

alter function pg_catalog.obj_description(oid, name) owner to "kim-uijin";

create function pg_catalog.col_description(oid, integer) returns text
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT pg_description.description
FROM pg_description
WHERE ((pg_description.objoid = $1) AND (pg_description.classoid = ('pg_class'::regclass)::oid) AND (pg_description.objsubid = $2));
END;

comment on function pg_catalog.col_description(oid, integer) is 'get description for table column';

alter function pg_catalog.col_description(oid, integer) owner to "kim-uijin";

create function pg_catalog.date_trunc(text, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp with time zone) is 'truncate timestamp with time zone to specified units';

alter function pg_catalog.date_trunc(text, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_trunc(text, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, interval) is 'truncate interval to specified units';

alter function pg_catalog.date_trunc(text, interval) owner to "kim-uijin";

create function pg_catalog.int8inc(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc(bigint) is 'increment';

alter function pg_catalog.int8inc(bigint) owner to "kim-uijin";

create function pg_catalog.int8abs(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8abs(bigint) is 'implementation of @ operator';

alter function pg_catalog.int8abs(bigint) owner to "kim-uijin";

create function pg_catalog.int8larger(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8larger(bigint, bigint) is 'larger of two';

alter function pg_catalog.int8larger(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8smaller(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8smaller(bigint, bigint) is 'smaller of two';

alter function pg_catalog.int8smaller(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.texticregexeq(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexeq(text, text) is 'implementation of ~* operator';

alter function pg_catalog.texticregexeq(text, text) owner to "kim-uijin";

create function pg_catalog.texticregexne(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticregexne(text, text) is 'implementation of !~* operator';

alter function pg_catalog.texticregexne(text, text) owner to "kim-uijin";

create function pg_catalog.nameicregexeq(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexeq(name, text) is 'implementation of ~* operator';

alter function pg_catalog.nameicregexeq(name, text) owner to "kim-uijin";

create function pg_catalog.nameicregexne(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicregexne(name, text) is 'implementation of !~* operator';

alter function pg_catalog.nameicregexne(name, text) owner to "kim-uijin";

create function pg_catalog.boolin(cstring) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolin(cstring) is 'I/O';

alter function pg_catalog.boolin(cstring) owner to "kim-uijin";

create function pg_catalog.boolout(boolean) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolout(boolean) is 'I/O';

alter function pg_catalog.boolout(boolean) owner to "kim-uijin";

create function pg_catalog.byteain(cstring) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteain(cstring) is 'I/O';

alter function pg_catalog.byteain(cstring) owner to "kim-uijin";

create function pg_catalog.charin(cstring) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charin(cstring) is 'I/O';

alter function pg_catalog.charin(cstring) owner to "kim-uijin";

create function pg_catalog.charlt("char", "char") returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charlt("char", "char") is 'implementation of < operator';

alter function pg_catalog.charlt("char", "char") owner to "kim-uijin";

create function pg_catalog.unique_key_recheck() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unique_key_recheck() is 'deferred UNIQUE constraint check';

alter function pg_catalog.unique_key_recheck() owner to "kim-uijin";

create function pg_catalog.int4abs(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4abs(integer) is 'implementation of @ operator';

alter function pg_catalog.int4abs(integer) owner to "kim-uijin";

create function pg_catalog.nameregexne(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameregexne(name, text) is 'implementation of !~ operator';

alter function pg_catalog.nameregexne(name, text) owner to "kim-uijin";

create function pg_catalog.int2abs(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2abs(smallint) is 'implementation of @ operator';

alter function pg_catalog.int2abs(smallint) owner to "kim-uijin";

create function pg_catalog.textregexeq(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq(text, text) is 'implementation of ~ operator';

alter function pg_catalog.textregexeq(text, text) owner to "kim-uijin";

create function pg_catalog.textregexne(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexne(text, text) is 'implementation of !~ operator';

alter function pg_catalog.textregexne(text, text) owner to "kim-uijin";

create function pg_catalog.textlen(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textlen(text) is 'length';

alter function pg_catalog.textlen(text) owner to "kim-uijin";

create function pg_catalog.textcat(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textcat(text, text) is 'implementation of || operator';

alter function pg_catalog.textcat(text, text) owner to "kim-uijin";

create function pg_catalog.pg_char_to_encoding(name) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_char_to_encoding(name) is 'convert encoding name to encoding id';

alter function pg_catalog.pg_char_to_encoding(name) owner to "kim-uijin";

create function pg_catalog.tidne(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidne(tid, tid) is 'implementation of <> operator';

alter function pg_catalog.tidne(tid, tid) owner to "kim-uijin";

create function pg_catalog.cidr_in(cstring) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_in(cstring) is 'I/O';

alter function pg_catalog.cidr_in(cstring) owner to "kim-uijin";

create function pg_catalog.parse_ident(str text, strict boolean default true) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.parse_ident(text, boolean) is 'parse qualified identifier to array of identifiers';

alter function pg_catalog.parse_ident(text, boolean) owner to "kim-uijin";

create function pg_catalog.pg_column_size("any") returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_size("any") is 'bytes required to store the value, perhaps with compression';

alter function pg_catalog.pg_column_size("any") owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time with time zone, time with time zone, time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.datetime_pl(date, time) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetime_pl(date, time) is 'implementation of + operator';

alter function pg_catalog.datetime_pl(date, time) owner to "kim-uijin";

create function pg_catalog.date_part(text, time with time zone) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, time with time zone) is 'extract field from time with time zone';

alter function pg_catalog.date_part(text, time with time zone) owner to "kim-uijin";

create function pg_catalog.int84pl(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84pl(bigint, integer) is 'implementation of + operator';

alter function pg_catalog.int84pl(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84mi(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mi(bigint, integer) is 'implementation of - operator';

alter function pg_catalog.int84mi(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84mul(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84mul(bigint, integer) is 'implementation of * operator';

alter function pg_catalog.int84mul(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int84div(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int84div(bigint, integer) is 'implementation of / operator';

alter function pg_catalog.int84div(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int48pl(integer, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48pl(integer, bigint) is 'implementation of + operator';

alter function pg_catalog.int48pl(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48mi(integer, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mi(integer, bigint) is 'implementation of - operator';

alter function pg_catalog.int48mi(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48mul(integer, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48mul(integer, bigint) is 'implementation of * operator';

alter function pg_catalog.int48mul(integer, bigint) owner to "kim-uijin";

create function pg_catalog.int48div(integer, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int48div(integer, bigint) is 'implementation of / operator';

alter function pg_catalog.int48div(integer, bigint) owner to "kim-uijin";

create function pg_catalog.quote_ident(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_ident(text) is 'quote an identifier for usage in a querystring';

alter function pg_catalog.quote_ident(text) owner to "kim-uijin";

create function pg_catalog.quote_literal(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_literal(text) is 'quote a literal for usage in a querystring';

alter function pg_catalog.quote_literal(text) owner to "kim-uijin";

create function pg_catalog.date_trunc(text, timestamp with time zone, text) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp with time zone, text) is 'truncate timestamp with time zone to specified units in specified time zone';

alter function pg_catalog.date_trunc(text, timestamp with time zone, text) owner to "kim-uijin";

create function pg_catalog.quote_literal(anyelement) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.quote_literal($1::pg_catalog.text)$$;

comment on function pg_catalog.quote_literal(anyelement) is 'quote a data value for usage in a querystring';

alter function pg_catalog.quote_literal(anyelement) owner to "kim-uijin";

create function pg_catalog.array_fill(anyelement, integer[], integer[]) returns anyarray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_fill(anyelement, integer[], integer[]) is 'array constructor with value';

alter function pg_catalog.array_fill(anyelement, integer[], integer[]) owner to "kim-uijin";

create function pg_catalog.oid(bigint) returns oid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oid(bigint) is 'convert int8 to oid';

alter function pg_catalog.oid(bigint) owner to "kim-uijin";

create function pg_catalog.int8(oid) returns bigint
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(oid) is 'convert oid to int8';

alter function pg_catalog.int8(oid) owner to "kim-uijin";

create function pg_catalog.quote_nullable(text) returns text
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.quote_nullable(text) is 'quote a possibly-null literal for usage in a querystring';

alter function pg_catalog.quote_nullable(text) owner to "kim-uijin";

create function pg_catalog.quote_nullable(anyelement) returns text
    stable
    parallel safe
    cost 1
    language sql
as
$$select pg_catalog.quote_nullable($1::pg_catalog.text)$$;

comment on function pg_catalog.quote_nullable(anyelement) is 'quote a possibly-null data value for usage in a querystring';

alter function pg_catalog.quote_nullable(anyelement) owner to "kim-uijin";

create function pg_catalog.suppress_redundant_updates_trigger() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.suppress_redundant_updates_trigger() is 'trigger to suppress updates when new and old records match';

alter function pg_catalog.suppress_redundant_updates_trigger() owner to "kim-uijin";

create function pg_catalog.tideq(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tideq(tid, tid) is 'implementation of = operator';

alter function pg_catalog.tideq(tid, tid) owner to "kim-uijin";

create function pg_catalog.unnest(anymultirange) returns setof setof anyrange
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.unnest(anymultirange) is 'expand multirange to set of ranges';

alter function pg_catalog.unnest(anymultirange) owner to "kim-uijin";

create function pg_catalog.currtid2(text, tid) returns tid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currtid2(text, tid) is 'latest tid of a tuple';

alter function pg_catalog.currtid2(text, tid) owner to "kim-uijin";

create function pg_catalog.justify_days(interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_days(interval) is 'promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_days(interval) owner to "kim-uijin";

create function pg_catalog.timedate_pl(time without time zone, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.timedate_pl(time, date) is 'implementation of + operator';

alter function pg_catalog.timedate_pl(time, date) owner to "kim-uijin";

create function pg_catalog.datetimetz_pl(date, time with time zone) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datetimetz_pl(date, time with time zone) is 'implementation of + operator';

alter function pg_catalog.datetimetz_pl(date, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetzdate_pl(time with time zone, date) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.timetzdate_pl(time with time zone, date) is 'implementation of + operator';

alter function pg_catalog.timetzdate_pl(time with time zone, date) owner to "kim-uijin";

create function pg_catalog.now() returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.now() is 'current transaction time';

alter function pg_catalog.now() owner to "kim-uijin";

create function pg_catalog.positionsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionsel(internal, oid, internal, integer) is 'restriction selectivity for position-comparison operators';

alter function pg_catalog.positionsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for position-comparison operators';

alter function pg_catalog.positionjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.contsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contsel(internal, oid, internal, integer) is 'restriction selectivity for containment comparison operators';

alter function pg_catalog.contsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for containment comparison operators';

alter function pg_catalog.contjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) returns boolean
    stable
    parallel safe
    cost 1
    language sql
RETURN (($1, $2) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, timestamp with time zone, timestamp with time zone, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) returns boolean
    stable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, $4));

comment on function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(time, time, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, time) owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(time, interval, time, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, time without time zone, time without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, $2) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(time, time, time, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, time, time, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(time without time zone, interval, time without time zone, time without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, $4));

comment on function pg_catalog."overlaps"(time, interval, time, time) is 'intervals overlap?';

alter function pg_catalog."overlaps"(time, interval, time, time) owner to "kim-uijin";

create function pg_catalog.timestamp_in(cstring, oid, integer) returns timestamp
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timestamp_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.timestamp_out(timestamp) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_out(timestamp) is 'I/O';

alter function pg_catalog.timestamp_out(timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.interval_cmp(interval, interval) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_cmp(interval, interval) is 'less-equal-greater';

alter function pg_catalog.interval_cmp(interval, interval) owner to "kim-uijin";

create function pg_catalog.time(timestamp, unknown) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp, unknown) is 'convert timestamp to time';

alter function pg_catalog.time(timestamp, unknown) owner to "kim-uijin";

create function pg_catalog.length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(text) is 'length';

alter function pg_catalog.length(text) owner to "kim-uijin";

create function pg_catalog.length(char) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(char) is 'character length';

alter function pg_catalog.length(char) owner to "kim-uijin";

create function pg_catalog.xideqint4(xid, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xideqint4(xid, integer) is 'implementation of = operator';

alter function pg_catalog.xideqint4(xid, integer) owner to "kim-uijin";

create function pg_catalog.interval_div(interval, double precision) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_div(interval, double precision) is 'implementation of / operator';

alter function pg_catalog.interval_div(interval, double precision) owner to "kim-uijin";

create function pg_catalog.dlog10(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dlog10(double precision) is 'base 10 logarithm';

alter function pg_catalog.dlog10(double precision) owner to "kim-uijin";

create function pg_catalog.log(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(double precision) is 'base 10 logarithm';

alter function pg_catalog.log(double precision) owner to "kim-uijin";

create function pg_catalog.ln(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(double precision) is 'natural logarithm';

alter function pg_catalog.ln(double precision) owner to "kim-uijin";

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(double precision) is 'round to nearest integer';

alter function pg_catalog.round(double precision) owner to "kim-uijin";

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(double precision) is 'truncate to integer';

alter function pg_catalog.trunc(double precision) owner to "kim-uijin";

create function pg_catalog.sqrt(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(double precision) is 'square root';

alter function pg_catalog.sqrt(double precision) owner to "kim-uijin";

create function pg_catalog.cbrt(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cbrt(double precision) is 'cube root';

alter function pg_catalog.cbrt(double precision) owner to "kim-uijin";

create function pg_catalog.pow(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(double precision, double precision) is 'exponentiation';

alter function pg_catalog.pow(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.exp(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(double precision) is 'natural exponential (e^x)';

alter function pg_catalog.exp(double precision) owner to "kim-uijin";

create function pg_catalog.obj_description(oid) returns text
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT pg_description.description
FROM pg_description
WHERE ((pg_description.objoid = $1) AND (pg_description.objsubid = 0));
END;

comment on function pg_catalog.obj_description(oid, unknown) is 'deprecated, use two-argument form instead';

alter function pg_catalog.obj_description(oid, unknown) owner to "kim-uijin";

create function pg_catalog.oidvectortypes(oidvector) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectortypes(oidvector) is 'print type names of oidvector field';

alter function pg_catalog.oidvectortypes(oidvector) owner to "kim-uijin";

create function pg_catalog.timetz_in(cstring, oid, integer) returns time with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.timetz_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.timetz_out(time with time zone) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_out(time with time zone) is 'I/O';

alter function pg_catalog.timetz_out(time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_eq(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_eq(time with time zone, time with time zone) is 'implementation of = operator';

alter function pg_catalog.timetz_eq(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_ne(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ne(time with time zone, time with time zone) is 'implementation of <> operator';

alter function pg_catalog.timetz_ne(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_lt(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_lt(time with time zone, time with time zone) is 'implementation of < operator';

alter function pg_catalog.timetz_lt(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_le(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_le(time with time zone, time with time zone) is 'implementation of <= operator';

alter function pg_catalog.timetz_le(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_ge(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_ge(time with time zone, time with time zone) is 'implementation of >= operator';

alter function pg_catalog.timetz_ge(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_gt(time with time zone, time with time zone) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_gt(time with time zone, time with time zone) is 'implementation of > operator';

alter function pg_catalog.timetz_gt(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_cmp(time with time zone, time with time zone) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_cmp(time with time zone, time with time zone) is 'less-equal-greater';

alter function pg_catalog.timetz_cmp(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz(date, time with time zone) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

alter function pg_catalog.timestamptz(date, time with time zone) owner to "kim-uijin";

create function pg_catalog.hostmask(inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hostmask(inet) is 'hostmask of address';

alter function pg_catalog.hostmask(inet) owner to "kim-uijin";

create function pg_catalog.textregexeq_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textregexeq_support(internal) is 'planner support for textregexeq';

alter function pg_catalog.textregexeq_support(internal) owner to "kim-uijin";

create function pg_catalog.makeaclitem(oid, oid, text, boolean) returns aclitem
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.makeaclitem(oid, oid, text, boolean) is 'make ACL item';

alter function pg_catalog.makeaclitem(oid, oid, text, boolean) owner to "kim-uijin";

create function pg_catalog.character_length(char) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(char) is 'character length';

alter function pg_catalog.character_length(char) owner to "kim-uijin";

create function pg_catalog.power(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(double precision, double precision) is 'exponentiation';

alter function pg_catalog.power(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.character_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.character_length(text) is 'character length';

alter function pg_catalog.character_length(text) owner to "kim-uijin";

create function pg_catalog.interval(time) returns interval
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval(time) is 'convert time to interval';

alter function pg_catalog.interval(time) owner to "kim-uijin";

create function pg_catalog.pg_lock_status(out locktype text, out database oid, out relation oid, out page integer, out tuple smallint, out virtualxid text, out transactionid xid, out classid oid, out objid oid, out objsubid smallint, out virtualtransaction text, out pid integer, out mode text, out granted boolean, out fastpath boolean, out waitstart timestamp with time zone) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean, out timestamp with time zone) is 'view system lock information';

alter function pg_catalog.pg_lock_status(out text, out oid, out oid, out integer, out smallint, out text, out xid, out oid, out oid, out smallint, out text, out integer, out text, out boolean, out boolean, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.char_length(char) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(char) is 'character length';

alter function pg_catalog.char_length(char) owner to "kim-uijin";

create function pg_catalog.isfinite(date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(date) is 'finite date?';

alter function pg_catalog.isfinite(date) owner to "kim-uijin";

create function pg_catalog.octet_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(text) is 'octet length';

alter function pg_catalog.octet_length(text) owner to "kim-uijin";

create function pg_catalog.octet_length(char) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(char) is 'octet length';

alter function pg_catalog.octet_length(char) owner to "kim-uijin";

create function pg_catalog.factorial(bigint) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.factorial(bigint) is 'factorial';

alter function pg_catalog.factorial(bigint) owner to "kim-uijin";

create function pg_catalog.time_larger(time, time) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_larger(time, time) is 'larger of two';

alter function pg_catalog.time_larger(time, time) owner to "kim-uijin";

create function pg_catalog.time_smaller(time, time) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_smaller(time, time) is 'smaller of two';

alter function pg_catalog.time_smaller(time, time) owner to "kim-uijin";

create function pg_catalog.timetz_larger(time with time zone, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_larger(time with time zone, time with time zone) is 'larger of two';

alter function pg_catalog.timetz_larger(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz_smaller(time with time zone, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_smaller(time with time zone, time with time zone) is 'smaller of two';

alter function pg_catalog.timetz_smaller(time with time zone, time with time zone) owner to "kim-uijin";

create function pg_catalog.char_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.char_length(text) is 'character length';

alter function pg_catalog.char_length(text) owner to "kim-uijin";

create function pg_catalog.date_part(text, date) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN date_part($1, ($2)::timestamp without time zone);

comment on function pg_catalog.date_part(text, date) is 'extract field from date';

alter function pg_catalog.date_part(text, date) owner to "kim-uijin";

create function pg_catalog.date_part(text, time) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, time) is 'extract field from time';

alter function pg_catalog.date_part(text, time) owner to "kim-uijin";

create function pg_catalog.age(timestamp with time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
RETURN age((CURRENT_DATE)::timestamp with time zone, $1);

comment on function pg_catalog.age(timestamp with time zone, unknown) is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp with time zone, unknown) owner to "kim-uijin";

create function pg_catalog.pg_get_constraintdef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(oid) is 'constraint description';

alter function pg_catalog.pg_get_constraintdef(oid) owner to "kim-uijin";

create function pg_catalog.timetz(timestamp with time zone, unknown) returns time with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(timestamp with time zone, unknown) is 'convert timestamp with time zone to time with time zone';

alter function pg_catalog.timetz(timestamp with time zone, unknown) owner to "kim-uijin";

create function pg_catalog.isfinite(timestamp with time zone) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(timestamp with time zone) is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.isfinite(interval) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(interval) is 'finite interval?';

alter function pg_catalog.isfinite(interval) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_start(integer) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_start(integer) is 'statistics: start time for current backend session';

alter function pg_catalog.pg_stat_get_backend_start(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_client_addr(integer) returns inet
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_addr(integer) is 'statistics: address of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_addr(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_client_port(integer) returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_client_port(integer) is 'statistics: port number of client connected to backend';

alter function pg_catalog.pg_stat_get_backend_client_port(integer) owner to "kim-uijin";

create function pg_catalog.abs(real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(real) is 'absolute value';

alter function pg_catalog.abs(real) owner to "kim-uijin";

create function pg_catalog.abs(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(double precision) is 'absolute value';

alter function pg_catalog.abs(double precision) owner to "kim-uijin";

create function pg_catalog.abs(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(bigint) is 'absolute value';

alter function pg_catalog.abs(bigint) owner to "kim-uijin";

create function pg_catalog.abs(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(integer) is 'absolute value';

alter function pg_catalog.abs(integer) owner to "kim-uijin";

create function pg_catalog.abs(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(smallint) is 'absolute value';

alter function pg_catalog.abs(smallint) owner to "kim-uijin";

create function pg_catalog.name(varchar) returns name
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.name(varchar) is 'convert varchar to name';

alter function pg_catalog.name(varchar) owner to "kim-uijin";

create function pg_catalog.varchar(name) returns varchar
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar(name) is 'convert name to varchar';

alter function pg_catalog.varchar(name) owner to "kim-uijin";

create function pg_catalog."current_schema"() returns name
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."current_schema"() is 'current schema name';

alter function pg_catalog."current_schema"() owner to "kim-uijin";

create function pg_catalog.current_schemas(boolean) returns name[]
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_schemas(boolean) is 'current schema search list';

alter function pg_catalog.current_schemas(boolean) owner to "kim-uijin";

create function pg_catalog.overlay(text, text, integer, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text, integer, integer) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer, integer) owner to "kim-uijin";

create function pg_catalog.overlay(text, text, integer, unknown) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(text, text, integer, unknown) is 'substitute portion of string';

alter function pg_catalog.overlay(text, text, integer, unknown) owner to "kim-uijin";

create function pg_catalog.isvertical(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(point, point) is 'vertically aligned';

alter function pg_catalog.isvertical(point, point) owner to "kim-uijin";

create function pg_catalog.ishorizontal(point, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(point, point) is 'horizontally aligned';

alter function pg_catalog.ishorizontal(point, point) owner to "kim-uijin";

create function pg_catalog.isparallel(lseg, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(lseg, lseg) is 'parallel';

alter function pg_catalog.isparallel(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.isperp(lseg, lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(lseg, lseg) is 'perpendicular';

alter function pg_catalog.isperp(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.isvertical(lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(lseg) is 'vertical';

alter function pg_catalog.isvertical(lseg) owner to "kim-uijin";

create function pg_catalog.ishorizontal(lseg) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(lseg) is 'horizontal';

alter function pg_catalog.ishorizontal(lseg) owner to "kim-uijin";

create function pg_catalog.isparallel(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isparallel(line, line) is 'parallel';

alter function pg_catalog.isparallel(line, line) owner to "kim-uijin";

create function pg_catalog.isperp(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isperp(line, line) is 'perpendicular';

alter function pg_catalog.isperp(line, line) owner to "kim-uijin";

create function pg_catalog.isvertical(line, unknown) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isvertical(line, unknown) is 'vertical';

alter function pg_catalog.isvertical(line, unknown) owner to "kim-uijin";

create function pg_catalog.ishorizontal(line, unknown) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ishorizontal(line, unknown) is 'horizontal';

alter function pg_catalog.ishorizontal(line, unknown) owner to "kim-uijin";

create function pg_catalog.point(circle) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(circle) is 'center of';

alter function pg_catalog.point(circle) owner to "kim-uijin";

create function pg_catalog.time(interval) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(interval) is 'convert interval to time';

alter function pg_catalog.time(interval) owner to "kim-uijin";

create function pg_catalog.box(point, point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point, point) is 'convert points to box';

alter function pg_catalog.box(point, point) owner to "kim-uijin";

create function pg_catalog.box_add(box, point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_add(box, point) is 'implementation of + operator';

alter function pg_catalog.box_add(box, point) owner to "kim-uijin";

create function pg_catalog.box_sub(box, point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_sub(box, point) is 'implementation of - operator';

alter function pg_catalog.box_sub(box, point) owner to "kim-uijin";

create function pg_catalog.box_mul(box, point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_mul(box, point) is 'implementation of * operator';

alter function pg_catalog.box_mul(box, point) owner to "kim-uijin";

create function pg_catalog.box_div(box, point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_div(box, point) is 'implementation of / operator';

alter function pg_catalog.box_div(box, point) owner to "kim-uijin";

create function pg_catalog.path_contain_pt(path, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN on_ppath($2, $1);

comment on function pg_catalog.path_contain_pt(path, point) is 'implementation of @> operator';

alter function pg_catalog.path_contain_pt(path, point) owner to "kim-uijin";

create function pg_catalog.cidr_out(cidr) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_out(cidr) is 'I/O';

alter function pg_catalog.cidr_out(cidr) owner to "kim-uijin";

create function pg_catalog.poly_contain_pt(polygon, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_contain_pt(polygon, point) is 'implementation of @> operator';

alter function pg_catalog.poly_contain_pt(polygon, point) owner to "kim-uijin";

create function pg_catalog.pt_contained_poly(point, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_poly(point, polygon) is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_poly(point, polygon) owner to "kim-uijin";

create function pg_catalog.isclosed(path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isclosed(path) is 'path closed?';

alter function pg_catalog.isclosed(path) owner to "kim-uijin";

create function pg_catalog.isopen(path) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isopen(path) is 'path open?';

alter function pg_catalog.isopen(path) owner to "kim-uijin";

create function pg_catalog.path_npoints(path) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_npoints(path) is 'implementation of # operator';

alter function pg_catalog.path_npoints(path) owner to "kim-uijin";

create function pg_catalog.pclose(path) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pclose(path) is 'close path';

alter function pg_catalog.pclose(path) owner to "kim-uijin";

create function pg_catalog.popen(path) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.popen(path) is 'open path';

alter function pg_catalog.popen(path) owner to "kim-uijin";

create function pg_catalog.path_add(path, path) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add(path, path) is 'implementation of + operator';

alter function pg_catalog.path_add(path, path) owner to "kim-uijin";

create function pg_catalog.path_add_pt(path, point) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_add_pt(path, point) is 'implementation of + operator';

alter function pg_catalog.path_add_pt(path, point) owner to "kim-uijin";

create function pg_catalog.path_sub_pt(path, point) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_sub_pt(path, point) is 'implementation of - operator';

alter function pg_catalog.path_sub_pt(path, point) owner to "kim-uijin";

create function pg_catalog.path_mul_pt(path, point) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_mul_pt(path, point) is 'implementation of * operator';

alter function pg_catalog.path_mul_pt(path, point) owner to "kim-uijin";

create function pg_catalog.path_div_pt(path, point) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_div_pt(path, point) is 'implementation of / operator';

alter function pg_catalog.path_div_pt(path, point) owner to "kim-uijin";

create function pg_catalog.point(double precision, double precision) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(double precision, double precision) is 'convert x, y to point';

alter function pg_catalog.point(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.point_add(point, point) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_add(point, point) is 'implementation of + operator';

alter function pg_catalog.point_add(point, point) owner to "kim-uijin";

create function pg_catalog.point_sub(point, point) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_sub(point, point) is 'implementation of - operator';

alter function pg_catalog.point_sub(point, point) owner to "kim-uijin";

create function pg_catalog.point_mul(point, point) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_mul(point, point) is 'implementation of * operator';

alter function pg_catalog.point_mul(point, point) owner to "kim-uijin";

create function pg_catalog.point_div(point, point) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_div(point, point) is 'implementation of / operator';

alter function pg_catalog.point_div(point, point) owner to "kim-uijin";

create function pg_catalog.poly_npoints(polygon) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_npoints(polygon) is 'implementation of # operator';

alter function pg_catalog.poly_npoints(polygon) owner to "kim-uijin";

create function pg_catalog.box(polygon, unknown) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(polygon, unknown) is 'convert polygon to bounding box';

alter function pg_catalog.box(polygon, unknown) owner to "kim-uijin";

create function pg_catalog.path(polygon) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path(polygon) is 'convert polygon to path';

alter function pg_catalog.path(polygon) owner to "kim-uijin";

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(box) is 'convert box to polygon';

alter function pg_catalog.polygon(box) owner to "kim-uijin";

create function pg_catalog.polygon(path) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(path) is 'convert path to polygon';

alter function pg_catalog.polygon(path) owner to "kim-uijin";

create function pg_catalog.circle_in(cstring) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_in(cstring) is 'I/O';

alter function pg_catalog.circle_in(cstring) owner to "kim-uijin";

create function pg_catalog.circle_out(circle) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_out(circle) is 'I/O';

alter function pg_catalog.circle_out(circle) owner to "kim-uijin";

create function pg_catalog.circle_same(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_same(circle, circle) is 'implementation of ~= operator';

alter function pg_catalog.circle_same(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_contain(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain(circle, circle) is 'implementation of @> operator';

alter function pg_catalog.circle_contain(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_left(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_left(circle, circle) is 'implementation of << operator';

alter function pg_catalog.circle_left(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_overleft(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overleft(circle, circle) is 'implementation of &< operator';

alter function pg_catalog.circle_overleft(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_overright(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overright(circle, circle) is 'implementation of &> operator';

alter function pg_catalog.circle_overright(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_right(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_right(circle, circle) is 'implementation of >> operator';

alter function pg_catalog.circle_right(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_contained(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contained(circle, circle) is 'implementation of <@ operator';

alter function pg_catalog.circle_contained(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_overlap(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overlap(circle, circle) is 'implementation of && operator';

alter function pg_catalog.circle_overlap(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_below(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_below(circle, circle) is 'implementation of <<| operator';

alter function pg_catalog.circle_below(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_above(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_above(circle, circle) is 'implementation of |>> operator';

alter function pg_catalog.circle_above(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_eq(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_eq(circle, circle) is 'implementation of = operator';

alter function pg_catalog.circle_eq(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_ne(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ne(circle, circle) is 'implementation of <> operator';

alter function pg_catalog.circle_ne(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_lt(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_lt(circle, circle) is 'implementation of < operator';

alter function pg_catalog.circle_lt(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_gt(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_gt(circle, circle) is 'implementation of > operator';

alter function pg_catalog.circle_gt(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_le(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_le(circle, circle) is 'implementation of <= operator';

alter function pg_catalog.circle_le(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_ge(circle, circle) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_ge(circle, circle) is 'implementation of >= operator';

alter function pg_catalog.circle_ge(circle, circle) owner to "kim-uijin";

create function pg_catalog.area(circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.area(circle) is 'area of circle';

alter function pg_catalog.area(circle) owner to "kim-uijin";

create function pg_catalog.diameter(circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.diameter(circle) is 'diameter of circle';

alter function pg_catalog.diameter(circle) owner to "kim-uijin";

create function pg_catalog.radius(circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radius(circle) is 'radius of circle';

alter function pg_catalog.radius(circle) owner to "kim-uijin";

create function pg_catalog.circle_distance(circle, circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_distance(circle, circle) is 'implementation of <-> operator';

alter function pg_catalog.circle_distance(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_center(circle) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_center(circle) is 'implementation of @@ operator';

alter function pg_catalog.circle_center(circle) owner to "kim-uijin";

create function pg_catalog.circle(point, double precision) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(point, double precision) is 'convert point and radius to circle';

alter function pg_catalog.circle(point, double precision) owner to "kim-uijin";

create function pg_catalog.circle(polygon, unknown) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(polygon, unknown) is 'convert polygon to circle';

alter function pg_catalog.circle(polygon, unknown) owner to "kim-uijin";

create function pg_catalog.polygon(integer, circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.polygon(integer, circle) is 'convert vertex count and circle to polygon';

alter function pg_catalog.polygon(integer, circle) owner to "kim-uijin";

create function pg_catalog.dist_pc(point, circle) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_pc(point, circle) is 'implementation of <-> operator';

alter function pg_catalog.dist_pc(point, circle) owner to "kim-uijin";

create function pg_catalog.circle_contain_pt(circle, point) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_contain_pt(circle, point) is 'implementation of @> operator';

alter function pg_catalog.circle_contain_pt(circle, point) owner to "kim-uijin";

create function pg_catalog.pt_contained_circle(point, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pt_contained_circle(point, circle) is 'implementation of <@ operator';

alter function pg_catalog.pt_contained_circle(point, circle) owner to "kim-uijin";

create function pg_catalog.circle(box) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle(box) is 'convert box to circle';

alter function pg_catalog.circle(box) owner to "kim-uijin";

create function pg_catalog.box(circle) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(circle) is 'convert circle to box';

alter function pg_catalog.box(circle) owner to "kim-uijin";

create function pg_catalog.log10(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN log((10)::numeric, $1);

comment on function pg_catalog.log10(numeric) is 'base 10 logarithm';

alter function pg_catalog.log10(numeric) owner to "kim-uijin";

create function pg_catalog.lseg_ne(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ne(lseg, lseg) is 'implementation of <> operator';

alter function pg_catalog.lseg_ne(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_lt(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_lt(lseg, lseg) is 'implementation of < operator';

alter function pg_catalog.lseg_lt(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_le(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_le(lseg, lseg) is 'implementation of <= operator';

alter function pg_catalog.lseg_le(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_gt(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_gt(lseg, lseg) is 'implementation of > operator';

alter function pg_catalog.lseg_gt(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_ge(lseg, lseg) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_ge(lseg, lseg) is 'implementation of >= operator';

alter function pg_catalog.lseg_ge(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.lseg_length(lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_length(lseg) is 'implementation of @-@ operator';

alter function pg_catalog.lseg_length(lseg) owner to "kim-uijin";

create function pg_catalog.close_ls(line, lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_ls(line, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_ls(line, lseg) owner to "kim-uijin";

create function pg_catalog.close_lseg(lseg, lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.close_lseg(lseg, lseg) is 'implementation of ## operator';

alter function pg_catalog.close_lseg(lseg, lseg) owner to "kim-uijin";

create function pg_catalog.line_in(cstring) returns line
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_in(cstring) is 'I/O';

alter function pg_catalog.line_in(cstring) owner to "kim-uijin";

create function pg_catalog.line_out(line) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_out(line) is 'I/O';

alter function pg_catalog.line_out(line) owner to "kim-uijin";

create function pg_catalog.line_eq(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_eq(line, line) is 'implementation of = operator';

alter function pg_catalog.line_eq(line, line) owner to "kim-uijin";

create function pg_catalog.line(point, point) returns line
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line(point, point) is 'construct line from points';

alter function pg_catalog.line(point, point) owner to "kim-uijin";

create function pg_catalog.line_interpt(line, line) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_interpt(line, line) is 'implementation of # operator';

alter function pg_catalog.line_interpt(line, line) owner to "kim-uijin";

create function pg_catalog.line_intersect(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_intersect(line, line) is 'implementation of ?# operator';

alter function pg_catalog.line_intersect(line, line) owner to "kim-uijin";

create function pg_catalog.line_parallel(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_parallel(line, line) is 'implementation of ?|| operator';

alter function pg_catalog.line_parallel(line, line) owner to "kim-uijin";

create function pg_catalog.line_perp(line, line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_perp(line, line) is 'implementation of ?-| operator';

alter function pg_catalog.line_perp(line, line) owner to "kim-uijin";

create function pg_catalog.line_vertical(line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_vertical(line) is 'implementation of ?| operator';

alter function pg_catalog.line_vertical(line) owner to "kim-uijin";

create function pg_catalog.line_horizontal(line) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_horizontal(line) is 'implementation of ?- operator';

alter function pg_catalog.line_horizontal(line) owner to "kim-uijin";

create function pg_catalog.length(lseg) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(lseg) is 'distance between endpoints';

alter function pg_catalog.length(lseg) owner to "kim-uijin";

create function pg_catalog.length(path) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(path) is 'sum of path segments';

alter function pg_catalog.length(path) owner to "kim-uijin";

create function pg_catalog.point(lseg) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(lseg) is 'center of';

alter function pg_catalog.point(lseg) owner to "kim-uijin";

create function pg_catalog.point(path) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(path) is 'center of';

alter function pg_catalog.point(path) owner to "kim-uijin";

create function pg_catalog.point(box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(box) is 'center of';

alter function pg_catalog.point(box) owner to "kim-uijin";

create function pg_catalog.point(polygon, unknown) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point(polygon, unknown) is 'center of';

alter function pg_catalog.point(polygon, unknown) owner to "kim-uijin";

create function pg_catalog.lseg(box) returns lseg
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg(box) is 'diagonal of';

alter function pg_catalog.lseg(box) owner to "kim-uijin";

create function pg_catalog.center(box) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(box) is 'center of';

alter function pg_catalog.center(box) owner to "kim-uijin";

create function pg_catalog.center(circle) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.center(circle) is 'center of';

alter function pg_catalog.center(circle) owner to "kim-uijin";

create function pg_catalog.polygon(circle) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN polygon(12, $1);

comment on function pg_catalog.polygon(circle, unknown) is 'convert circle to 12-vertex polygon';

alter function pg_catalog.polygon(circle, unknown) owner to "kim-uijin";

create function pg_catalog.npoints(path) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(path) is 'number of points';

alter function pg_catalog.npoints(path) owner to "kim-uijin";

create function pg_catalog.npoints(polygon) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.npoints(polygon) is 'number of points';

alter function pg_catalog.npoints(polygon) owner to "kim-uijin";

create function pg_catalog.bit_in(cstring, oid, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.bit_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.bit_out(bit) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_out(bit) is 'I/O';

alter function pg_catalog.bit_out(bit) owner to "kim-uijin";

create function pg_catalog."like"(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(text, text) is 'matches LIKE expression';

alter function pg_catalog."like"(text, text) owner to "kim-uijin";

create function pg_catalog.notlike(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(text, text) is 'does not match LIKE expression';

alter function pg_catalog.notlike(text, text) owner to "kim-uijin";

create function pg_catalog."like"(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(name, text) is 'matches LIKE expression';

alter function pg_catalog."like"(name, text) owner to "kim-uijin";

create function pg_catalog.notlike(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(name, text) is 'does not match LIKE expression';

alter function pg_catalog.notlike(name, text) owner to "kim-uijin";

create function pg_catalog.pg_get_ruledef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(oid) is 'source text of a rule';

alter function pg_catalog.pg_get_ruledef(oid) owner to "kim-uijin";

create function pg_catalog.nextval(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nextval(regclass) is 'sequence next value';

alter function pg_catalog.nextval(regclass) owner to "kim-uijin";

create function pg_catalog.currval(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.currval(regclass) is 'sequence current value';

alter function pg_catalog.currval(regclass) owner to "kim-uijin";

create function pg_catalog.setval(regclass, bigint) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(regclass, bigint) is 'set sequence value';

alter function pg_catalog.setval(regclass, bigint) owner to "kim-uijin";

create function pg_catalog.varbit_in(cstring, oid, integer) returns bit varying
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.varbit_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.varbit_out(bit varying) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_out(bit varying) is 'I/O';

alter function pg_catalog.varbit_out(bit varying) owner to "kim-uijin";

create function pg_catalog.biteq(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.biteq(bit, bit) is 'implementation of = operator';

alter function pg_catalog.biteq(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitne(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitne(bit, bit) is 'implementation of <> operator';

alter function pg_catalog.bitne(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitge(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitge(bit, bit) is 'implementation of >= operator';

alter function pg_catalog.bitge(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitgt(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitgt(bit, bit) is 'implementation of > operator';

alter function pg_catalog.bitgt(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitle(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitle(bit, bit) is 'implementation of <= operator';

alter function pg_catalog.bitle(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitlt(bit, bit) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitlt(bit, bit) is 'implementation of < operator';

alter function pg_catalog.bitlt(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitcmp(bit, bit) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcmp(bit, bit) is 'less-equal-greater';

alter function pg_catalog.bitcmp(bit, bit) owner to "kim-uijin";

create function pg_catalog.pg_encoding_to_char(integer) returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_to_char(integer) is 'convert encoding id to encoding name';

alter function pg_catalog.pg_encoding_to_char(integer) owner to "kim-uijin";

create function pg_catalog.random() returns double precision
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.random() is 'random value';

alter function pg_catalog.random() owner to "kim-uijin";

create function pg_catalog.setseed(double precision) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setseed(double precision) is 'set random seed';

alter function pg_catalog.setseed(double precision) owner to "kim-uijin";

create function pg_catalog.asin(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asin(double precision) is 'arcsine';

alter function pg_catalog.asin(double precision) owner to "kim-uijin";

create function pg_catalog.acos(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acos(double precision) is 'arccosine';

alter function pg_catalog.acos(double precision) owner to "kim-uijin";

create function pg_catalog.atan(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan(double precision) is 'arctangent';

alter function pg_catalog.atan(double precision) owner to "kim-uijin";

create function pg_catalog.atan2(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2(double precision, double precision) is 'arctangent, two arguments';

alter function pg_catalog.atan2(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.sin(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sin(double precision) is 'sine';

alter function pg_catalog.sin(double precision) owner to "kim-uijin";

create function pg_catalog.cos(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cos(double precision) is 'cosine';

alter function pg_catalog.cos(double precision) owner to "kim-uijin";

create function pg_catalog.tan(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tan(double precision) is 'tangent';

alter function pg_catalog.tan(double precision) owner to "kim-uijin";

create function pg_catalog.cot(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cot(double precision) is 'cotangent';

alter function pg_catalog.cot(double precision) owner to "kim-uijin";

create function pg_catalog.degrees(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.degrees(double precision) is 'radians to degrees';

alter function pg_catalog.degrees(double precision) owner to "kim-uijin";

create function pg_catalog.radians(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.radians(double precision) is 'degrees to radians';

alter function pg_catalog.radians(double precision) owner to "kim-uijin";

create function pg_catalog.pi() returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pi() is 'PI';

alter function pg_catalog.pi() owner to "kim-uijin";

create function pg_catalog.interval_mul(interval, double precision) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_mul(interval, double precision) is 'implementation of * operator';

alter function pg_catalog.interval_mul(interval, double precision) owner to "kim-uijin";

create function pg_catalog.pg_typeof("any") returns regtype
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_typeof("any") is 'type of the argument';

alter function pg_catalog.pg_typeof("any") owner to "kim-uijin";

create function pg_catalog.ascii(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ascii(text) is 'convert first char to int4';

alter function pg_catalog.ascii(text) owner to "kim-uijin";

create function pg_catalog.chr(integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.chr(integer) is 'convert int4 to char';

alter function pg_catalog.chr(integer) owner to "kim-uijin";

create function pg_catalog.repeat(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.repeat(text, integer) is 'replicate string n times';

alter function pg_catalog.repeat(text, integer) owner to "kim-uijin";

create function pg_catalog.similar_escape(text, text) returns text
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_escape(text, text) is 'convert SQL regexp pattern to POSIX style';

alter function pg_catalog.similar_escape(text, text) owner to "kim-uijin";

create function pg_catalog.mul_d_interval(double precision, interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mul_d_interval(double precision, interval) is 'implementation of * operator';

alter function pg_catalog.mul_d_interval(double precision, interval) owner to "kim-uijin";

create function pg_catalog.bpcharlike(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharlike(char, text) is 'implementation of ~~ operator';

alter function pg_catalog.bpcharlike(char, text) owner to "kim-uijin";

create function pg_catalog.bpcharnlike(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharnlike(char, text) is 'implementation of !~~ operator';

alter function pg_catalog.bpcharnlike(char, text) owner to "kim-uijin";

create function pg_catalog.texticlike(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticlike(text, text) is 'implementation of ~~* operator';

alter function pg_catalog.texticlike(text, text) owner to "kim-uijin";

create function pg_catalog.texticnlike(text, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.texticnlike(text, text) is 'implementation of !~~* operator';

alter function pg_catalog.texticnlike(text, text) owner to "kim-uijin";

create function pg_catalog.nameiclike(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameiclike(name, text) is 'implementation of ~~* operator';

alter function pg_catalog.nameiclike(name, text) owner to "kim-uijin";

create function pg_catalog.nameicnlike(name, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nameicnlike(name, text) is 'implementation of !~~* operator';

alter function pg_catalog.nameicnlike(name, text) owner to "kim-uijin";

create function pg_catalog.like_escape(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(text, text) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(text, text) owner to "kim-uijin";

create function pg_catalog.oidgt(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidgt(oid, oid) is 'implementation of > operator';

alter function pg_catalog.oidgt(oid, oid) owner to "kim-uijin";

create function pg_catalog.oidge(oid, oid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidge(oid, oid) is 'implementation of >= operator';

alter function pg_catalog.oidge(oid, oid) owner to "kim-uijin";

create function pg_catalog.pg_get_viewdef(text) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(text) owner to "kim-uijin";

create function pg_catalog.pg_get_viewdef(oid) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid) is 'select statement of a view';

alter function pg_catalog.pg_get_viewdef(oid) owner to "kim-uijin";

create function pg_catalog.pg_get_userbyid(oid) returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_userbyid(oid) is 'role name by OID (with fallback)';

alter function pg_catalog.pg_get_userbyid(oid) owner to "kim-uijin";

create function pg_catalog.pg_get_indexdef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(oid) is 'index description';

alter function pg_catalog.pg_get_indexdef(oid) owner to "kim-uijin";

create function pg_catalog."RI_FKey_check_ins"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_ins"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_ins"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_check_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_check_upd"() is 'referential integrity FOREIGN KEY ... REFERENCES';

alter function pg_catalog."RI_FKey_check_upd"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_cascade_del"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_del"() is 'referential integrity ON DELETE CASCADE';

alter function pg_catalog."RI_FKey_cascade_del"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_cascade_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_cascade_upd"() is 'referential integrity ON UPDATE CASCADE';

alter function pg_catalog."RI_FKey_cascade_upd"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_restrict_del"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_del"() is 'referential integrity ON DELETE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_del"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_restrict_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_restrict_upd"() is 'referential integrity ON UPDATE RESTRICT';

alter function pg_catalog."RI_FKey_restrict_upd"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_setnull_del"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_del"() is 'referential integrity ON DELETE SET NULL';

alter function pg_catalog."RI_FKey_setnull_del"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_setnull_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setnull_upd"() is 'referential integrity ON UPDATE SET NULL';

alter function pg_catalog."RI_FKey_setnull_upd"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_setdefault_del"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_del"() is 'referential integrity ON DELETE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_del"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_setdefault_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_setdefault_upd"() is 'referential integrity ON UPDATE SET DEFAULT';

alter function pg_catalog."RI_FKey_setdefault_upd"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_noaction_del"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_del"() is 'referential integrity ON DELETE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_del"() owner to "kim-uijin";

create function pg_catalog."RI_FKey_noaction_upd"() returns trigger
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."RI_FKey_noaction_upd"() is 'referential integrity ON UPDATE NO ACTION';

alter function pg_catalog."RI_FKey_noaction_upd"() owner to "kim-uijin";

create function pg_catalog.bpcharicregexeq(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexeq(char, text) is 'implementation of ~* operator';

alter function pg_catalog.bpcharicregexeq(char, text) owner to "kim-uijin";

create function pg_catalog.bpcharicregexne(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicregexne(char, text) is 'implementation of !~* operator';

alter function pg_catalog.bpcharicregexne(char, text) owner to "kim-uijin";

create function pg_catalog.bpcharregexeq(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexeq(char, text) is 'implementation of ~ operator';

alter function pg_catalog.bpcharregexeq(char, text) owner to "kim-uijin";

create function pg_catalog.bpcharregexne(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharregexne(char, text) is 'implementation of !~ operator';

alter function pg_catalog.bpcharregexne(char, text) owner to "kim-uijin";

create function pg_catalog.bpchariclike(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchariclike(char, text) is 'implementation of ~~* operator';

alter function pg_catalog.bpchariclike(char, text) owner to "kim-uijin";

create function pg_catalog.bpcharicnlike(char, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharicnlike(char, text) is 'implementation of !~~* operator';

alter function pg_catalog.bpcharicnlike(char, text) owner to "kim-uijin";

create function pg_catalog.pg_get_triggerdef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(oid) is 'trigger description';

alter function pg_catalog.pg_get_triggerdef(oid) owner to "kim-uijin";

create function pg_catalog.pg_get_serial_sequence(text, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_serial_sequence(text, text) is 'name of sequence for a serial column';

alter function pg_catalog.pg_get_serial_sequence(text, text) owner to "kim-uijin";

create function pg_catalog.varbiteq(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbiteq(bit varying, bit varying) is 'implementation of = operator';

alter function pg_catalog.varbiteq(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitne(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitne(bit varying, bit varying) is 'implementation of <> operator';

alter function pg_catalog.varbitne(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitge(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitge(bit varying, bit varying) is 'implementation of >= operator';

alter function pg_catalog.varbitge(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitgt(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitgt(bit varying, bit varying) is 'implementation of > operator';

alter function pg_catalog.varbitgt(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitle(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitle(bit varying, bit varying) is 'implementation of <= operator';

alter function pg_catalog.varbitle(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitlt(bit varying, bit varying) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitlt(bit varying, bit varying) is 'implementation of < operator';

alter function pg_catalog.varbitlt(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.varbitcmp(bit varying, bit varying) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbitcmp(bit varying, bit varying) is 'less-equal-greater';

alter function pg_catalog.varbitcmp(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.bitand(bit, bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitand(bit, bit) is 'implementation of & operator';

alter function pg_catalog.bitand(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitor(bit, bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitor(bit, bit) is 'implementation of | operator';

alter function pg_catalog.bitor(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitxor(bit, bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitxor(bit, bit) is 'implementation of # operator';

alter function pg_catalog.bitxor(bit, bit) owner to "kim-uijin";

create function pg_catalog.bitnot(bit) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitnot(bit) is 'implementation of ~ operator';

alter function pg_catalog.bitnot(bit) owner to "kim-uijin";

create function pg_catalog.bitshiftleft(bit, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftleft(bit, integer) is 'implementation of << operator';

alter function pg_catalog.bitshiftleft(bit, integer) owner to "kim-uijin";

create function pg_catalog.bitshiftright(bit, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitshiftright(bit, integer) is 'implementation of >> operator';

alter function pg_catalog.bitshiftright(bit, integer) owner to "kim-uijin";

create function pg_catalog.bitcat(bit varying, bit varying) returns bit varying
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bitcat(bit varying, bit varying) is 'implementation of || operator';

alter function pg_catalog.bitcat(bit varying, bit varying) owner to "kim-uijin";

create function pg_catalog.substring(bit, integer, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit, integer, integer) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer, integer) owner to "kim-uijin";

create function pg_catalog.length(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bit) is 'bitstring length';

alter function pg_catalog.length(bit) owner to "kim-uijin";

create function pg_catalog.octet_length(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.octet_length(bit) is 'octet length';

alter function pg_catalog.octet_length(bit) owner to "kim-uijin";

create function pg_catalog.bit(integer, integer, unknown) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(integer, integer, unknown) is 'convert int4 to bitstring';

alter function pg_catalog.bit(integer, integer, unknown) owner to "kim-uijin";

create function pg_catalog.int4(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(bit) is 'convert bitstring to int4';

alter function pg_catalog.int4(bit) owner to "kim-uijin";

create function pg_catalog.bit(bit, integer, boolean) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(bit, integer, boolean) is 'adjust bit() to typmod length';

alter function pg_catalog.bit(bit, integer, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_keywords(out word text, out catcode "char", out barelabel boolean, out catdesc text, out baredesc text) returns setof setof record
    stable
    strict
    parallel safe
    cost 10
    rows 500
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_keywords(out text, out "char", out boolean, out text, out text) is 'list of SQL keywords';

alter function pg_catalog.pg_get_keywords(out text, out "char", out boolean, out text, out text) owner to "kim-uijin";

create function pg_catalog.varbit(bit varying, integer, boolean) returns bit varying
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit(bit varying, integer, boolean) is 'adjust varbit() to typmod length';

alter function pg_catalog.varbit(bit varying, integer, boolean) owner to "kim-uijin";

create function pg_catalog.time_hash(time) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash(time) is 'hash';

alter function pg_catalog.time_hash(time) owner to "kim-uijin";

create function pg_catalog.aclexplode(acl aclitem[], out grantor oid, out grantee oid, out privilege_type text, out is_grantable boolean) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.aclexplode(aclitem[], out oid, out oid, out text, out boolean) is 'convert ACL item array to table, primarily for use by information schema';

alter function pg_catalog.aclexplode(aclitem[], out oid, out oid, out text, out boolean) owner to "kim-uijin";

create function pg_catalog.time_mi_time(time, time) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_time(time, time) is 'implementation of - operator';

alter function pg_catalog.time_mi_time(time, time) owner to "kim-uijin";

create function pg_catalog.boolle(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolle(boolean, boolean) is 'implementation of <= operator';

alter function pg_catalog.boolle(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.boolge(boolean, boolean) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolge(boolean, boolean) is 'implementation of >= operator';

alter function pg_catalog.boolge(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.btboolcmp(boolean, boolean) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btboolcmp(boolean, boolean) is 'less-equal-greater';

alter function pg_catalog.btboolcmp(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.timetz_hash(time with time zone) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash(time with time zone) is 'hash';

alter function pg_catalog.timetz_hash(time with time zone) owner to "kim-uijin";

create function pg_catalog.interval_hash(interval) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash(interval) is 'hash';

alter function pg_catalog.interval_hash(interval) owner to "kim-uijin";

create function pg_catalog.position(bit, bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bit, bit) is 'position of sub-bitstring';

alter function pg_catalog.position(bit, bit) owner to "kim-uijin";

create function pg_catalog.substring(bit, integer, unknown) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bit, integer, unknown) is 'extract portion of bitstring';

alter function pg_catalog.substring(bit, integer, unknown) owner to "kim-uijin";

create function pg_catalog.numeric_in(cstring, oid, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.numeric_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.numeric_out(numeric) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_out(numeric) is 'I/O';

alter function pg_catalog.numeric_out(numeric) owner to "kim-uijin";

create function pg_catalog.numeric(numeric, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(numeric, integer) is 'adjust numeric to typmod precision/scale';

alter function pg_catalog.numeric(numeric, integer) owner to "kim-uijin";

create function pg_catalog.numeric_abs(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_abs(numeric) is 'implementation of @ operator';

alter function pg_catalog.numeric_abs(numeric) owner to "kim-uijin";

create function pg_catalog.abs(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.abs(numeric) is 'absolute value';

alter function pg_catalog.abs(numeric) owner to "kim-uijin";

create function pg_catalog.sign(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(numeric) is 'sign of value';

alter function pg_catalog.sign(numeric) owner to "kim-uijin";

create function pg_catalog.round(numeric, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.round(numeric, integer) is 'value rounded to ''scale''';

alter function pg_catalog.round(numeric, integer) owner to "kim-uijin";

create function pg_catalog.round(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN round($1, 0);

comment on function pg_catalog.round(numeric, unknown) is 'value rounded to ''scale'' of zero';

alter function pg_catalog.round(numeric, unknown) owner to "kim-uijin";

create function pg_catalog.trunc(numeric, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(numeric, integer) is 'value truncated to ''scale''';

alter function pg_catalog.trunc(numeric, integer) owner to "kim-uijin";

create function pg_catalog.trunc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN trunc($1, 0);

comment on function pg_catalog.trunc(numeric) is 'value truncated to ''scale'' of zero';

alter function pg_catalog.trunc(numeric) owner to "kim-uijin";

create function pg_catalog.ceil(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(numeric) is 'nearest integer >= value';

alter function pg_catalog.ceil(numeric) owner to "kim-uijin";

create function pg_catalog.floor(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(numeric) is 'nearest integer <= value';

alter function pg_catalog.floor(numeric) owner to "kim-uijin";

create function pg_catalog.length(bytea, name) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bytea, name) is 'length of string in specified encoding';

alter function pg_catalog.length(bytea, name) owner to "kim-uijin";

create function pg_catalog.convert_from(bytea, name) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_from(bytea, name) is 'convert string with specified source encoding name';

alter function pg_catalog.convert_from(bytea, name) owner to "kim-uijin";

create function pg_catalog.cidr(inet) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr(inet) is 'convert inet to cidr';

alter function pg_catalog.cidr(inet) owner to "kim-uijin";

create function pg_catalog.pg_get_expr(pg_node_tree, oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid) is 'deparse an encoded expression';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid) owner to "kim-uijin";

create function pg_catalog.convert_to(text, name) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert_to(text, name) is 'convert string with specified destination encoding name';

alter function pg_catalog.convert_to(text, name) owner to "kim-uijin";

create function pg_catalog.numeric_eq(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_eq(numeric, numeric) is 'implementation of = operator';

alter function pg_catalog.numeric_eq(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_ne(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ne(numeric, numeric) is 'implementation of <> operator';

alter function pg_catalog.numeric_ne(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_gt(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_gt(numeric, numeric) is 'implementation of > operator';

alter function pg_catalog.numeric_gt(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_ge(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ge(numeric, numeric) is 'implementation of >= operator';

alter function pg_catalog.numeric_ge(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_lt(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_lt(numeric, numeric) is 'implementation of < operator';

alter function pg_catalog.numeric_lt(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_le(numeric, numeric) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_le(numeric, numeric) is 'implementation of <= operator';

alter function pg_catalog.numeric_le(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_add(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_add(numeric, numeric) is 'implementation of + operator';

alter function pg_catalog.numeric_add(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_sub(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sub(numeric, numeric) is 'implementation of - operator';

alter function pg_catalog.numeric_sub(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_mul(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mul(numeric, numeric) is 'implementation of * operator';

alter function pg_catalog.numeric_mul(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_div(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div(numeric, numeric) is 'implementation of / operator';

alter function pg_catalog.numeric_div(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.mod(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mod(numeric, numeric) is 'modulus';

alter function pg_catalog.mod(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_mod(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_mod(numeric, numeric) is 'implementation of % operator';

alter function pg_catalog.numeric_mod(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.sqrt(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sqrt(numeric) is 'square root';

alter function pg_catalog.sqrt(numeric) owner to "kim-uijin";

create function pg_catalog.numeric_sqrt(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sqrt(numeric) is 'square root';

alter function pg_catalog.numeric_sqrt(numeric) owner to "kim-uijin";

create function pg_catalog.exp(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.exp(numeric) is 'natural exponential (e^x)';

alter function pg_catalog.exp(numeric) owner to "kim-uijin";

create function pg_catalog.numeric_exp(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_exp(numeric) is 'natural exponential (e^x)';

alter function pg_catalog.numeric_exp(numeric) owner to "kim-uijin";

create function pg_catalog.ln(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ln(numeric) is 'natural logarithm';

alter function pg_catalog.ln(numeric) owner to "kim-uijin";

create function pg_catalog.numeric_ln(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_ln(numeric) is 'natural logarithm';

alter function pg_catalog.numeric_ln(numeric) owner to "kim-uijin";

create function pg_catalog.log(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.log(numeric, numeric) is 'logarithm base m of n';

alter function pg_catalog.log(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_log(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_log(numeric, numeric) is 'logarithm base m of n';

alter function pg_catalog.numeric_log(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.pow(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pow(numeric, numeric) is 'exponentiation';

alter function pg_catalog.pow(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_power(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_power(numeric, numeric) is 'implementation of ^ operator';

alter function pg_catalog.numeric_power(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric(integer) returns numeric
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(integer) is 'convert int4 to numeric';

alter function pg_catalog.numeric(integer) owner to "kim-uijin";

create function pg_catalog.log(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN log((10)::numeric, $1);

comment on function pg_catalog.log(numeric) is 'base 10 logarithm';

alter function pg_catalog.log(numeric) owner to "kim-uijin";

create function pg_catalog.numeric(real) returns numeric
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(real) is 'convert float4 to numeric';

alter function pg_catalog.numeric(real) owner to "kim-uijin";

create function pg_catalog.numeric(double precision) returns numeric
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(double precision) is 'convert float8 to numeric';

alter function pg_catalog.numeric(double precision) owner to "kim-uijin";

create function pg_catalog.int4(numeric) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(numeric) is 'convert numeric to int4';

alter function pg_catalog.int4(numeric) owner to "kim-uijin";

create function pg_catalog.float4(numeric) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(numeric) is 'convert numeric to float4';

alter function pg_catalog.float4(numeric) owner to "kim-uijin";

create function pg_catalog.float8(numeric) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(numeric) is 'convert numeric to float8';

alter function pg_catalog.float8(numeric) owner to "kim-uijin";

create function pg_catalog.time_pl_interval(time, interval) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_pl_interval(time, interval) is 'implementation of + operator';

alter function pg_catalog.time_pl_interval(time, interval) owner to "kim-uijin";

create function pg_catalog.time_mi_interval(time, interval) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_mi_interval(time, interval) is 'implementation of - operator';

alter function pg_catalog.time_mi_interval(time, interval) owner to "kim-uijin";

create function pg_catalog.timetz_pl_interval(time with time zone, interval) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_pl_interval(time with time zone, interval) is 'implementation of + operator';

alter function pg_catalog.timetz_pl_interval(time with time zone, interval) owner to "kim-uijin";

create function pg_catalog.timetz_mi_interval(time with time zone, interval) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_mi_interval(time with time zone, interval) is 'implementation of - operator';

alter function pg_catalog.timetz_mi_interval(time with time zone, interval) owner to "kim-uijin";

create function pg_catalog.numeric_inc(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_inc(numeric) is 'increment by one';

alter function pg_catalog.numeric_inc(numeric) owner to "kim-uijin";

create function pg_catalog.setval(regclass, bigint, boolean) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setval(regclass, bigint, boolean) is 'set sequence value and is_called status';

alter function pg_catalog.setval(regclass, bigint, boolean) owner to "kim-uijin";

create function pg_catalog.numeric_smaller(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_smaller(numeric, numeric) is 'smaller of two';

alter function pg_catalog.numeric_smaller(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_larger(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_larger(numeric, numeric) is 'larger of two';

alter function pg_catalog.numeric_larger(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.to_char(interval, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(interval, text) is 'format interval to text';

alter function pg_catalog.to_char(interval, text) owner to "kim-uijin";

create function pg_catalog.numeric_cmp(numeric, numeric) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_cmp(numeric, numeric) is 'less-equal-greater';

alter function pg_catalog.numeric_cmp(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.to_char(timestamp with time zone, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp with time zone, text) is 'format timestamp with time zone to text';

alter function pg_catalog.to_char(timestamp with time zone, text) owner to "kim-uijin";

create function pg_catalog.numeric_uminus(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uminus(numeric) is 'implementation of - operator';

alter function pg_catalog.numeric_uminus(numeric) owner to "kim-uijin";

create function pg_catalog.to_char(numeric, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(numeric, text) is 'format numeric to text';

alter function pg_catalog.to_char(numeric, text) owner to "kim-uijin";

create function pg_catalog.to_char(integer, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(integer, text) is 'format int4 to text';

alter function pg_catalog.to_char(integer, text) owner to "kim-uijin";

create function pg_catalog.to_char(bigint, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(bigint, text) is 'format int8 to text';

alter function pg_catalog.to_char(bigint, text) owner to "kim-uijin";

create function pg_catalog.to_char(real, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(real, text) is 'format float4 to text';

alter function pg_catalog.to_char(real, text) owner to "kim-uijin";

create function pg_catalog.to_char(double precision, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(double precision, text) is 'format float8 to text';

alter function pg_catalog.to_char(double precision, text) owner to "kim-uijin";

create function pg_catalog.to_number(text, text) returns numeric
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_number(text, text) is 'convert text to numeric';

alter function pg_catalog.to_number(text, text) owner to "kim-uijin";

create function pg_catalog.to_timestamp(text, text) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_timestamp(text, text) is 'convert text to timestamp with time zone';

alter function pg_catalog.to_timestamp(text, text) owner to "kim-uijin";

create function pg_catalog.int8(numeric) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(numeric) is 'convert numeric to int8';

alter function pg_catalog.int8(numeric) owner to "kim-uijin";

create function pg_catalog.to_date(text, text) returns date
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_date(text, text) is 'convert text to date';

alter function pg_catalog.to_date(text, text) owner to "kim-uijin";

create function pg_catalog.numeric(bigint) returns numeric
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(bigint) is 'convert int8 to numeric';

alter function pg_catalog.numeric(bigint) owner to "kim-uijin";

create function pg_catalog.numeric(smallint) returns numeric
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(smallint) is 'convert int2 to numeric';

alter function pg_catalog.numeric(smallint) owner to "kim-uijin";

create function pg_catalog.int2(numeric) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(numeric) is 'convert numeric to int2';

alter function pg_catalog.int2(numeric) owner to "kim-uijin";

create function pg_catalog.oidin(cstring) returns oid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidin(cstring) is 'I/O';

alter function pg_catalog.oidin(cstring) owner to "kim-uijin";

create function pg_catalog.oidout(oid) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidout(oid) is 'I/O';

alter function pg_catalog.oidout(oid) owner to "kim-uijin";

create function pg_catalog.bit_length(bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN (octet_length($1) * 8);

comment on function pg_catalog.bit_length(bytea) is 'length in bits';

alter function pg_catalog.bit_length(bytea) owner to "kim-uijin";

create function pg_catalog.bit_length(text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN (octet_length($1) * 8);

comment on function pg_catalog.bit_length(text) is 'length in bits';

alter function pg_catalog.bit_length(text) owner to "kim-uijin";

create function pg_catalog.bit_length(bit) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN length($1);

comment on function pg_catalog.bit_length(bit) is 'length in bits';

alter function pg_catalog.bit_length(bit) owner to "kim-uijin";

create function pg_catalog.convert(bytea, name, name) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.convert(bytea, name, name) is 'convert string with specified encoding names';

alter function pg_catalog.convert(bytea, name, name) owner to "kim-uijin";

create function pg_catalog.iclikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikesel(internal, oid, internal, integer) is 'restriction selectivity of ILIKE';

alter function pg_catalog.iclikesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.icnlikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT ILIKE';

alter function pg_catalog.icnlikesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of ILIKE';

alter function pg_catalog.iclikejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT ILIKE';

alter function pg_catalog.icnlikejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.regexeqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqsel(internal, oid, internal, integer) is 'restriction selectivity of regex match';

alter function pg_catalog.regexeqsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.likesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likesel(internal, oid, internal, integer) is 'restriction selectivity of LIKE';

alter function pg_catalog.likesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.icregexeqsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqsel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.regexnesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnesel(internal, oid, internal, integer) is 'restriction selectivity of regex non-match';

alter function pg_catalog.regexnesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.nlikesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikesel(internal, oid, internal, integer) is 'restriction selectivity of NOT LIKE';

alter function pg_catalog.nlikesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.icregexnesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnesel(internal, oid, internal, integer) is 'restriction selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex match';

alter function pg_catalog.regexeqjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of LIKE';

alter function pg_catalog.likejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex match';

alter function pg_catalog.icregexeqjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of regex non-match';

alter function pg_catalog.regexnejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of NOT LIKE';

alter function pg_catalog.nlikejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of case-insensitive regex non-match';

alter function pg_catalog.icregexnejoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.float8_avg(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_avg(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_avg(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_var_samp(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_var_samp(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_stddev_samp(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_stddev_samp(double precision[]) owner to "kim-uijin";

create function pg_catalog.numeric_accum(internal, numeric) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_accum(internal, numeric) owner to "kim-uijin";

create function pg_catalog.int2_accum(internal, smallint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum(internal, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_accum(internal, smallint) owner to "kim-uijin";

create function pg_catalog.int4_accum(internal, integer) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum(internal, integer) is 'aggregate transition function';

alter function pg_catalog.int4_accum(internal, integer) owner to "kim-uijin";

create function pg_catalog.int8_accum(internal, bigint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_accum(internal, bigint) owner to "kim-uijin";

create function pg_catalog.numeric_avg(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg(internal) is 'aggregate final function';

alter function pg_catalog.numeric_avg(internal) owner to "kim-uijin";

create function pg_catalog.numeric_var_samp(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_var_samp(internal) owner to "kim-uijin";

create function pg_catalog.numeric_stddev_samp(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_stddev_samp(internal) owner to "kim-uijin";

create function pg_catalog.int2_sum(bigint, smallint) returns bigint
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_sum(bigint, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_sum(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int4_sum(bigint, integer) returns bigint
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_sum(bigint, integer) is 'aggregate transition function';

alter function pg_catalog.int4_sum(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int8_sum(numeric, bigint) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_sum(numeric, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_sum(numeric, bigint) owner to "kim-uijin";

create function pg_catalog.interval_accum(interval[], interval) returns interval[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum(interval[], interval) is 'aggregate transition function';

alter function pg_catalog.interval_accum(interval[], interval) owner to "kim-uijin";

create function pg_catalog.interval_avg(interval[]) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_avg(interval[]) is 'aggregate final function';

alter function pg_catalog.interval_avg(interval[]) owner to "kim-uijin";

create function pg_catalog.to_ascii(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text) is 'encode text from DB encoding to ASCII text';

alter function pg_catalog.to_ascii(text) owner to "kim-uijin";

create function pg_catalog.to_ascii(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text, integer) is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, integer) owner to "kim-uijin";

create function pg_catalog.to_ascii(text, name) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_ascii(text, name) is 'encode text from encoding to ASCII text';

alter function pg_catalog.to_ascii(text, name) owner to "kim-uijin";

create function pg_catalog.interval_pl_time(interval, time without time zone) returns time without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.interval_pl_time(interval, time) is 'implementation of + operator';

alter function pg_catalog.interval_pl_time(interval, time) owner to "kim-uijin";

create function pg_catalog.int28eq(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28eq(smallint, bigint) is 'implementation of = operator';

alter function pg_catalog.int28eq(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28ne(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ne(smallint, bigint) is 'implementation of <> operator';

alter function pg_catalog.int28ne(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28lt(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28lt(smallint, bigint) is 'implementation of < operator';

alter function pg_catalog.int28lt(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28gt(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28gt(smallint, bigint) is 'implementation of > operator';

alter function pg_catalog.int28gt(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28le(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28le(smallint, bigint) is 'implementation of <= operator';

alter function pg_catalog.int28le(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int28ge(smallint, bigint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int28ge(smallint, bigint) is 'implementation of >= operator';

alter function pg_catalog.int28ge(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.int82eq(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82eq(bigint, smallint) is 'implementation of = operator';

alter function pg_catalog.int82eq(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82ne(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ne(bigint, smallint) is 'implementation of <> operator';

alter function pg_catalog.int82ne(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82lt(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82lt(bigint, smallint) is 'implementation of < operator';

alter function pg_catalog.int82lt(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82gt(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82gt(bigint, smallint) is 'implementation of > operator';

alter function pg_catalog.int82gt(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82le(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82le(bigint, smallint) is 'implementation of <= operator';

alter function pg_catalog.int82le(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int82ge(bigint, smallint) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int82ge(bigint, smallint) is 'implementation of >= operator';

alter function pg_catalog.int82ge(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.int2and(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2and(smallint, smallint) is 'implementation of & operator';

alter function pg_catalog.int2and(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2or(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2or(smallint, smallint) is 'implementation of | operator';

alter function pg_catalog.int2or(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2xor(smallint, smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2xor(smallint, smallint) is 'implementation of # operator';

alter function pg_catalog.int2xor(smallint, smallint) owner to "kim-uijin";

create function pg_catalog.int2not(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2not(smallint) is 'implementation of ~ operator';

alter function pg_catalog.int2not(smallint) owner to "kim-uijin";

create function pg_catalog.int2shl(smallint, integer) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shl(smallint, integer) is 'implementation of << operator';

alter function pg_catalog.int2shl(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int2shr(smallint, integer) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2shr(smallint, integer) is 'implementation of >> operator';

alter function pg_catalog.int2shr(smallint, integer) owner to "kim-uijin";

create function pg_catalog.int4and(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4and(integer, integer) is 'implementation of & operator';

alter function pg_catalog.int4and(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4or(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4or(integer, integer) is 'implementation of | operator';

alter function pg_catalog.int4or(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4xor(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4xor(integer, integer) is 'implementation of # operator';

alter function pg_catalog.int4xor(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4not(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4not(integer) is 'implementation of ~ operator';

alter function pg_catalog.int4not(integer) owner to "kim-uijin";

create function pg_catalog.int4shl(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shl(integer, integer) is 'implementation of << operator';

alter function pg_catalog.int4shl(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4shr(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4shr(integer, integer) is 'implementation of >> operator';

alter function pg_catalog.int4shr(integer, integer) owner to "kim-uijin";

create function pg_catalog.int8and(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8and(bigint, bigint) is 'implementation of & operator';

alter function pg_catalog.int8and(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8or(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8or(bigint, bigint) is 'implementation of | operator';

alter function pg_catalog.int8or(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8xor(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8xor(bigint, bigint) is 'implementation of # operator';

alter function pg_catalog.int8xor(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8not(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8not(bigint) is 'implementation of ~ operator';

alter function pg_catalog.int8not(bigint) owner to "kim-uijin";

create function pg_catalog.int8shl(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shl(bigint, integer) is 'implementation of << operator';

alter function pg_catalog.int8shl(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int8shr(bigint, integer) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8shr(bigint, integer) is 'implementation of >> operator';

alter function pg_catalog.int8shr(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int8up(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8up(bigint) is 'implementation of + operator';

alter function pg_catalog.int8up(bigint) owner to "kim-uijin";

create function pg_catalog.int2up(smallint) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2up(smallint) is 'implementation of + operator';

alter function pg_catalog.int2up(smallint) owner to "kim-uijin";

create function pg_catalog.int4up(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4up(integer) is 'implementation of + operator';

alter function pg_catalog.int4up(integer) owner to "kim-uijin";

create function pg_catalog.float4up(real) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4up(real) is 'implementation of + operator';

alter function pg_catalog.float4up(real) owner to "kim-uijin";

create function pg_catalog.float8up(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8up(double precision) is 'implementation of + operator';

alter function pg_catalog.float8up(double precision) owner to "kim-uijin";

create function pg_catalog.numeric_uplus(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_uplus(numeric) is 'implementation of + operator';

alter function pg_catalog.numeric_uplus(numeric) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, text, text) is 'user privilege on relation by username, rel name';

alter function pg_catalog.has_table_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(name, oid, text) is 'user privilege on relation by username, rel oid';

alter function pg_catalog.has_table_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, text, text) is 'user privilege on relation by user oid, rel name';

alter function pg_catalog.has_table_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, oid, text) is 'user privilege on relation by user oid, rel oid';

alter function pg_catalog.has_table_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(text, text, unknown) is 'current user privilege on relation by rel name';

alter function pg_catalog.has_table_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_table_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_table_privilege(oid, text, unknown) is 'current user privilege on relation by rel oid';

alter function pg_catalog.has_table_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_numscans(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_numscans(oid) is 'statistics: number of scans done for table/index';

alter function pg_catalog.pg_stat_get_numscans(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_returned(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_returned(oid) is 'statistics: number of tuples read by seqscan';

alter function pg_catalog.pg_stat_get_tuples_returned(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_fetched(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan';

alter function pg_catalog.pg_stat_get_tuples_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_inserted(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_inserted(oid) is 'statistics: number of tuples inserted';

alter function pg_catalog.pg_stat_get_tuples_inserted(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_updated(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_updated(oid) is 'statistics: number of tuples updated';

alter function pg_catalog.pg_stat_get_tuples_updated(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_deleted(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_deleted(oid) is 'statistics: number of tuples deleted';

alter function pg_catalog.pg_stat_get_tuples_deleted(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_blocks_fetched(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_fetched(oid) is 'statistics: number of blocks fetched';

alter function pg_catalog.pg_stat_get_blocks_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_blocks_hit(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_blocks_hit(oid) is 'statistics: number of blocks found in cache';

alter function pg_catalog.pg_stat_get_blocks_hit(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_idset() returns setof setof integer
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_backend_idset() is 'statistics: currently active backend IDs';

alter function pg_catalog.pg_stat_get_backend_idset() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_pid(integer) returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_pid(integer) is 'statistics: PID of backend';

alter function pg_catalog.pg_stat_get_backend_pid(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_dbid(integer) returns oid
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_dbid(integer) is 'statistics: database ID of backend';

alter function pg_catalog.pg_stat_get_backend_dbid(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_userid(integer) returns oid
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_userid(integer) is 'statistics: user ID of backend';

alter function pg_catalog.pg_stat_get_backend_userid(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_activity(integer) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity(integer) is 'statistics: current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity(integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_numbackends(oid) returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_numbackends(oid) is 'statistics: number of backends in database';

alter function pg_catalog.pg_stat_get_db_numbackends(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_xact_commit(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_commit(oid) is 'statistics: transactions committed';

alter function pg_catalog.pg_stat_get_db_xact_commit(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_xact_rollback(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_xact_rollback(oid) is 'statistics: transactions rolled back';

alter function pg_catalog.pg_stat_get_db_xact_rollback(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_blocks_fetched(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_fetched(oid) is 'statistics: blocks fetched for database';

alter function pg_catalog.pg_stat_get_db_blocks_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_blocks_hit(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blocks_hit(oid) is 'statistics: blocks found in cache for database';

alter function pg_catalog.pg_stat_get_db_blocks_hit(oid) owner to "kim-uijin";

create function pg_catalog.encode(bytea, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.encode(bytea, text) is 'convert bytea value into some ascii-only text string';

alter function pg_catalog.encode(bytea, text) owner to "kim-uijin";

create function pg_catalog.decode(text, text) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.decode(text, text) is 'convert ascii-encoded text string into bytea value';

alter function pg_catalog.decode(text, text) owner to "kim-uijin";

create function pg_catalog.byteaeq(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteaeq(bytea, bytea) is 'implementation of = operator';

alter function pg_catalog.byteaeq(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.bytealt(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealt(bytea, bytea) is 'implementation of < operator';

alter function pg_catalog.bytealt(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteale(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteale(bytea, bytea) is 'implementation of <= operator';

alter function pg_catalog.byteale(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteagt(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteagt(bytea, bytea) is 'implementation of > operator';

alter function pg_catalog.byteagt(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteage(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteage(bytea, bytea) is 'implementation of >= operator';

alter function pg_catalog.byteage(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteane(bytea, bytea) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteane(bytea, bytea) is 'implementation of <> operator';

alter function pg_catalog.byteane(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteacmp(bytea, bytea) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacmp(bytea, bytea) is 'less-equal-greater';

alter function pg_catalog.byteacmp(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.timestamp(timestamp, integer) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(timestamp, integer) is 'adjust timestamp precision';

alter function pg_catalog.timestamp(timestamp, integer) owner to "kim-uijin";

create function pg_catalog.int2_avg_accum(bigint[], smallint) returns bigint[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum(bigint[], smallint) is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum(bigint[], smallint) owner to "kim-uijin";

create function pg_catalog.int4_avg_accum(bigint[], integer) returns bigint[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum(bigint[], integer) is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum(bigint[], integer) owner to "kim-uijin";

create function pg_catalog.int8_avg(bigint[]) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg(bigint[]) is 'aggregate final function';

alter function pg_catalog.int8_avg(bigint[]) owner to "kim-uijin";

create function pg_catalog.oidlarger(oid, oid) returns oid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidlarger(oid, oid) is 'larger of two';

alter function pg_catalog.oidlarger(oid, oid) owner to "kim-uijin";

create function pg_catalog.oidsmaller(oid, oid) returns oid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsmaller(oid, oid) is 'smaller of two';

alter function pg_catalog.oidsmaller(oid, oid) owner to "kim-uijin";

create function pg_catalog.timestamptz(timestamp with time zone, integer) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(timestamp with time zone, integer) is 'adjust timestamptz precision';

alter function pg_catalog.timestamptz(timestamp with time zone, integer) owner to "kim-uijin";

create function pg_catalog.time(time, integer) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time, integer) is 'adjust time precision';

alter function pg_catalog.time(time, integer) owner to "kim-uijin";

create function pg_catalog.timetz(time with time zone, integer) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time with time zone, integer) is 'adjust time with time zone precision';

alter function pg_catalog.timetz(time with time zone, integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_tuples_hot_updated(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated';

alter function pg_catalog.pg_stat_get_tuples_hot_updated(oid) owner to "kim-uijin";

create function pg_catalog.div(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.div(numeric, numeric) is 'trunc(x/y)';

alter function pg_catalog.div(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_div_trunc(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_div_trunc(numeric, numeric) is 'trunc(x/y)';

alter function pg_catalog.numeric_div_trunc(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.similar_to_escape(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(text, text) is 'convert SQL regexp pattern to POSIX style';

alter function pg_catalog.similar_to_escape(text, text) owner to "kim-uijin";

create function pg_catalog.similar_to_escape(text, unknown) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.similar_to_escape(text, unknown) is 'convert SQL regexp pattern to POSIX style';

alter function pg_catalog.similar_to_escape(text, unknown) owner to "kim-uijin";

create function pg_catalog.shobj_description(oid, name) returns text
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT pg_shdescription.description
FROM pg_shdescription
WHERE ((pg_shdescription.objoid = $1) AND (pg_shdescription.classoid = ( SELECT pg_class.oid
                                                                         FROM pg_class
                                                                         WHERE ((pg_class.relname = $2) AND (pg_class.relnamespace = ('pg_catalog'::regnamespace)::oid)))));
END;

comment on function pg_catalog.shobj_description(oid, name) is 'get description for object id and shared catalog name';

alter function pg_catalog.shobj_description(oid, name) owner to "kim-uijin";

create function pg_catalog.textanycat(text, anynonarray) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$select $1 operator(pg_catalog.||) $2::pg_catalog.text$$;

comment on function pg_catalog.textanycat(text, anynonarray) is 'implementation of || operator';

alter function pg_catalog.textanycat(text, anynonarray) owner to "kim-uijin";

create function pg_catalog.anytextcat(anynonarray, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language sql
as
$$select $1::pg_catalog.text operator(pg_catalog.||) $2$$;

comment on function pg_catalog.anytextcat(anynonarray, text) is 'implementation of || operator';

alter function pg_catalog.anytextcat(anynonarray, text) owner to "kim-uijin";

create function pg_catalog.bytealike(bytea, bytea) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytealike(bytea, bytea) is 'implementation of ~~ operator';

alter function pg_catalog.bytealike(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.byteanlike(bytea, bytea) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteanlike(bytea, bytea) is 'implementation of !~~ operator';

alter function pg_catalog.byteanlike(bytea, bytea) owner to "kim-uijin";

create function pg_catalog."like"(bytea, bytea) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."like"(bytea, bytea) is 'matches LIKE expression';

alter function pg_catalog."like"(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.notlike(bytea, bytea) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.notlike(bytea, bytea) is 'does not match LIKE expression';

alter function pg_catalog.notlike(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.like_escape(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.like_escape(bytea, bytea) is 'convert LIKE pattern to use backslash escapes';

alter function pg_catalog.like_escape(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.length(bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(bytea) is 'octet length';

alter function pg_catalog.length(bytea) owner to "kim-uijin";

create function pg_catalog.byteacat(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteacat(bytea, bytea) is 'implementation of || operator';

alter function pg_catalog.byteacat(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.substring(bytea, integer, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea, integer, integer) is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer, integer) owner to "kim-uijin";

create function pg_catalog.substring(bytea, integer, unknown) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(bytea, integer, unknown) is 'extract portion of string';

alter function pg_catalog.substring(bytea, integer, unknown) owner to "kim-uijin";

create function pg_catalog.position(bytea, bytea) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.position(bytea, bytea) is 'position of substring';

alter function pg_catalog.position(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.btrim(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrim(bytea, bytea) is 'trim selected bytes from both ends of string';

alter function pg_catalog.btrim(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.time(timestamp with time zone) returns time
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(timestamp with time zone) is 'convert timestamp with time zone to time';

alter function pg_catalog.time(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_trunc(text, timestamp, unknown) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_trunc(text, timestamp, unknown) is 'truncate timestamp to specified units';

alter function pg_catalog.date_trunc(text, timestamp, unknown) owner to "kim-uijin";

create function pg_catalog.date_part(text, timestamp) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_part(text, timestamp) is 'extract field from timestamp';

alter function pg_catalog.date_part(text, timestamp) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_activity(pid integer, out datid oid, out pid integer, out usesysid oid, out application_name text, out state text, out query text, out wait_event_type text, out wait_event text, out xact_start timestamp with time zone, out query_start timestamp with time zone, out backend_start timestamp with time zone, out state_change timestamp with time zone, out client_addr inet, out client_hostname text, out client_port integer, out backend_xid xid, out backend_xmin xid, out backend_type text, out ssl boolean, out sslversion text, out sslcipher text, out sslbits integer, out ssl_client_dn text, out ssl_client_serial numeric, out ssl_issuer_dn text, out gss_auth boolean, out gss_princ text, out gss_enc boolean, out leader_pid integer, out query_id bigint) returns setof setof record
    stable
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out text, out boolean, out text, out text, out integer, out text, out numeric, out text, out boolean, out text, out boolean, out integer, out bigint) is 'statistics: information about currently active backends';

alter function pg_catalog.pg_stat_get_activity(integer, out oid, out integer, out oid, out text, out text, out text, out text, out text, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out inet, out text, out integer, out xid, out xid, out text, out boolean, out text, out text, out integer, out text, out numeric, out text, out boolean, out text, out boolean, out integer, out bigint) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query_first_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query first item with timezone';

alter function pg_catalog.jsonb_path_query_first_tz(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.timestamp(date, unknown) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(date, unknown) is 'convert date to timestamp';

alter function pg_catalog.timestamp(date, unknown) owner to "kim-uijin";

create function pg_catalog.timestamp(date, time) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(date, time) is 'convert date and time to timestamp';

alter function pg_catalog.timestamp(date, time) owner to "kim-uijin";

create function pg_catalog.pg_backend_pid() returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backend_pid() is 'statistics: current backend PID';

alter function pg_catalog.pg_backend_pid() owner to "kim-uijin";

create function pg_catalog.timestamp(timestamp with time zone) returns timestamp
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp(timestamp with time zone) is 'convert timestamp with time zone to timestamp';

alter function pg_catalog.timestamp(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz(timestamp) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz(timestamp) is 'convert timestamp to timestamp with time zone';

alter function pg_catalog.timestamptz(timestamp) owner to "kim-uijin";

create function pg_catalog.date(timestamp) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date(timestamp) is 'convert timestamp to date';

alter function pg_catalog.date(timestamp) owner to "kim-uijin";

create function pg_catalog.jsonb_path_match_tz(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_tz(jsonb, jsonpath, jsonb, boolean) is 'jsonpath match with timezone';

alter function pg_catalog.jsonb_path_match_tz(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.timestamp_mi(timestamp, timestamp) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi(timestamp, timestamp) is 'implementation of - operator';

alter function pg_catalog.timestamp_mi(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_pl_interval(timestamp, interval) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_pl_interval(timestamp, interval) is 'implementation of + operator';

alter function pg_catalog.timestamp_pl_interval(timestamp, interval) owner to "kim-uijin";

create function pg_catalog.timestamp_mi_interval(timestamp, interval) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_mi_interval(timestamp, interval) is 'implementation of - operator';

alter function pg_catalog.timestamp_mi_interval(timestamp, interval) owner to "kim-uijin";

create function pg_catalog.pg_conf_load_time() returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conf_load_time() is 'configuration load time';

alter function pg_catalog.pg_conf_load_time() owner to "kim-uijin";

create function pg_catalog.timestamp_smaller(timestamp, timestamp) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_smaller(timestamp, timestamp) is 'smaller of two';

alter function pg_catalog.timestamp_smaller(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_larger(timestamp, timestamp) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_larger(timestamp, timestamp) is 'larger of two';

alter function pg_catalog.timestamp_larger(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timezone(text, time with time zone) returns time with time zone
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(text, time with time zone) owner to "kim-uijin";

create function pg_catalog.timezone(interval, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, time with time zone) is 'adjust time with time zone to new zone';

alter function pg_catalog.timezone(interval, time with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_hash(timestamp) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash(timestamp) is 'hash';

alter function pg_catalog.timestamp_hash(timestamp) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp with time zone, interval, timestamp with time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp without time zone, timestamp without time zone, timestamp without time zone, interval) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, $2) OVERLAPS ($3, ($3 + $4)));

comment on function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, timestamp, timestamp, interval) owner to "kim-uijin";

create function pg_catalog."overlaps"(timestamp without time zone, interval, timestamp without time zone, timestamp without time zone) returns boolean
    immutable
    parallel safe
    cost 1
    language sql
RETURN (($1, ($1 + $2)) OVERLAPS ($3, $4));

comment on function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) is 'intervals overlap?';

alter function pg_catalog."overlaps"(timestamp, interval, timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_cmp(timestamp, timestamp) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp(timestamp, timestamp) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.time(time with time zone) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time(time with time zone) is 'convert time with time zone to time';

alter function pg_catalog.time(time with time zone) owner to "kim-uijin";

create function pg_catalog.timetz(time) returns time with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz(time) is 'convert time to time with time zone';

alter function pg_catalog.timetz(time) owner to "kim-uijin";

create function pg_catalog.isfinite(timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isfinite(timestamp) is 'finite timestamp?';

alter function pg_catalog.isfinite(timestamp) owner to "kim-uijin";

create function pg_catalog.to_char(timestamp, text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_char(timestamp, text) is 'format timestamp to text';

alter function pg_catalog.to_char(timestamp, text) owner to "kim-uijin";

create function pg_catalog.timestamp_eq(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq(timestamp, timestamp) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_ne(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne(timestamp, timestamp) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_lt(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt(timestamp, timestamp) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_le(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le(timestamp, timestamp) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_ge(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge(timestamp, timestamp) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamp_gt(timestamp, timestamp) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt(timestamp, timestamp) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.age(timestamp, timestamp) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.age(timestamp, timestamp) is 'date difference preserving months and years';

alter function pg_catalog.age(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.age(timestamp without time zone) returns interval
    stable
    strict
    parallel safe
    cost 1
    language sql
RETURN age((CURRENT_DATE)::timestamp without time zone, $1);

comment on function pg_catalog.age(timestamp, unknown) is 'date difference from today preserving months and years';

alter function pg_catalog.age(timestamp, unknown) owner to "kim-uijin";

create function pg_catalog.timezone(text, timestamp) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(text, timestamp) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(text, timestamp) owner to "kim-uijin";

create function pg_catalog.timezone(interval, timestamp) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timezone(interval, timestamp) is 'adjust timestamp to new time zone';

alter function pg_catalog.timezone(interval, timestamp) owner to "kim-uijin";

create function pg_catalog.date_pl_interval(date, interval) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_pl_interval(date, interval) is 'implementation of + operator';

alter function pg_catalog.date_pl_interval(date, interval) owner to "kim-uijin";

create function pg_catalog.date_mi_interval(date, interval) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_mi_interval(date, interval) is 'implementation of - operator';

alter function pg_catalog.date_mi_interval(date, interval) owner to "kim-uijin";

create function pg_catalog.substring(text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substring(text, text) is 'extract text matching regular expression';

alter function pg_catalog.substring(text, text) owner to "kim-uijin";

create function pg_catalog.substring(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN "substring"($1, similar_to_escape($2, $3));

comment on function pg_catalog.substring(text, text, text) is 'extract text matching SQL regular expression';

alter function pg_catalog.substring(text, text, text) owner to "kim-uijin";

create function pg_catalog.bit(bigint, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit(bigint, integer) is 'convert int8 to bitstring';

alter function pg_catalog.bit(bigint, integer) owner to "kim-uijin";

create function pg_catalog.int8(bit) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(bit) is 'convert bitstring to int8';

alter function pg_catalog.int8(bit) owner to "kim-uijin";

create function pg_catalog.current_setting(text) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(text) is 'SHOW X as a function';

alter function pg_catalog.current_setting(text) owner to "kim-uijin";

create function pg_catalog.set_config(text, text, boolean) returns text
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_config(text, text, boolean) is 'SET X as a function';

alter function pg_catalog.set_config(text, text, boolean) owner to "kim-uijin";

create function pg_catalog.pg_table_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_is_visible(oid) is 'is table visible in search path?';

alter function pg_catalog.pg_table_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_type_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_type_is_visible(oid) is 'is type visible in search path?';

alter function pg_catalog.pg_type_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_function_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_function_is_visible(oid) is 'is function visible in search path?';

alter function pg_catalog.pg_function_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_operator_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_operator_is_visible(oid) is 'is operator visible in search path?';

alter function pg_catalog.pg_operator_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_opclass_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opclass_is_visible(oid) is 'is opclass visible in search path?';

alter function pg_catalog.pg_opclass_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_show_all_settings(out name text, out setting text, out unit text, out category text, out short_desc text, out extra_desc text, out context text, out vartype text, out source text, out min_val text, out max_val text, out enumvals text[], out boot_val text, out reset_val text, out sourcefile text, out sourceline integer, out pending_restart boolean) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text[], out text, out text, out text, out integer, out boolean) is 'SHOW ALL as a function';

alter function pg_catalog.pg_show_all_settings(out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text, out text[], out text, out text, out text, out integer, out boolean) owner to "kim-uijin";

create function pg_catalog.substr(bytea, integer, integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea, integer, integer) is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer, integer) owner to "kim-uijin";

create function pg_catalog.substr(bytea, integer, unknown) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.substr(bytea, integer, unknown) is 'extract portion of string';

alter function pg_catalog.substr(bytea, integer, unknown) owner to "kim-uijin";

create function pg_catalog.replace(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.replace(text, text, text) is 'replace all occurrences in string of old_substr with new_substr';

alter function pg_catalog.replace(text, text, text) owner to "kim-uijin";

create function pg_catalog.split_part(text, text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.split_part(text, text, integer) is 'split string by field_sep and return field_num';

alter function pg_catalog.split_part(text, text, integer) owner to "kim-uijin";

create function pg_catalog.to_hex(integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(integer) is 'convert int4 number to hex';

alter function pg_catalog.to_hex(integer) owner to "kim-uijin";

create function pg_catalog.to_hex(bigint) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_hex(bigint) is 'convert int8 number to hex';

alter function pg_catalog.to_hex(bigint) owner to "kim-uijin";

create function pg_catalog.array_lower(anyarray, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_lower(anyarray, integer) is 'array lower dimension';

alter function pg_catalog.array_lower(anyarray, integer) owner to "kim-uijin";

create function pg_catalog.array_upper(anyarray, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_upper(anyarray, integer) is 'array upper dimension';

alter function pg_catalog.array_upper(anyarray, integer) owner to "kim-uijin";

create function pg_catalog.pg_conversion_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_conversion_is_visible(oid) is 'is conversion visible in search path?';

alter function pg_catalog.pg_conversion_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_activity_start(integer) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_activity_start(integer) is 'statistics: start time for current query of backend';

alter function pg_catalog.pg_stat_get_backend_activity_start(integer) owner to "kim-uijin";

create function pg_catalog.pg_terminate_backend(pid integer, timeout bigint default 0) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_terminate_backend(integer, bigint) is 'terminate a server process';

alter function pg_catalog.pg_terminate_backend(integer, bigint) owner to "kim-uijin";

create function pg_catalog.pg_get_functiondef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_functiondef(oid) is 'definition of a function';

alter function pg_catalog.pg_get_functiondef(oid) owner to "kim-uijin";

create function pg_catalog.pg_column_compression("any") returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_compression("any") is 'compression method for the compressed datum';

alter function pg_catalog.pg_column_compression("any") owner to "kim-uijin";

create function pg_catalog.text_pattern_lt(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_lt(text, text) is 'implementation of ~<~ operator';

alter function pg_catalog.text_pattern_lt(text, text) owner to "kim-uijin";

create function pg_catalog.text_pattern_le(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_le(text, text) is 'implementation of ~<=~ operator';

alter function pg_catalog.text_pattern_le(text, text) owner to "kim-uijin";

create function pg_catalog.pg_get_function_arguments(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arguments(oid) is 'argument list of a function';

alter function pg_catalog.pg_get_function_arguments(oid) owner to "kim-uijin";

create function pg_catalog.text_pattern_ge(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_ge(text, text) is 'implementation of ~>=~ operator';

alter function pg_catalog.text_pattern_ge(text, text) owner to "kim-uijin";

create function pg_catalog.text_pattern_gt(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text_pattern_gt(text, text) is 'implementation of ~>~ operator';

alter function pg_catalog.text_pattern_gt(text, text) owner to "kim-uijin";

create function pg_catalog.pg_get_function_result(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_result(oid) is 'result type of a function';

alter function pg_catalog.pg_get_function_result(oid) owner to "kim-uijin";

create function pg_catalog.bttext_pattern_cmp(text, text) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_cmp(text, text) is 'less-equal-greater';

alter function pg_catalog.bttext_pattern_cmp(text, text) owner to "kim-uijin";

create function pg_catalog.ceiling(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(numeric) is 'nearest integer >= value';

alter function pg_catalog.ceiling(numeric) owner to "kim-uijin";

create function pg_catalog.pg_database_size(name) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(name) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(name) owner to "kim-uijin";

create function pg_catalog.power(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.power(numeric, numeric) is 'exponentiation';

alter function pg_catalog.power(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.width_bucket(numeric, numeric, numeric, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(numeric, numeric, numeric, integer) is 'bucket number of operand in equal-width histogram';

alter function pg_catalog.width_bucket(numeric, numeric, numeric, integer) owner to "kim-uijin";

create function pg_catalog.pg_cancel_backend(integer) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_cancel_backend(integer) is 'cancel a server process'' current query';

alter function pg_catalog.pg_cancel_backend(integer) owner to "kim-uijin";

create function pg_catalog.pg_start_backup(label text, fast boolean default false, exclusive boolean default true) returns pg_lsn
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_start_backup(text, boolean, boolean) is 'prepare for taking an online backup';

alter function pg_catalog.pg_start_backup(text, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.pg_stop_backup(exclusive unknown, wait_for_archive unknown, out lsn unknown, out labelfile unknown, out spcmapfile unknown) returns pg_lsn
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stop_backup(unknown, unknown, out unknown, out unknown, out unknown) is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup(unknown, unknown, out unknown, out unknown, out unknown) owner to "kim-uijin";

create function pg_catalog.bpchar_pattern_lt(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_lt(char, char) is 'implementation of ~<~ operator';

alter function pg_catalog.bpchar_pattern_lt(char, char) owner to "kim-uijin";

create function pg_catalog.bpchar_pattern_le(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_le(char, char) is 'implementation of ~<=~ operator';

alter function pg_catalog.bpchar_pattern_le(char, char) owner to "kim-uijin";

create function pg_catalog.array_length(anyarray, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_length(anyarray, integer) is 'array length';

alter function pg_catalog.array_length(anyarray, integer) owner to "kim-uijin";

create function pg_catalog.bpchar_pattern_ge(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_ge(char, char) is 'implementation of ~>=~ operator';

alter function pg_catalog.bpchar_pattern_ge(char, char) owner to "kim-uijin";

create function pg_catalog.bpchar_pattern_gt(char, char) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_pattern_gt(char, char) is 'implementation of ~>~ operator';

alter function pg_catalog.bpchar_pattern_gt(char, char) owner to "kim-uijin";

create function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.btbpchar_pattern_cmp(char, char) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_cmp(char, char) is 'less-equal-greater';

alter function pg_catalog.btbpchar_pattern_cmp(char, char) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, text, text) is 'user privilege on sequence by username, seq name';

alter function pg_catalog.has_sequence_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(name, oid, text) is 'user privilege on sequence by username, seq oid';

alter function pg_catalog.has_sequence_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, text, text) is 'user privilege on sequence by user oid, seq name';

alter function pg_catalog.has_sequence_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, oid, text) is 'user privilege on sequence by user oid, seq oid';

alter function pg_catalog.has_sequence_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(text, text, unknown) is 'current user privilege on sequence by seq name';

alter function pg_catalog.has_sequence_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_sequence_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_sequence_privilege(oid, text, unknown) is 'current user privilege on sequence by seq oid';

alter function pg_catalog.has_sequence_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.btint48cmp(integer, bigint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint48cmp(integer, bigint) is 'less-equal-greater';

alter function pg_catalog.btint48cmp(integer, bigint) owner to "kim-uijin";

create function pg_catalog.btint84cmp(bigint, integer) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint84cmp(bigint, integer) is 'less-equal-greater';

alter function pg_catalog.btint84cmp(bigint, integer) owner to "kim-uijin";

create function pg_catalog.btint24cmp(smallint, integer) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint24cmp(smallint, integer) is 'less-equal-greater';

alter function pg_catalog.btint24cmp(smallint, integer) owner to "kim-uijin";

create function pg_catalog.btint42cmp(integer, smallint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint42cmp(integer, smallint) is 'less-equal-greater';

alter function pg_catalog.btint42cmp(integer, smallint) owner to "kim-uijin";

create function pg_catalog.btint28cmp(smallint, bigint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint28cmp(smallint, bigint) is 'less-equal-greater';

alter function pg_catalog.btint28cmp(smallint, bigint) owner to "kim-uijin";

create function pg_catalog.btint82cmp(bigint, smallint) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint82cmp(bigint, smallint) is 'less-equal-greater';

alter function pg_catalog.btint82cmp(bigint, smallint) owner to "kim-uijin";

create function pg_catalog.btfloat48cmp(real, double precision) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat48cmp(real, double precision) is 'less-equal-greater';

alter function pg_catalog.btfloat48cmp(real, double precision) owner to "kim-uijin";

create function pg_catalog.btfloat84cmp(double precision, real) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat84cmp(double precision, real) is 'less-equal-greater';

alter function pg_catalog.btfloat84cmp(double precision, real) owner to "kim-uijin";

create function pg_catalog.inet_client_addr() returns inet
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_addr() is 'inet address of the client';

alter function pg_catalog.inet_client_addr() owner to "kim-uijin";

create function pg_catalog.inet_client_port() returns integer
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_client_port() is 'client''s port number for this connection';

alter function pg_catalog.inet_client_port() owner to "kim-uijin";

create function pg_catalog.inet_server_addr() returns inet
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_addr() is 'inet address of the server';

alter function pg_catalog.inet_server_addr() owner to "kim-uijin";

create function pg_catalog.inet_server_port() returns integer
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_server_port() is 'server''s port number for this connection';

alter function pg_catalog.inet_server_port() owner to "kim-uijin";

create function pg_catalog.regprocedurein(cstring) returns regprocedure
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurein(cstring) is 'I/O';

alter function pg_catalog.regprocedurein(cstring) owner to "kim-uijin";

create function pg_catalog.regprocedureout(regprocedure) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedureout(regprocedure) is 'I/O';

alter function pg_catalog.regprocedureout(regprocedure) owner to "kim-uijin";

create function pg_catalog.regoperin(cstring) returns regoper
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperin(cstring) is 'I/O';

alter function pg_catalog.regoperin(cstring) owner to "kim-uijin";

create function pg_catalog.regoperout(regoper) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperout(regoper) is 'I/O';

alter function pg_catalog.regoperout(regoper) owner to "kim-uijin";

create function pg_catalog.regoperatorin(cstring) returns regoperator
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorin(cstring) is 'I/O';

alter function pg_catalog.regoperatorin(cstring) owner to "kim-uijin";

create function pg_catalog.regoperatorout(regoperator) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorout(regoperator) is 'I/O';

alter function pg_catalog.regoperatorout(regoperator) owner to "kim-uijin";

create function pg_catalog.regclassin(cstring) returns regclass
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassin(cstring) is 'I/O';

alter function pg_catalog.regclassin(cstring) owner to "kim-uijin";

create function pg_catalog.regclassout(regclass) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassout(regclass) is 'I/O';

alter function pg_catalog.regclassout(regclass) owner to "kim-uijin";

create function pg_catalog.regtypein(cstring) returns regtype
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypein(cstring) is 'I/O';

alter function pg_catalog.regtypein(cstring) owner to "kim-uijin";

create function pg_catalog.regtypeout(regtype) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypeout(regtype) is 'I/O';

alter function pg_catalog.regtypeout(regtype) owner to "kim-uijin";

create function pg_catalog.pg_stat_clear_snapshot() returns void
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_clear_snapshot() is 'statistics: discard current transaction''s statistics snapshot';

alter function pg_catalog.pg_stat_clear_snapshot() owner to "kim-uijin";

create function pg_catalog.pg_get_function_identity_arguments(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_identity_arguments(oid) is 'identity argument list of a function';

alter function pg_catalog.pg_get_function_identity_arguments(oid) owner to "kim-uijin";

create function pg_catalog.hashtid(tid) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtid(tid) is 'hash';

alter function pg_catalog.hashtid(tid) owner to "kim-uijin";

create function pg_catalog.hashtidextended(tid, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashtidextended(tid, bigint) is 'hash';

alter function pg_catalog.hashtidextended(tid, bigint) owner to "kim-uijin";

create function pg_catalog.fmgr_internal_validator(oid) returns void
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_internal_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_internal_validator(oid) owner to "kim-uijin";

create function pg_catalog.fmgr_c_validator(oid) returns void
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_c_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_c_validator(oid) owner to "kim-uijin";

create function pg_catalog.fmgr_sql_validator(oid) returns void
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fmgr_sql_validator(oid) is '(internal)';

alter function pg_catalog.fmgr_sql_validator(oid) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, text, text) is 'user privilege on database by username, database name';

alter function pg_catalog.has_database_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(name, oid, text) is 'user privilege on database by username, database oid';

alter function pg_catalog.has_database_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, text, text) is 'user privilege on database by user oid, database name';

alter function pg_catalog.has_database_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, oid, text) is 'user privilege on database by user oid, database oid';

alter function pg_catalog.has_database_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(text, text, unknown) is 'current user privilege on database by database name';

alter function pg_catalog.has_database_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_database_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_database_privilege(oid, text, unknown) is 'current user privilege on database by database oid';

alter function pg_catalog.has_database_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, text, text) is 'user privilege on function by username, function name';

alter function pg_catalog.has_function_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(name, oid, text) is 'user privilege on function by username, function oid';

alter function pg_catalog.has_function_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, text, text) is 'user privilege on function by user oid, function name';

alter function pg_catalog.has_function_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, oid, text) is 'user privilege on function by user oid, function oid';

alter function pg_catalog.has_function_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(text, text, unknown) is 'current user privilege on function by function name';

alter function pg_catalog.has_function_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_function_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_function_privilege(oid, text, unknown) is 'current user privilege on function by function oid';

alter function pg_catalog.has_function_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, text, text) is 'user privilege on language by username, language name';

alter function pg_catalog.has_language_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(name, oid, text) is 'user privilege on language by username, language oid';

alter function pg_catalog.has_language_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, text, text) is 'user privilege on language by user oid, language name';

alter function pg_catalog.has_language_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, oid, text) is 'user privilege on language by user oid, language oid';

alter function pg_catalog.has_language_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(text, text, unknown) is 'current user privilege on language by language name';

alter function pg_catalog.has_language_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_language_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_language_privilege(oid, text, unknown) is 'current user privilege on language by language oid';

alter function pg_catalog.has_language_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, text, text) is 'user privilege on schema by username, schema name';

alter function pg_catalog.has_schema_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(name, oid, text) is 'user privilege on schema by username, schema oid';

alter function pg_catalog.has_schema_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, text, text) is 'user privilege on schema by user oid, schema name';

alter function pg_catalog.has_schema_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, oid, text) is 'user privilege on schema by user oid, schema oid';

alter function pg_catalog.has_schema_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(text, text, unknown) is 'current user privilege on schema by schema name';

alter function pg_catalog.has_schema_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_schema_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_schema_privilege(oid, text, unknown) is 'current user privilege on schema by schema oid';

alter function pg_catalog.has_schema_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset() returns void
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset() is 'statistics: reset collected statistics for current database';

alter function pg_catalog.pg_stat_reset() owner to "kim-uijin";

create function pg_catalog.pg_get_backend_memory_contexts(out name text, out ident text, out parent text, out level integer, out total_bytes bigint, out total_nblocks bigint, out free_bytes bigint, out free_chunks bigint, out used_bytes bigint) returns setof setof record
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_backend_memory_contexts(out text, out text, out text, out integer, out bigint, out bigint, out bigint, out bigint, out bigint) is 'information about all memory contexts of local backend';

alter function pg_catalog.pg_get_backend_memory_contexts(out text, out text, out text, out integer, out bigint, out bigint, out bigint, out bigint, out bigint) owner to "kim-uijin";

create function pg_catalog.regexp_replace(text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(text, text, text) is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text) owner to "kim-uijin";

create function pg_catalog.regexp_replace(text, text, text, text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_replace(text, text, text, text) is 'replace text using regexp';

alter function pg_catalog.regexp_replace(text, text, text, text) owner to "kim-uijin";

create function pg_catalog.pg_total_relation_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_total_relation_size(regclass) is 'total disk space usage for the specified table and associated indexes';

alter function pg_catalog.pg_total_relation_size(regclass) owner to "kim-uijin";

create function pg_catalog.pg_size_pretty(bigint) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(bigint) is 'convert a long int to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(bigint) owner to "kim-uijin";

create function pg_catalog.pg_options_to_table(options_array text[], out option_name text, out option_value text) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    rows 3
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_options_to_table(text[], out text, out text) is 'convert generic options array to name/value table';

alter function pg_catalog.pg_options_to_table(text[], out text, out text) owner to "kim-uijin";

create function pg_catalog.record_in(cstring, oid, integer) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.record_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.record_out(record) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_out(record) is 'I/O';

alter function pg_catalog.record_out(record) owner to "kim-uijin";

create function pg_catalog.cstring_in(cstring) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_in(cstring) is 'I/O';

alter function pg_catalog.cstring_in(cstring) owner to "kim-uijin";

create function pg_catalog.cstring_out(cstring) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_out(cstring) is 'I/O';

alter function pg_catalog.cstring_out(cstring) owner to "kim-uijin";

create function pg_catalog.any_in(cstring) returns "any"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_in(cstring) is 'I/O';

alter function pg_catalog.any_in(cstring) owner to "kim-uijin";

create function pg_catalog.any_out("any") returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.any_out("any") is 'I/O';

alter function pg_catalog.any_out("any") owner to "kim-uijin";

create function pg_catalog.anyarray_in(cstring) returns anyarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_in(cstring) is 'I/O';

alter function pg_catalog.anyarray_in(cstring) owner to "kim-uijin";

create function pg_catalog.anyarray_out(anyarray) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_out(anyarray) is 'I/O';

alter function pg_catalog.anyarray_out(anyarray) owner to "kim-uijin";

create function pg_catalog.void_in(cstring) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_in(cstring) is 'I/O';

alter function pg_catalog.void_in(cstring) owner to "kim-uijin";

create function pg_catalog.void_out(void) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_out(void) is 'I/O';

alter function pg_catalog.void_out(void) owner to "kim-uijin";

create function pg_catalog.trigger_in(cstring) returns trigger
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_in(cstring) is 'I/O';

alter function pg_catalog.trigger_in(cstring) owner to "kim-uijin";

create function pg_catalog.trigger_out(trigger) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trigger_out(trigger) is 'I/O';

alter function pg_catalog.trigger_out(trigger) owner to "kim-uijin";

create function pg_catalog.language_handler_in(cstring) returns language_handler
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_in(cstring) is 'I/O';

alter function pg_catalog.language_handler_in(cstring) owner to "kim-uijin";

create function pg_catalog.language_handler_out(language_handler) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.language_handler_out(language_handler) is 'I/O';

alter function pg_catalog.language_handler_out(language_handler) owner to "kim-uijin";

create function pg_catalog.internal_in(cstring) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_in(cstring) is 'I/O';

alter function pg_catalog.internal_in(cstring) owner to "kim-uijin";

create function pg_catalog.internal_out(internal) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.internal_out(internal) is 'I/O';

alter function pg_catalog.internal_out(internal) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_slru(out name text, out blks_zeroed bigint, out blks_hit bigint, out blks_read bigint, out blks_written bigint, out blks_exists bigint, out flushes bigint, out truncates bigint, out stats_reset timestamp with time zone) returns setof setof record
    stable
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_slru(out text, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out timestamp with time zone) is 'statistics: information about SLRU caches';

alter function pg_catalog.pg_stat_get_slru(out text, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset_slru(text) returns void
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_slru(text) is 'statistics: reset collected statistics for a single SLRU';

alter function pg_catalog.pg_stat_reset_slru(text) owner to "kim-uijin";

create function pg_catalog.ceil(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceil(double precision) is 'nearest integer >= value';

alter function pg_catalog.ceil(double precision) owner to "kim-uijin";

create function pg_catalog.floor(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.floor(double precision) is 'nearest integer <= value';

alter function pg_catalog.floor(double precision) owner to "kim-uijin";

create function pg_catalog.sign(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sign(double precision) is 'sign of value';

alter function pg_catalog.sign(double precision) owner to "kim-uijin";

create function pg_catalog.md5(text) returns text
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(text) is 'MD5 hash';

alter function pg_catalog.md5(text) owner to "kim-uijin";

create function pg_catalog.anyelement_in(cstring) returns anyelement
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_in(cstring) is 'I/O';

alter function pg_catalog.anyelement_in(cstring) owner to "kim-uijin";

create function pg_catalog.anyelement_out(anyelement) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyelement_out(anyelement) is 'I/O';

alter function pg_catalog.anyelement_out(anyelement) owner to "kim-uijin";

create function pg_catalog.postgresql_fdw_validator(text[], oid) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.postgresql_fdw_validator(text[], oid) is '(internal)';

alter function pg_catalog.postgresql_fdw_validator(text[], oid) owner to "kim-uijin";

create function pg_catalog.pg_encoding_max_length(integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_encoding_max_length(integer) is 'maximum octet length of a character in given encoding';

alter function pg_catalog.pg_encoding_max_length(integer) owner to "kim-uijin";

create function pg_catalog.ceiling(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ceiling(double precision) is 'nearest integer >= value';

alter function pg_catalog.ceiling(double precision) owner to "kim-uijin";

create function pg_catalog.md5(bytea) returns text
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.md5(bytea) is 'MD5 hash';

alter function pg_catalog.md5(bytea) owner to "kim-uijin";

create function pg_catalog.pg_tablespace_size(oid) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(oid) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(oid) owner to "kim-uijin";

create function pg_catalog.pg_tablespace_size(name) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_size(name) is 'total disk space usage for the specified tablespace';

alter function pg_catalog.pg_tablespace_size(name) owner to "kim-uijin";

create function pg_catalog.pg_database_size(oid) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_database_size(oid) is 'total disk space usage for the specified database';

alter function pg_catalog.pg_database_size(oid) owner to "kim-uijin";

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language sql
RETURN pg_relation_size($1, 'main'::text);

comment on function pg_catalog.pg_relation_size(regclass, unknown) is 'disk space usage for the main fork of the specified table or index';

alter function pg_catalog.pg_relation_size(regclass, unknown) owner to "kim-uijin";

create function pg_catalog.unnest(anyarray) returns setof setof anyelement
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.unnest(anyarray) is 'expand array to set of rows';

alter function pg_catalog.unnest(anyarray) owner to "kim-uijin";

create function pg_catalog.pg_relation_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_size(regclass, text) is 'disk space usage for the specified fork of a table or index';

alter function pg_catalog.pg_relation_size(regclass, text) owner to "kim-uijin";

create function pg_catalog.array_agg_transfn(internal, anynonarray) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_transfn(internal, anynonarray) is 'aggregate transition function';

alter function pg_catalog.array_agg_transfn(internal, anynonarray) owner to "kim-uijin";

create function pg_catalog.array_agg_finalfn(internal, anynonarray) returns anyarray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_finalfn(internal, anynonarray) is 'aggregate final function';

alter function pg_catalog.array_agg_finalfn(internal, anynonarray) owner to "kim-uijin";

create function pg_catalog.date_lt_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamp(date, timestamp) is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_le_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamp(date, timestamp) is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_eq_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamp(date, timestamp) is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_gt_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamp(date, timestamp) is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_ge_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamp(date, timestamp) is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_ne_timestamp(date, timestamp) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamp(date, timestamp) is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_cmp_timestamp(date, timestamp) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamp(date, timestamp) is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamp(date, timestamp) owner to "kim-uijin";

create function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.date_lt_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_le_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_le_timestamptz(date, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.date_le_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.date_eq_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.date_gt_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.date_ge_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.date_ne_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.date_cmp_timestamptz(date, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_lt_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_date(timestamp, date) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_le_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_date(timestamp, date) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_eq_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_date(timestamp, date) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_gt_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_date(timestamp, date) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_ge_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_date(timestamp, date) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_ne_date(timestamp, date) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_date(timestamp, date) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamp_cmp_date(timestamp, date) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_date(timestamp, date) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_date(timestamp, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_le_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_date(timestamp with time zone, date) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_date(timestamp with time zone, date) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, text, text) is 'user privilege on tablespace by username, tablespace name';

alter function pg_catalog.has_tablespace_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(name, oid, text) is 'user privilege on tablespace by username, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, text, text) is 'user privilege on tablespace by user oid, tablespace name';

alter function pg_catalog.has_tablespace_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, oid, text) is 'user privilege on tablespace by user oid, tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(text, text, unknown) is 'current user privilege on tablespace by tablespace name';

alter function pg_catalog.has_tablespace_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_tablespace_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_tablespace_privilege(oid, text, unknown) is 'current user privilege on tablespace by tablespace oid';

alter function pg_catalog.has_tablespace_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.shell_in(cstring) returns void
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_in(cstring) is 'I/O';

alter function pg_catalog.shell_in(cstring) owner to "kim-uijin";

create function pg_catalog.shell_out(void) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shell_out(void) is 'I/O';

alter function pg_catalog.shell_out(void) owner to "kim-uijin";

create function pg_catalog.array_recv(internal, oid, integer) returns anyarray
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.array_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.array_send(anyarray) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_send(anyarray) is 'I/O';

alter function pg_catalog.array_send(anyarray) owner to "kim-uijin";

create function pg_catalog.record_recv(internal, oid, integer) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.record_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.record_send(record) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_send(record) is 'I/O';

alter function pg_catalog.record_send(record) owner to "kim-uijin";

create function pg_catalog.int2recv(internal) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2recv(internal) is 'I/O';

alter function pg_catalog.int2recv(internal) owner to "kim-uijin";

create function pg_catalog.int2send(smallint) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2send(smallint) is 'I/O';

alter function pg_catalog.int2send(smallint) owner to "kim-uijin";

create function pg_catalog.int4recv(internal) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4recv(internal) is 'I/O';

alter function pg_catalog.int4recv(internal) owner to "kim-uijin";

create function pg_catalog.int4send(integer) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4send(integer) is 'I/O';

alter function pg_catalog.int4send(integer) owner to "kim-uijin";

create function pg_catalog.int8recv(internal) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8recv(internal) is 'I/O';

alter function pg_catalog.int8recv(internal) owner to "kim-uijin";

create function pg_catalog.int8send(bigint) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8send(bigint) is 'I/O';

alter function pg_catalog.int8send(bigint) owner to "kim-uijin";

create function pg_catalog.int2vectorrecv(internal) returns int2vector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorrecv(internal) is 'I/O';

alter function pg_catalog.int2vectorrecv(internal) owner to "kim-uijin";

create function pg_catalog.int2vectorsend(int2vector) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2vectorsend(int2vector) is 'I/O';

alter function pg_catalog.int2vectorsend(int2vector) owner to "kim-uijin";

create function pg_catalog.bytearecv(internal) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytearecv(internal) is 'I/O';

alter function pg_catalog.bytearecv(internal) owner to "kim-uijin";

create function pg_catalog.byteasend(bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.byteasend(bytea) is 'I/O';

alter function pg_catalog.byteasend(bytea) owner to "kim-uijin";

create function pg_catalog.textrecv(internal) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textrecv(internal) is 'I/O';

alter function pg_catalog.textrecv(internal) owner to "kim-uijin";

create function pg_catalog.textsend(text) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.textsend(text) is 'I/O';

alter function pg_catalog.textsend(text) owner to "kim-uijin";

create function pg_catalog.unknownrecv(internal) returns unknown
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownrecv(internal) is 'I/O';

alter function pg_catalog.unknownrecv(internal) owner to "kim-uijin";

create function pg_catalog.unknownsend(unknown) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unknownsend(unknown) is 'I/O';

alter function pg_catalog.unknownsend(unknown) owner to "kim-uijin";

create function pg_catalog.oidrecv(internal) returns oid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidrecv(internal) is 'I/O';

alter function pg_catalog.oidrecv(internal) owner to "kim-uijin";

create function pg_catalog.oidsend(oid) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidsend(oid) is 'I/O';

alter function pg_catalog.oidsend(oid) owner to "kim-uijin";

create function pg_catalog.oidvectorrecv(internal) returns oidvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorrecv(internal) is 'I/O';

alter function pg_catalog.oidvectorrecv(internal) owner to "kim-uijin";

create function pg_catalog.oidvectorsend(oidvector) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.oidvectorsend(oidvector) is 'I/O';

alter function pg_catalog.oidvectorsend(oidvector) owner to "kim-uijin";

create function pg_catalog.namerecv(internal) returns name
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namerecv(internal) is 'I/O';

alter function pg_catalog.namerecv(internal) owner to "kim-uijin";

create function pg_catalog.namesend(name) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.namesend(name) is 'I/O';

alter function pg_catalog.namesend(name) owner to "kim-uijin";

create function pg_catalog.float4recv(internal) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4recv(internal) is 'I/O';

alter function pg_catalog.float4recv(internal) owner to "kim-uijin";

create function pg_catalog.float4send(real) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4send(real) is 'I/O';

alter function pg_catalog.float4send(real) owner to "kim-uijin";

create function pg_catalog.float8recv(internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8recv(internal) is 'I/O';

alter function pg_catalog.float8recv(internal) owner to "kim-uijin";

create function pg_catalog.float8send(double precision) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8send(double precision) is 'I/O';

alter function pg_catalog.float8send(double precision) owner to "kim-uijin";

create function pg_catalog.point_recv(internal) returns point
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_recv(internal) is 'I/O';

alter function pg_catalog.point_recv(internal) owner to "kim-uijin";

create function pg_catalog.point_send(point) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.point_send(point) is 'I/O';

alter function pg_catalog.point_send(point) owner to "kim-uijin";

create function pg_catalog.bpcharrecv(internal, oid, integer) returns char
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharrecv(internal, oid, integer) is 'I/O';

alter function pg_catalog.bpcharrecv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.bpcharsend(char) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpcharsend(char) is 'I/O';

alter function pg_catalog.bpcharsend(char) owner to "kim-uijin";

create function pg_catalog.varcharrecv(internal, oid, integer) returns varchar
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharrecv(internal, oid, integer) is 'I/O';

alter function pg_catalog.varcharrecv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.varcharsend(varchar) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varcharsend(varchar) is 'I/O';

alter function pg_catalog.varcharsend(varchar) owner to "kim-uijin";

create function pg_catalog.charrecv(internal) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charrecv(internal) is 'I/O';

alter function pg_catalog.charrecv(internal) owner to "kim-uijin";

create function pg_catalog.charsend("char") returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.charsend("char") is 'I/O';

alter function pg_catalog.charsend("char") owner to "kim-uijin";

create function pg_catalog.boolrecv(internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolrecv(internal) is 'I/O';

alter function pg_catalog.boolrecv(internal) owner to "kim-uijin";

create function pg_catalog.boolsend(boolean) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolsend(boolean) is 'I/O';

alter function pg_catalog.boolsend(boolean) owner to "kim-uijin";

create function pg_catalog.tidrecv(internal) returns tid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidrecv(internal) is 'I/O';

alter function pg_catalog.tidrecv(internal) owner to "kim-uijin";

create function pg_catalog.tidsend(tid) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsend(tid) is 'I/O';

alter function pg_catalog.tidsend(tid) owner to "kim-uijin";

create function pg_catalog.xidrecv(internal) returns xid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidrecv(internal) is 'I/O';

alter function pg_catalog.xidrecv(internal) owner to "kim-uijin";

create function pg_catalog.xidsend(xid) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidsend(xid) is 'I/O';

alter function pg_catalog.xidsend(xid) owner to "kim-uijin";

create function pg_catalog.cidrecv(internal) returns cid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidrecv(internal) is 'I/O';

alter function pg_catalog.cidrecv(internal) owner to "kim-uijin";

create function pg_catalog.cidsend(cid) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidsend(cid) is 'I/O';

alter function pg_catalog.cidsend(cid) owner to "kim-uijin";

create function pg_catalog.regprocrecv(internal) returns regproc
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocrecv(internal) is 'I/O';

alter function pg_catalog.regprocrecv(internal) owner to "kim-uijin";

create function pg_catalog.regprocsend(regproc) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocsend(regproc) is 'I/O';

alter function pg_catalog.regprocsend(regproc) owner to "kim-uijin";

create function pg_catalog.regprocedurerecv(internal) returns regprocedure
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regprocedurerecv(internal) is 'I/O';

alter function pg_catalog.regprocedurerecv(internal) owner to "kim-uijin";

create function pg_catalog.regproceduresend(regprocedure) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regproceduresend(regprocedure) is 'I/O';

alter function pg_catalog.regproceduresend(regprocedure) owner to "kim-uijin";

create function pg_catalog.regoperrecv(internal) returns regoper
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperrecv(internal) is 'I/O';

alter function pg_catalog.regoperrecv(internal) owner to "kim-uijin";

create function pg_catalog.regopersend(regoper) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regopersend(regoper) is 'I/O';

alter function pg_catalog.regopersend(regoper) owner to "kim-uijin";

create function pg_catalog.regoperatorrecv(internal) returns regoperator
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorrecv(internal) is 'I/O';

alter function pg_catalog.regoperatorrecv(internal) owner to "kim-uijin";

create function pg_catalog.regoperatorsend(regoperator) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regoperatorsend(regoperator) is 'I/O';

alter function pg_catalog.regoperatorsend(regoperator) owner to "kim-uijin";

create function pg_catalog.regclassrecv(internal) returns regclass
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclassrecv(internal) is 'I/O';

alter function pg_catalog.regclassrecv(internal) owner to "kim-uijin";

create function pg_catalog.regclasssend(regclass) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regclasssend(regclass) is 'I/O';

alter function pg_catalog.regclasssend(regclass) owner to "kim-uijin";

create function pg_catalog.regtyperecv(internal) returns regtype
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtyperecv(internal) is 'I/O';

alter function pg_catalog.regtyperecv(internal) owner to "kim-uijin";

create function pg_catalog.regtypesend(regtype) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regtypesend(regtype) is 'I/O';

alter function pg_catalog.regtypesend(regtype) owner to "kim-uijin";

create function pg_catalog.bit_recv(internal, oid, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.bit_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.bit_send(bit) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_send(bit) is 'I/O';

alter function pg_catalog.bit_send(bit) owner to "kim-uijin";

create function pg_catalog.varbit_recv(internal, oid, integer) returns bit varying
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.varbit_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.varbit_send(bit varying) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_send(bit varying) is 'I/O';

alter function pg_catalog.varbit_send(bit varying) owner to "kim-uijin";

create function pg_catalog.numeric_recv(internal, oid, integer) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.numeric_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.numeric_send(numeric) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_send(numeric) is 'I/O';

alter function pg_catalog.numeric_send(numeric) owner to "kim-uijin";

create function pg_catalog.sinh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sinh(double precision) is 'hyperbolic sine';

alter function pg_catalog.sinh(double precision) owner to "kim-uijin";

create function pg_catalog.cosh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosh(double precision) is 'hyperbolic cosine';

alter function pg_catalog.cosh(double precision) owner to "kim-uijin";

create function pg_catalog.tanh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tanh(double precision) is 'hyperbolic tangent';

alter function pg_catalog.tanh(double precision) owner to "kim-uijin";

create function pg_catalog.asinh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asinh(double precision) is 'inverse hyperbolic sine';

alter function pg_catalog.asinh(double precision) owner to "kim-uijin";

create function pg_catalog.acosh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosh(double precision) is 'inverse hyperbolic cosine';

alter function pg_catalog.acosh(double precision) owner to "kim-uijin";

create function pg_catalog.atanh(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atanh(double precision) is 'inverse hyperbolic tangent';

alter function pg_catalog.atanh(double precision) owner to "kim-uijin";

create function pg_catalog.date_recv(internal) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_recv(internal) is 'I/O';

alter function pg_catalog.date_recv(internal) owner to "kim-uijin";

create function pg_catalog.date_send(date) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_send(date) is 'I/O';

alter function pg_catalog.date_send(date) owner to "kim-uijin";

create function pg_catalog.time_recv(internal, oid, integer) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.time_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.time_send(time) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_send(time) is 'I/O';

alter function pg_catalog.time_send(time) owner to "kim-uijin";

create function pg_catalog.timetz_recv(internal, oid, integer) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timetz_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.timetz_send(time with time zone) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_send(time with time zone) is 'I/O';

alter function pg_catalog.timetz_send(time with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_recv(internal, oid, integer) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timestamp_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.timestamp_send(timestamp) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_send(timestamp) is 'I/O';

alter function pg_catalog.timestamp_send(timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_recv(internal, oid, integer) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.timestamptz_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.timestamptz_send(timestamp with time zone) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_send(timestamp with time zone) is 'I/O';

alter function pg_catalog.timestamptz_send(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.interval_recv(internal, oid, integer) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.interval_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.interval_send(interval) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_send(interval) is 'I/O';

alter function pg_catalog.interval_send(interval) owner to "kim-uijin";

create function pg_catalog.lseg_recv(internal) returns lseg
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_recv(internal) is 'I/O';

alter function pg_catalog.lseg_recv(internal) owner to "kim-uijin";

create function pg_catalog.lseg_send(lseg) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lseg_send(lseg) is 'I/O';

alter function pg_catalog.lseg_send(lseg) owner to "kim-uijin";

create function pg_catalog.path_recv(internal) returns path
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_recv(internal) is 'I/O';

alter function pg_catalog.path_recv(internal) owner to "kim-uijin";

create function pg_catalog.path_send(path) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.path_send(path) is 'I/O';

alter function pg_catalog.path_send(path) owner to "kim-uijin";

create function pg_catalog.box_recv(internal) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_recv(internal) is 'I/O';

alter function pg_catalog.box_recv(internal) owner to "kim-uijin";

create function pg_catalog.box_send(box) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_send(box) is 'I/O';

alter function pg_catalog.box_send(box) owner to "kim-uijin";

create function pg_catalog.poly_recv(internal) returns polygon
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_recv(internal) is 'I/O';

alter function pg_catalog.poly_recv(internal) owner to "kim-uijin";

create function pg_catalog.poly_send(polygon) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_send(polygon) is 'I/O';

alter function pg_catalog.poly_send(polygon) owner to "kim-uijin";

create function pg_catalog.line_recv(internal) returns line
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_recv(internal) is 'I/O';

alter function pg_catalog.line_recv(internal) owner to "kim-uijin";

create function pg_catalog.line_send(line) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.line_send(line) is 'I/O';

alter function pg_catalog.line_send(line) owner to "kim-uijin";

create function pg_catalog.circle_recv(internal) returns circle
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_recv(internal) is 'I/O';

alter function pg_catalog.circle_recv(internal) owner to "kim-uijin";

create function pg_catalog.circle_send(circle) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_send(circle) is 'I/O';

alter function pg_catalog.circle_send(circle) owner to "kim-uijin";

create function pg_catalog.cash_recv(internal) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_recv(internal) is 'I/O';

alter function pg_catalog.cash_recv(internal) owner to "kim-uijin";

create function pg_catalog.cash_send(money) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_send(money) is 'I/O';

alter function pg_catalog.cash_send(money) owner to "kim-uijin";

create function pg_catalog.macaddr_recv(internal) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_recv(internal) is 'I/O';

alter function pg_catalog.macaddr_recv(internal) owner to "kim-uijin";

create function pg_catalog.macaddr_send(macaddr) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_send(macaddr) is 'I/O';

alter function pg_catalog.macaddr_send(macaddr) owner to "kim-uijin";

create function pg_catalog.inet_recv(internal) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_recv(internal) is 'I/O';

alter function pg_catalog.inet_recv(internal) owner to "kim-uijin";

create function pg_catalog.inet_send(inet) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_send(inet) is 'I/O';

alter function pg_catalog.inet_send(inet) owner to "kim-uijin";

create function pg_catalog.cidr_recv(internal) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_recv(internal) is 'I/O';

alter function pg_catalog.cidr_recv(internal) owner to "kim-uijin";

create function pg_catalog.cidr_send(cidr) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cidr_send(cidr) is 'I/O';

alter function pg_catalog.cidr_send(cidr) owner to "kim-uijin";

create function pg_catalog.cstring_recv(internal) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_recv(internal) is 'I/O';

alter function pg_catalog.cstring_recv(internal) owner to "kim-uijin";

create function pg_catalog.cstring_send(cstring) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cstring_send(cstring) is 'I/O';

alter function pg_catalog.cstring_send(cstring) owner to "kim-uijin";

create function pg_catalog.anyarray_recv(internal) returns anyarray
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_recv(internal) is 'I/O';

alter function pg_catalog.anyarray_recv(internal) owner to "kim-uijin";

create function pg_catalog.anyarray_send(anyarray) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyarray_send(anyarray) is 'I/O';

alter function pg_catalog.anyarray_send(anyarray) owner to "kim-uijin";

create function pg_catalog.pg_get_ruledef(oid, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_ruledef(oid, boolean) is 'source text of a rule with pretty-print option';

alter function pg_catalog.pg_get_ruledef(oid, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_viewdef(text, boolean) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(text, boolean) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(text, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_viewdef(oid, boolean) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid, boolean) is 'select statement of a view with pretty-print option';

alter function pg_catalog.pg_get_viewdef(oid, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_indexdef(oid, integer, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_indexdef(oid, integer, boolean) is 'index description (full create statement or single expression) with pretty-print option';

alter function pg_catalog.pg_get_indexdef(oid, integer, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_constraintdef(oid, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_constraintdef(oid, boolean) is 'constraint description with pretty-print option';

alter function pg_catalog.pg_get_constraintdef(oid, boolean) owner to "kim-uijin";

create function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) is 'deparse an encoded expression with pretty-print option';

alter function pg_catalog.pg_get_expr(pg_node_tree, oid, boolean) owner to "kim-uijin";

create function pg_catalog.pg_prepared_statement(out name text, out statement text, out prepare_time timestamp with time zone, out parameter_types regtype[], out from_sql boolean, out generic_plans bigint, out custom_plans bigint) returns setof setof record
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype[], out boolean, out bigint, out bigint) is 'get the prepared statements for this session';

alter function pg_catalog.pg_prepared_statement(out text, out text, out timestamp with time zone, out regtype[], out boolean, out bigint, out bigint) owner to "kim-uijin";

create function pg_catalog.pg_cursor(out name text, out statement text, out is_holdable boolean, out is_binary boolean, out is_scrollable boolean, out creation_time timestamp with time zone) returns setof setof record
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone) is 'get the open cursors for this session';

alter function pg_catalog.pg_cursor(out text, out text, out boolean, out boolean, out boolean, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.float8_var_pop(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_var_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_var_pop(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_stddev_pop(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_stddev_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_stddev_pop(double precision[]) owner to "kim-uijin";

create function pg_catalog.numeric_var_pop(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_var_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_var_pop(internal) owner to "kim-uijin";

create function pg_catalog.booland_statefunc(boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.booland_statefunc(boolean, boolean) is 'aggregate transition function';

alter function pg_catalog.booland_statefunc(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.boolor_statefunc(boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.boolor_statefunc(boolean, boolean) is 'aggregate transition function';

alter function pg_catalog.boolor_statefunc(boolean, boolean) owner to "kim-uijin";

create function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) is 'implementation of < operator';

alter function pg_catalog.timestamp_lt_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) is 'implementation of <= operator';

alter function pg_catalog.timestamp_le_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) is 'implementation of = operator';

alter function pg_catalog.timestamp_eq_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) is 'implementation of > operator';

alter function pg_catalog.timestamp_gt_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) is 'implementation of >= operator';

alter function pg_catalog.timestamp_ge_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) is 'implementation of <> operator';

alter function pg_catalog.timestamp_ne_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) is 'less-equal-greater';

alter function pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) is 'implementation of < operator';

alter function pg_catalog.timestamptz_lt_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) is 'implementation of <= operator';

alter function pg_catalog.timestamptz_le_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) is 'implementation of = operator';

alter function pg_catalog.timestamptz_eq_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) is 'implementation of > operator';

alter function pg_catalog.timestamptz_gt_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) is 'implementation of >= operator';

alter function pg_catalog.timestamptz_ge_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) is 'implementation of <> operator';

alter function pg_catalog.timestamptz_ne_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) is 'less-equal-greater';

alter function pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp) owner to "kim-uijin";

create function pg_catalog.interval_pl_date(interval, date) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.interval_pl_date(interval, date) is 'implementation of + operator';

alter function pg_catalog.interval_pl_date(interval, date) owner to "kim-uijin";

create function pg_catalog.interval_pl_timetz(interval, time with time zone) returns time with time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.interval_pl_timetz(interval, time with time zone) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timetz(interval, time with time zone) owner to "kim-uijin";

create function pg_catalog.interval_pl_timestamp(interval, timestamp without time zone) returns timestamp without time zone
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.interval_pl_timestamp(interval, timestamp) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamp(interval, timestamp) owner to "kim-uijin";

create function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) is 'implementation of + operator';

alter function pg_catalog.interval_pl_timestamptz(interval, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.integer_pl_date(integer, date) returns date
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.integer_pl_date(integer, date) is 'implementation of + operator';

alter function pg_catalog.integer_pl_date(integer, date) owner to "kim-uijin";

create function pg_catalog.pg_tablespace_databases(oid) returns setof setof oid
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_tablespace_databases(oid) is 'get OIDs of databases in a tablespace';

alter function pg_catalog.pg_tablespace_databases(oid) owner to "kim-uijin";

create function pg_catalog.bool(integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(integer) is 'convert int4 to boolean';

alter function pg_catalog.bool(integer) owner to "kim-uijin";

create function pg_catalog.int4(boolean) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(boolean) is 'convert boolean to int4';

alter function pg_catalog.int4(boolean) owner to "kim-uijin";

create function pg_catalog.lastval() returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lastval() is 'current value from last used sequence';

alter function pg_catalog.lastval() owner to "kim-uijin";

create function pg_catalog.pg_postmaster_start_time() returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_postmaster_start_time() is 'postmaster start time';

alter function pg_catalog.pg_postmaster_start_time() owner to "kim-uijin";

create function pg_catalog.pg_blocking_pids(integer) returns integer[]
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_blocking_pids(integer) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a heavyweight lock';

alter function pg_catalog.pg_blocking_pids(integer) owner to "kim-uijin";

create function pg_catalog.box_below(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_below(box, box) is 'implementation of <<| operator';

alter function pg_catalog.box_below(box, box) owner to "kim-uijin";

create function pg_catalog.box_overbelow(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overbelow(box, box) is 'implementation of &<| operator';

alter function pg_catalog.box_overbelow(box, box) owner to "kim-uijin";

create function pg_catalog.box_overabove(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_overabove(box, box) is 'implementation of |&> operator';

alter function pg_catalog.box_overabove(box, box) owner to "kim-uijin";

create function pg_catalog.box_above(box, box) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box_above(box, box) is 'implementation of |>> operator';

alter function pg_catalog.box_above(box, box) owner to "kim-uijin";

create function pg_catalog.poly_below(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_below(polygon, polygon) is 'implementation of <<| operator';

alter function pg_catalog.poly_below(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_overbelow(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overbelow(polygon, polygon) is 'implementation of &<| operator';

alter function pg_catalog.poly_overbelow(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_overabove(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_overabove(polygon, polygon) is 'implementation of |&> operator';

alter function pg_catalog.poly_overabove(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.poly_above(polygon, polygon) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.poly_above(polygon, polygon) is 'implementation of |>> operator';

alter function pg_catalog.poly_above(polygon, polygon) owner to "kim-uijin";

create function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.float8(jsonb) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8(jsonb) is 'convert jsonb to float8';

alter function pg_catalog.float8(jsonb) owner to "kim-uijin";

create function pg_catalog.gist_box_penalty(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_penalty(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gist_box_picksplit(internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.gist_box_union(internal, internal) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_union(internal, internal) is 'GiST support';

alter function pg_catalog.gist_box_union(internal, internal) owner to "kim-uijin";

create function pg_catalog.gist_box_same(box, box, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_same(box, box, internal) is 'GiST support';

alter function pg_catalog.gist_box_same(box, box, internal) owner to "kim-uijin";

create function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.gist_poly_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_compress(internal) is 'GiST support';

alter function pg_catalog.gist_poly_compress(internal) owner to "kim-uijin";

create function pg_catalog.circle_overbelow(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overbelow(circle, circle) is 'implementation of &<| operator';

alter function pg_catalog.circle_overbelow(circle, circle) owner to "kim-uijin";

create function pg_catalog.circle_overabove(circle, circle) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.circle_overabove(circle, circle) is 'implementation of |&> operator';

alter function pg_catalog.circle_overabove(circle, circle) owner to "kim-uijin";

create function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.gist_circle_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_compress(internal) is 'GiST support';

alter function pg_catalog.gist_circle_compress(internal) owner to "kim-uijin";

create function pg_catalog.numeric_stddev_pop(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_stddev_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_stddev_pop(internal) owner to "kim-uijin";

create function pg_catalog.domain_in(cstring, oid, integer) returns "any"
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.domain_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.domain_recv(internal, oid, integer) returns "any"
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.domain_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.domain_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.pg_timezone_abbrevs(out abbrev text, out utc_offset interval, out is_dst boolean) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean) is 'get the available time zone abbreviations';

alter function pg_catalog.pg_timezone_abbrevs(out text, out interval, out boolean) owner to "kim-uijin";

create function pg_catalog.xmlexists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlexists(text, xml) is 'test XML value against XPath expression';

alter function pg_catalog.xmlexists(text, xml) owner to "kim-uijin";

create function pg_catalog.pg_reload_conf() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_reload_conf() is 'reload configuration files';

alter function pg_catalog.pg_reload_conf() owner to "kim-uijin";

create function pg_catalog.pg_rotate_logfile() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile() is 'rotate log file';

alter function pg_catalog.pg_rotate_logfile() owner to "kim-uijin";

create function pg_catalog.pg_stat_file(filename text, out size bigint, out access timestamp with time zone, out modification timestamp with time zone, out change timestamp with time zone, out creation timestamp with time zone, out isdir boolean) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

alter function pg_catalog.pg_stat_file(text, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) owner to "kim-uijin";

create function pg_catalog.pg_read_file(text, bigint, bigint) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text, bigint, bigint) is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint) owner to "kim-uijin";

create function pg_catalog.pg_ls_dir(text) returns setof setof text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_dir(text) is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text) owner to "kim-uijin";

create function pg_catalog.pg_sleep(double precision) returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sleep(double precision) is 'sleep for the specified time in seconds';

alter function pg_catalog.pg_sleep(double precision) owner to "kim-uijin";

create function pg_catalog.inetnot(inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetnot(inet) is 'implementation of ~ operator';

alter function pg_catalog.inetnot(inet) owner to "kim-uijin";

create function pg_catalog.inetand(inet, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetand(inet, inet) is 'implementation of & operator';

alter function pg_catalog.inetand(inet, inet) owner to "kim-uijin";

create function pg_catalog.inetor(inet, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetor(inet, inet) is 'implementation of | operator';

alter function pg_catalog.inetor(inet, inet) owner to "kim-uijin";

create function pg_catalog.inetpl(inet, bigint) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetpl(inet, bigint) is 'implementation of + operator';

alter function pg_catalog.inetpl(inet, bigint) owner to "kim-uijin";

create function pg_catalog.int8pl_inet(bigint, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.int8pl_inet(bigint, inet) is 'implementation of + operator';

alter function pg_catalog.int8pl_inet(bigint, inet) owner to "kim-uijin";

create function pg_catalog.inetmi_int8(inet, bigint) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi_int8(inet, bigint) is 'implementation of - operator';

alter function pg_catalog.inetmi_int8(inet, bigint) owner to "kim-uijin";

create function pg_catalog.inetmi(inet, inet) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inetmi(inet, inet) is 'implementation of - operator';

alter function pg_catalog.inetmi(inet, inet) owner to "kim-uijin";

create function pg_catalog.transaction_timestamp() returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.transaction_timestamp() is 'current transaction time';

alter function pg_catalog.transaction_timestamp() owner to "kim-uijin";

create function pg_catalog.statement_timestamp() returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.statement_timestamp() is 'current statement time';

alter function pg_catalog.statement_timestamp() owner to "kim-uijin";

create function pg_catalog.clock_timestamp() returns timestamp with time zone
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.clock_timestamp() is 'current clock time';

alter function pg_catalog.clock_timestamp() owner to "kim-uijin";

create function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_prefix(text, text, smallint, internal) owner to "kim-uijin";

create function pg_catalog.pg_has_role(name, name, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, name, text) is 'user privilege on role by username, role name';

alter function pg_catalog.pg_has_role(name, name, text) owner to "kim-uijin";

create function pg_catalog.pg_has_role(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, oid, text) is 'user privilege on role by username, role oid';

alter function pg_catalog.pg_has_role(name, oid, text) owner to "kim-uijin";

create function pg_catalog.pg_has_role(oid, name, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, name, text) is 'user privilege on role by user oid, role name';

alter function pg_catalog.pg_has_role(oid, name, text) owner to "kim-uijin";

create function pg_catalog.pg_has_role(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, oid, text) is 'user privilege on role by user oid, role oid';

alter function pg_catalog.pg_has_role(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.pg_has_role(name, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(name, text, unknown) is 'current user privilege on role by role name';

alter function pg_catalog.pg_has_role(name, text, unknown) owner to "kim-uijin";

create function pg_catalog.pg_has_role(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_has_role(oid, text, unknown) is 'current user privilege on role by role oid';

alter function pg_catalog.pg_has_role(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.justify_interval(interval) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.justify_interval(interval) is 'promote groups of 24 hours to numbers of days and promote groups of 30 days to numbers of months';

alter function pg_catalog.justify_interval(interval) owner to "kim-uijin";

create function pg_catalog.pg_get_triggerdef(oid, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_triggerdef(oid, boolean) is 'trigger description with pretty-print option';

alter function pg_catalog.pg_get_triggerdef(oid, boolean) owner to "kim-uijin";

create function pg_catalog.asind(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.asind(double precision) is 'arcsine, degrees';

alter function pg_catalog.asind(double precision) owner to "kim-uijin";

create function pg_catalog.acosd(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acosd(double precision) is 'arccosine, degrees';

alter function pg_catalog.acosd(double precision) owner to "kim-uijin";

create function pg_catalog.atand(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atand(double precision) is 'arctangent, degrees';

alter function pg_catalog.atand(double precision) owner to "kim-uijin";

create function pg_catalog.atan2d(double precision, double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.atan2d(double precision, double precision) is 'arctangent, two arguments, degrees';

alter function pg_catalog.atan2d(double precision, double precision) owner to "kim-uijin";

create function pg_catalog.sind(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sind(double precision) is 'sine, degrees';

alter function pg_catalog.sind(double precision) owner to "kim-uijin";

create function pg_catalog.cosd(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cosd(double precision) is 'cosine, degrees';

alter function pg_catalog.cosd(double precision) owner to "kim-uijin";

create function pg_catalog.tand(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tand(double precision) is 'tangent, degrees';

alter function pg_catalog.tand(double precision) owner to "kim-uijin";

create function pg_catalog.cotd(double precision) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cotd(double precision) is 'cotangent, degrees';

alter function pg_catalog.cotd(double precision) owner to "kim-uijin";

create function pg_catalog.pg_stop_backup(exclusive boolean, wait_for_archive boolean default true, out lsn pg_lsn, out labelfile text, out spcmapfile text) returns setof setof record
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text) is 'finish taking an online backup';

alter function pg_catalog.pg_stop_backup(boolean, boolean, out pg_lsn, out text, out text) owner to "kim-uijin";

create function pg_catalog.numeric_avg_serialize(internal) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_avg_serialize(internal) owner to "kim-uijin";

create function pg_catalog.numeric_avg_deserialize(bytea, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_avg_deserialize(bytea, internal) owner to "kim-uijin";

create function pg_catalog.ginarrayextract(anyarray, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(anyarray, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarrayextract(anyarray, internal, internal) owner to "kim-uijin";

create function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.int8_avg_accum(internal, bigint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum(internal, bigint) owner to "kim-uijin";

create function pg_catalog.arrayoverlap(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arrayoverlap(anyarray, anyarray) is 'implementation of && operator';

alter function pg_catalog.arrayoverlap(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.arraycontains(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontains(anyarray, anyarray) is 'implementation of @> operator';

alter function pg_catalog.arraycontains(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.arraycontained(anyarray, anyarray) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontained(anyarray, anyarray) is 'implementation of <@ operator';

alter function pg_catalog.arraycontained(anyarray, anyarray) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_tuples_returned(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_returned(oid) is 'statistics: tuples returned for database';

alter function pg_catalog.pg_stat_get_db_tuples_returned(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_tuples_fetched(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_fetched(oid) is 'statistics: tuples fetched for database';

alter function pg_catalog.pg_stat_get_db_tuples_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_tuples_inserted(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_inserted(oid) is 'statistics: tuples inserted in database';

alter function pg_catalog.pg_stat_get_db_tuples_inserted(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_tuples_updated(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_updated(oid) is 'statistics: tuples updated in database';

alter function pg_catalog.pg_stat_get_db_tuples_updated(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_tuples_deleted(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_tuples_deleted(oid) is 'statistics: tuples deleted in database';

alter function pg_catalog.pg_stat_get_db_tuples_deleted(oid) owner to "kim-uijin";

create function pg_catalog.regexp_matches(text, text) returns setof setof text[]
    immutable
    strict
    parallel safe
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_matches(text, text) is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches(text, text) owner to "kim-uijin";

create function pg_catalog.regexp_matches(text, text, text) returns setof setof text[]
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_matches(text, text, text) is 'find match(es) for regexp';

alter function pg_catalog.regexp_matches(text, text, text) owner to "kim-uijin";

create function pg_catalog.regexp_split_to_table(text, text) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_split_to_table(text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text) owner to "kim-uijin";

create function pg_catalog.regexp_split_to_table(text, text, text) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.regexp_split_to_table(text, text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_table(text, text, text) owner to "kim-uijin";

create function pg_catalog.regexp_split_to_array(text, text) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text) owner to "kim-uijin";

create function pg_catalog.regexp_split_to_array(text, text, text) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_split_to_array(text, text, text) is 'split string by pattern';

alter function pg_catalog.regexp_split_to_array(text, text, text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() is 'statistics: number of timed checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_timed_checkpoints() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() is 'statistics: number of backend requested checkpoints started by the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_requested_checkpoints() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() is 'statistics: number of buffers written by the bgwriter during checkpoints';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_checkpoints() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() is 'statistics: number of buffers written by the bgwriter for cleaning dirty buffers';

alter function pg_catalog.pg_stat_get_bgwriter_buf_written_clean() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() is 'statistics: number of times the bgwriter stopped processing when it had written too many buffers while cleaning';

alter function pg_catalog.pg_stat_get_bgwriter_maxwritten_clean() owner to "kim-uijin";

create function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_buf_written_backend() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_written_backend() is 'statistics: number of buffers written by backends';

alter function pg_catalog.pg_stat_get_buf_written_backend() owner to "kim-uijin";

create function pg_catalog.anynonarray_in(cstring) returns anynonarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_in(cstring) is 'I/O';

alter function pg_catalog.anynonarray_in(cstring) owner to "kim-uijin";

create function pg_catalog.anynonarray_out(anynonarray) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anynonarray_out(anynonarray) is 'I/O';

alter function pg_catalog.anynonarray_out(anynonarray) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_last_vacuum_time(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_vacuum_time(oid) is 'statistics: last manual vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_vacuum_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_last_autovacuum_time(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autovacuum_time(oid) is 'statistics: last auto vacuum time for a table';

alter function pg_catalog.pg_stat_get_last_autovacuum_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_last_analyze_time(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_analyze_time(oid) is 'statistics: last manual analyze time for a table';

alter function pg_catalog.pg_stat_get_last_analyze_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) is 'statistics: last auto analyze time for a table';

alter function pg_catalog.pg_stat_get_last_autoanalyze_time(oid) owner to "kim-uijin";

create function pg_catalog.int8_avg_combine(internal, internal) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.int8_avg_combine(internal, internal) owner to "kim-uijin";

create function pg_catalog.int8_avg_serialize(internal) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.int8_avg_serialize(internal) owner to "kim-uijin";

create function pg_catalog.int8_avg_deserialize(bytea, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.int8_avg_deserialize(bytea, internal) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_wait_event_type(integer) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event_type(integer) is 'statistics: wait event type on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event_type(integer) owner to "kim-uijin";

create function pg_catalog.tidgt(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidgt(tid, tid) is 'implementation of > operator';

alter function pg_catalog.tidgt(tid, tid) owner to "kim-uijin";

create function pg_catalog.tidlt(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlt(tid, tid) is 'implementation of < operator';

alter function pg_catalog.tidlt(tid, tid) owner to "kim-uijin";

create function pg_catalog.tidge(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidge(tid, tid) is 'implementation of >= operator';

alter function pg_catalog.tidge(tid, tid) owner to "kim-uijin";

create function pg_catalog.tidle(tid, tid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidle(tid, tid) is 'implementation of <= operator';

alter function pg_catalog.tidle(tid, tid) owner to "kim-uijin";

create function pg_catalog.bttidcmp(tid, tid) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttidcmp(tid, tid) is 'less-equal-greater';

alter function pg_catalog.bttidcmp(tid, tid) owner to "kim-uijin";

create function pg_catalog.tidlarger(tid, tid) returns tid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidlarger(tid, tid) is 'larger of two';

alter function pg_catalog.tidlarger(tid, tid) owner to "kim-uijin";

create function pg_catalog.tidsmaller(tid, tid) returns tid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tidsmaller(tid, tid) is 'smaller of two';

alter function pg_catalog.tidsmaller(tid, tid) owner to "kim-uijin";

create function pg_catalog.int8inc_any(bigint, "any") returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_any(bigint, "any") is 'increment, ignores second argument';

alter function pg_catalog.int8inc_any(bigint, "any") owner to "kim-uijin";

create function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) is 'aggregate transition function';

alter function pg_catalog.int8inc_float8_float8(bigint, double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) returns double precision[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) is 'aggregate transition function';

alter function pg_catalog.float8_regr_accum(double precision[], double precision, double precision) owner to "kim-uijin";

create function pg_catalog.float8_regr_sxx(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxx(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_sxx(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_syy(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_syy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_syy(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_sxy(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_sxy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_sxy(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_avgx(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgx(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_avgx(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_avgy(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_avgy(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_avgy(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_r2(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_r2(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_r2(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_slope(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_slope(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_slope(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_regr_intercept(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_intercept(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_regr_intercept(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_covar_pop(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_pop(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_covar_pop(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_covar_samp(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_covar_samp(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_covar_samp(double precision[]) owner to "kim-uijin";

create function pg_catalog.float8_corr(double precision[]) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_corr(double precision[]) is 'aggregate final function';

alter function pg_catalog.float8_corr(double precision[]) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_blk_read_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_read_time(oid) is 'statistics: block read time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_read_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_blk_write_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_blk_write_time(oid) is 'statistics: block write time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_blk_write_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_switch_wal() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_switch_wal() is 'switch to new wal file';

alter function pg_catalog.pg_switch_wal() owner to "kim-uijin";

create function pg_catalog.pg_current_wal_lsn() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_lsn() is 'current wal write location';

alter function pg_catalog.pg_current_wal_lsn() owner to "kim-uijin";

create function pg_catalog.pg_walfile_name_offset(lsn pg_lsn, out file_name text, out file_offset integer) returns record
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer) is 'wal filename and byte offset, given a wal location';

alter function pg_catalog.pg_walfile_name_offset(pg_lsn, out text, out integer) owner to "kim-uijin";

create function pg_catalog.pg_walfile_name(pg_lsn) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_walfile_name(pg_lsn) is 'wal filename, given a wal location';

alter function pg_catalog.pg_walfile_name(pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_current_wal_insert_lsn() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_insert_lsn() is 'current wal insert location';

alter function pg_catalog.pg_current_wal_insert_lsn() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_wait_event(integer) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_wait_event(integer) is 'statistics: wait event on which backend is currently waiting';

alter function pg_catalog.pg_stat_get_backend_wait_event(integer) owner to "kim-uijin";

create function pg_catalog.pg_my_temp_schema() returns oid
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_my_temp_schema() is 'get OID of current session''s temp schema, if any';

alter function pg_catalog.pg_my_temp_schema() owner to "kim-uijin";

create function pg_catalog.pg_is_other_temp_schema(oid) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_other_temp_schema(oid) is 'is schema another session''s temp schema?';

alter function pg_catalog.pg_is_other_temp_schema(oid) owner to "kim-uijin";

create function pg_catalog.pg_timezone_names(out name text, out abbrev text, out utc_offset interval, out is_dst boolean) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean) is 'get the available time zone names';

alter function pg_catalog.pg_timezone_names(out text, out text, out interval, out boolean) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_backend_xact_start(integer) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_backend_xact_start(integer) is 'statistics: start time for backend''s current transaction';

alter function pg_catalog.pg_stat_get_backend_xact_start(integer) owner to "kim-uijin";

create function pg_catalog.numeric_avg_accum(internal, numeric) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_accum(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_avg_accum(internal, numeric) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_buf_alloc() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_alloc() is 'statistics: number of buffer allocations';

alter function pg_catalog.pg_stat_get_buf_alloc() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_live_tuples(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_live_tuples(oid) is 'statistics: number of live tuples';

alter function pg_catalog.pg_stat_get_live_tuples(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_dead_tuples(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_dead_tuples(oid) is 'statistics: number of dead tuples';

alter function pg_catalog.pg_stat_get_dead_tuples(oid) owner to "kim-uijin";

create function pg_catalog.pg_advisory_lock(bigint) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(bigint) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_lock_shared(bigint) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(bigint) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(bigint) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_lock(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(bigint) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(bigint) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_lock_shared(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(bigint) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_unlock(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(bigint) is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_unlock_shared(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(bigint) is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_lock(integer, integer) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock(integer, integer) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_lock(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_advisory_lock_shared(integer, integer) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_lock_shared(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_lock(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock(integer, integer) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_lock_shared(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_lock_shared(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_advisory_unlock(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock(integer, integer) is 'release exclusive advisory lock';

alter function pg_catalog.pg_advisory_unlock(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_advisory_unlock_shared(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_shared(integer, integer) is 'release shared advisory lock';

alter function pg_catalog.pg_advisory_unlock_shared(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_advisory_unlock_all() returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_unlock_all() is 'release all advisory locks';

alter function pg_catalog.pg_advisory_unlock_all() owner to "kim-uijin";

create function pg_catalog.xml_in(cstring) returns xml
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_in(cstring) is 'I/O';

alter function pg_catalog.xml_in(cstring) owner to "kim-uijin";

create function pg_catalog.xml_out(xml) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_out(xml) is 'I/O';

alter function pg_catalog.xml_out(xml) owner to "kim-uijin";

create function pg_catalog.xmlcomment(text) returns xml
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlcomment(text) is 'generate XML comment';

alter function pg_catalog.xmlcomment(text) owner to "kim-uijin";

create function pg_catalog.xml(text) returns xml
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml(text) is 'perform a non-validating parse of a character string to produce an XML value';

alter function pg_catalog.xml(text) owner to "kim-uijin";

create function pg_catalog.xmlvalidate(xml, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlvalidate(xml, text) is 'validate an XML value';

alter function pg_catalog.xmlvalidate(xml, text) owner to "kim-uijin";

create function pg_catalog.xml_recv(internal) returns xml
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_recv(internal) is 'I/O';

alter function pg_catalog.xml_recv(internal) owner to "kim-uijin";

create function pg_catalog.xml_send(xml) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_send(xml) is 'I/O';

alter function pg_catalog.xml_send(xml) owner to "kim-uijin";

create function pg_catalog.xmlconcat2(xml, xml) returns xml
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xmlconcat2(xml, xml) is 'aggregate transition function';

alter function pg_catalog.xmlconcat2(xml, xml) owner to "kim-uijin";

create function pg_catalog.varbittypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.varbittypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.intervaltypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.intervaltypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.intervaltypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.intervaltypmodout(integer) is 'I/O typmod';

alter function pg_catalog.intervaltypmodout(integer) owner to "kim-uijin";

create function pg_catalog.timestamptypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timestamptypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.timestamptypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timestamptypmodout(integer) owner to "kim-uijin";

create function pg_catalog.timestamptztypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timestamptztypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.timestamptztypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamptztypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timestamptztypmodout(integer) owner to "kim-uijin";

create function pg_catalog.timetypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timetypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.timetypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timetypmodout(integer) owner to "kim-uijin";

create function pg_catalog.timetztypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.timetztypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.timetztypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetztypmodout(integer) is 'I/O typmod';

alter function pg_catalog.timetztypmodout(integer) owner to "kim-uijin";

create function pg_catalog.bpchartypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.bpchartypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.bpchartypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchartypmodout(integer) is 'I/O typmod';

alter function pg_catalog.bpchartypmodout(integer) owner to "kim-uijin";

create function pg_catalog.varchartypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.varchartypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.varchartypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchartypmodout(integer) is 'I/O typmod';

alter function pg_catalog.varchartypmodout(integer) owner to "kim-uijin";

create function pg_catalog.numerictypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.numerictypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.numerictypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numerictypmodout(integer) is 'I/O typmod';

alter function pg_catalog.numerictypmodout(integer) owner to "kim-uijin";

create function pg_catalog.bittypmodin(cstring[]) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodin(cstring[]) is 'I/O typmod';

alter function pg_catalog.bittypmodin(cstring[]) owner to "kim-uijin";

create function pg_catalog.bittypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bittypmodout(integer) is 'I/O typmod';

alter function pg_catalog.bittypmodout(integer) owner to "kim-uijin";

create function pg_catalog.varbittypmodout(integer) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbittypmodout(integer) is 'I/O typmod';

alter function pg_catalog.varbittypmodout(integer) owner to "kim-uijin";

create function pg_catalog.text(xml) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(xml) is 'serialize an XML value to a character string';

alter function pg_catalog.text(xml) owner to "kim-uijin";

create function pg_catalog.table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml(regclass, boolean, boolean, text) is 'map table contents to XML';

alter function pg_catalog.table_to_xml(regclass, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.query_to_xml(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml(text, boolean, boolean, text) is 'map query result to XML';

alter function pg_catalog.query_to_xml(text, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.cursor_to_xml(cursor refcursor, count integer, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) is 'map rows from cursor to XML';

alter function pg_catalog.cursor_to_xml(refcursor, integer, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) is 'map table structure to XML Schema';

alter function pg_catalog.table_to_xmlschema(regclass, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xmlschema(text, boolean, boolean, text) is 'map query result structure to XML Schema';

alter function pg_catalog.query_to_xmlschema(text, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) is 'map cursor structure to XML Schema';

alter function pg_catalog.cursor_to_xmlschema(refcursor, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) is 'map table contents and structure to XML and XML Schema';

alter function pg_catalog.table_to_xml_and_xmlschema(regclass, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, targetns text) returns xml
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) is 'map query result and structure to XML and XML Schema';

alter function pg_catalog.query_to_xml_and_xmlschema(text, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath(text, xml, text[]) is 'evaluate XPath expression, with namespaces support';

alter function pg_catalog.xpath(text, xml, text[]) owner to "kim-uijin";

create function pg_catalog.xpath(text, xml) returns xml[]
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN xpath($1, $2, '{}'::text[]);

comment on function pg_catalog.xpath(text, xml, unknown) is 'evaluate XPath expression';

alter function pg_catalog.xpath(text, xml, unknown) owner to "kim-uijin";

create function pg_catalog.schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml(name, boolean, boolean, text) is 'map schema contents to XML';

alter function pg_catalog.schema_to_xml(name, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) is 'map schema structure to XML Schema';

alter function pg_catalog.schema_to_xmlschema(name, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) is 'map schema contents and structure to XML and XML Schema';

alter function pg_catalog.schema_to_xml_and_xmlschema(name, boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.database_to_xml(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml(boolean, boolean, text) is 'map database contents to XML';

alter function pg_catalog.database_to_xml(boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.database_to_xmlschema(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xmlschema(boolean, boolean, text) is 'map database structure to XML Schema';

alter function pg_catalog.database_to_xmlschema(boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns text) returns xml
    stable
    strict
    parallel restricted
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) is 'map database contents and structure to XML and XML Schema';

alter function pg_catalog.database_to_xml_and_xmlschema(boolean, boolean, text) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_in(cstring) returns txid_snapshot
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_in(cstring) is 'I/O';

alter function pg_catalog.txid_snapshot_in(cstring) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_out(txid_snapshot) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_out(txid_snapshot) is 'I/O';

alter function pg_catalog.txid_snapshot_out(txid_snapshot) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_recv(internal) returns txid_snapshot
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_recv(internal) is 'I/O';

alter function pg_catalog.txid_snapshot_recv(internal) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_send(txid_snapshot) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_send(txid_snapshot) is 'I/O';

alter function pg_catalog.txid_snapshot_send(txid_snapshot) owner to "kim-uijin";

create function pg_catalog.txid_current() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current() is 'get current transaction ID';

alter function pg_catalog.txid_current() owner to "kim-uijin";

create function pg_catalog.txid_current_snapshot() returns txid_snapshot
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_snapshot() is 'get current snapshot';

alter function pg_catalog.txid_current_snapshot() owner to "kim-uijin";

create function pg_catalog.txid_snapshot_xmin(txid_snapshot) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmin(txid_snapshot) is 'get xmin of snapshot';

alter function pg_catalog.txid_snapshot_xmin(txid_snapshot) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_xmax(txid_snapshot) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_snapshot_xmax(txid_snapshot) is 'get xmax of snapshot';

alter function pg_catalog.txid_snapshot_xmax(txid_snapshot) owner to "kim-uijin";

create function pg_catalog.txid_snapshot_xip(txid_snapshot) returns setof setof bigint
    immutable
    strict
    parallel safe
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.txid_snapshot_xip(txid_snapshot) is 'get set of in-progress txids in snapshot';

alter function pg_catalog.txid_snapshot_xip(txid_snapshot) owner to "kim-uijin";

create function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) is 'is txid visible in snapshot?';

alter function pg_catalog.txid_visible_in_snapshot(bigint, txid_snapshot) owner to "kim-uijin";

create function pg_catalog.uuid_in(cstring) returns uuid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_in(cstring) is 'I/O';

alter function pg_catalog.uuid_in(cstring) owner to "kim-uijin";

create function pg_catalog.uuid_out(uuid) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_out(uuid) is 'I/O';

alter function pg_catalog.uuid_out(uuid) owner to "kim-uijin";

create function pg_catalog.uuid_lt(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_lt(uuid, uuid) is 'implementation of < operator';

alter function pg_catalog.uuid_lt(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_le(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_le(uuid, uuid) is 'implementation of <= operator';

alter function pg_catalog.uuid_le(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_eq(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_eq(uuid, uuid) is 'implementation of = operator';

alter function pg_catalog.uuid_eq(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_ge(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ge(uuid, uuid) is 'implementation of >= operator';

alter function pg_catalog.uuid_ge(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_gt(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_gt(uuid, uuid) is 'implementation of > operator';

alter function pg_catalog.uuid_gt(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_ne(uuid, uuid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_ne(uuid, uuid) is 'implementation of <> operator';

alter function pg_catalog.uuid_ne(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_cmp(uuid, uuid) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_cmp(uuid, uuid) is 'less-equal-greater';

alter function pg_catalog.uuid_cmp(uuid, uuid) owner to "kim-uijin";

create function pg_catalog.uuid_recv(internal) returns uuid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_recv(internal) is 'I/O';

alter function pg_catalog.uuid_recv(internal) owner to "kim-uijin";

create function pg_catalog.uuid_send(uuid) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_send(uuid) is 'I/O';

alter function pg_catalog.uuid_send(uuid) owner to "kim-uijin";

create function pg_catalog.uuid_hash(uuid) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash(uuid) is 'hash';

alter function pg_catalog.uuid_hash(uuid) owner to "kim-uijin";

create function pg_catalog.text(boolean) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.text(boolean) is 'convert boolean to text';

alter function pg_catalog.text(boolean) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_function_calls(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_calls(oid) is 'statistics: number of function calls';

alter function pg_catalog.pg_stat_get_function_calls(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_function_total_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_total_time(oid) is 'statistics: total execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_total_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_function_self_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_function_self_time(oid) is 'statistics: self execution time of function, in milliseconds';

alter function pg_catalog.pg_stat_get_function_self_time(oid) owner to "kim-uijin";

create function pg_catalog.record_eq(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_eq(record, record) is 'implementation of = operator';

alter function pg_catalog.record_eq(record, record) owner to "kim-uijin";

create function pg_catalog.record_ne(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ne(record, record) is 'implementation of <> operator';

alter function pg_catalog.record_ne(record, record) owner to "kim-uijin";

create function pg_catalog.record_lt(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_lt(record, record) is 'implementation of < operator';

alter function pg_catalog.record_lt(record, record) owner to "kim-uijin";

create function pg_catalog.record_gt(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_gt(record, record) is 'implementation of > operator';

alter function pg_catalog.record_gt(record, record) owner to "kim-uijin";

create function pg_catalog.record_le(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_le(record, record) is 'implementation of <= operator';

alter function pg_catalog.record_le(record, record) owner to "kim-uijin";

create function pg_catalog.record_ge(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_ge(record, record) is 'implementation of >= operator';

alter function pg_catalog.record_ge(record, record) owner to "kim-uijin";

create function pg_catalog.btrecordcmp(record, record) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordcmp(record, record) is 'less-equal-greater';

alter function pg_catalog.btrecordcmp(record, record) owner to "kim-uijin";

create function pg_catalog.pg_table_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_table_size(regclass) is 'disk space usage for the specified table, including TOAST, free space and visibility map';

alter function pg_catalog.pg_table_size(regclass) owner to "kim-uijin";

create function pg_catalog.pg_indexes_size(regclass) returns bigint
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_indexes_size(regclass) is 'disk space usage for all indexes attached to the specified table';

alter function pg_catalog.pg_indexes_size(regclass) owner to "kim-uijin";

create function pg_catalog.pg_relation_filenode(regclass) returns oid
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filenode(regclass) is 'filenode identifier of relation';

alter function pg_catalog.pg_relation_filenode(regclass) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) is 'user privilege on foreign data wrapper by username, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) is 'user privilege on foreign data wrapper by user oid, foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(text, text, unknown) is 'current user privilege on foreign data wrapper by foreign data wrapper name';

alter function pg_catalog.has_foreign_data_wrapper_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, unknown) is 'current user privilege on foreign data wrapper by foreign data wrapper oid';

alter function pg_catalog.has_foreign_data_wrapper_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, text, text) is 'user privilege on server by username, server name';

alter function pg_catalog.has_server_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(name, oid, text) is 'user privilege on server by username, server oid';

alter function pg_catalog.has_server_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, text, text) is 'user privilege on server by user oid, server name';

alter function pg_catalog.has_server_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, oid, text) is 'user privilege on server by user oid, server oid';

alter function pg_catalog.has_server_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(text, text, unknown) is 'current user privilege on server by server name';

alter function pg_catalog.has_server_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_server_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_server_privilege(oid, text, unknown) is 'current user privilege on server by server oid';

alter function pg_catalog.has_server_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(name, text, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, text, text, text) is 'user privilege on column by username, rel name, col name';

alter function pg_catalog.has_column_privilege(name, text, text, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(name, text, smallint, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, text, smallint, text) is 'user privilege on column by username, rel name, col attnum';

alter function pg_catalog.has_column_privilege(name, text, smallint, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(name, oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, text, text) is 'user privilege on column by username, rel oid, col name';

alter function pg_catalog.has_column_privilege(name, oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(name, oid, smallint, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(name, oid, smallint, text) is 'user privilege on column by username, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(name, oid, smallint, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, text, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, text, text) is 'user privilege on column by user oid, rel name, col name';

alter function pg_catalog.has_column_privilege(oid, text, text, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, text, smallint, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, smallint, text) is 'user privilege on column by user oid, rel name, col attnum';

alter function pg_catalog.has_column_privilege(oid, text, smallint, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, oid, text, text) is 'user privilege on column by user oid, rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, oid, smallint, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, oid, smallint, text) is 'user privilege on column by user oid, rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, oid, smallint, text) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(text, text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, text, text, unknown) is 'current user privilege on column by rel name, col name';

alter function pg_catalog.has_column_privilege(text, text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(text, smallint, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(text, smallint, text, unknown) is 'current user privilege on column by rel name, col attnum';

alter function pg_catalog.has_column_privilege(text, smallint, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, text, text, unknown) is 'current user privilege on column by rel oid, col name';

alter function pg_catalog.has_column_privilege(oid, text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_column_privilege(oid, smallint, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_column_privilege(oid, smallint, text, unknown) is 'current user privilege on column by rel oid, col attnum';

alter function pg_catalog.has_column_privilege(oid, smallint, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, text, text) is 'user privilege on any column by username, rel name';

alter function pg_catalog.has_any_column_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(name, oid, text) is 'user privilege on any column by username, rel oid';

alter function pg_catalog.has_any_column_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, text, text) is 'user privilege on any column by user oid, rel name';

alter function pg_catalog.has_any_column_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, oid, text) is 'user privilege on any column by user oid, rel oid';

alter function pg_catalog.has_any_column_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(text, text, unknown) is 'current user privilege on any column by rel name';

alter function pg_catalog.has_any_column_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_any_column_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_any_column_privilege(oid, text, unknown) is 'current user privilege on any column by rel oid';

alter function pg_catalog.has_any_column_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.overlay(bit, bit, integer, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit, integer, integer) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer, integer) owner to "kim-uijin";

create function pg_catalog.overlay(bit, bit, integer, unknown) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.overlay(bit, bit, integer, unknown) is 'substitute portion of bitstring';

alter function pg_catalog.overlay(bit, bit, integer, unknown) owner to "kim-uijin";

create function pg_catalog.get_bit(bit, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_bit(bit, integer) is 'get bit';

alter function pg_catalog.get_bit(bit, integer) owner to "kim-uijin";

create function pg_catalog.set_bit(bit, integer, integer) returns bit
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.set_bit(bit, integer, integer) is 'set bit';

alter function pg_catalog.set_bit(bit, integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_relation_filepath(regclass) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_filepath(regclass) is 'file path of relation';

alter function pg_catalog.pg_relation_filepath(regclass) owner to "kim-uijin";

create function pg_catalog.pg_listening_channels() returns setof setof text
    stable
    strict
    parallel restricted
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_listening_channels() is 'get the channels that the current backend listens to';

alter function pg_catalog.pg_listening_channels() owner to "kim-uijin";

create function pg_catalog.pg_notify(text, text) returns void
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notify(text, text) is 'send a notification event';

alter function pg_catalog.pg_notify(text, text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_numscans(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_numscans(oid) is 'statistics: number of scans done for table/index in current transaction';

alter function pg_catalog.pg_stat_get_xact_numscans(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_returned(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_returned(oid) is 'statistics: number of tuples read by seqscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_returned(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) is 'statistics: number of tuples fetched by idxscan in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) is 'statistics: number of tuples inserted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_inserted(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_updated(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_updated(oid) is 'statistics: number of tuples updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_updated(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) is 'statistics: number of tuples deleted in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_deleted(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) is 'statistics: number of tuples hot updated in current transaction';

alter function pg_catalog.pg_stat_get_xact_tuples_hot_updated(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) is 'statistics: number of blocks fetched in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_fetched(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_blocks_hit(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_blocks_hit(oid) is 'statistics: number of blocks found in cache in current transaction';

alter function pg_catalog.pg_stat_get_xact_blocks_hit(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_function_calls(oid) returns bigint
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_calls(oid) is 'statistics: number of function calls in current transaction';

alter function pg_catalog.pg_stat_get_xact_function_calls(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_function_total_time(oid) returns double precision
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_total_time(oid) is 'statistics: total execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_total_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_xact_function_self_time(oid) returns double precision
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_xact_function_self_time(oid) is 'statistics: self execution time of function in current transaction, in milliseconds';

alter function pg_catalog.pg_stat_get_xact_function_self_time(oid) owner to "kim-uijin";

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xpath_exists(text, xml, text[]) is 'test XML value against XPath expression, with namespace support';

alter function pg_catalog.xpath_exists(text, xml, text[]) owner to "kim-uijin";

create function pg_catalog.xpath_exists(text, xml) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN xpath_exists($1, $2, '{}'::text[]);

comment on function pg_catalog.xpath_exists(text, xml, unknown) is 'test XML value against XPath expression';

alter function pg_catalog.xpath_exists(text, xml, unknown) owner to "kim-uijin";

create function pg_catalog.xml_is_well_formed(text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed(text) is 'determine if a string is well formed XML';

alter function pg_catalog.xml_is_well_formed(text) owner to "kim-uijin";

create function pg_catalog.xml_is_well_formed_document(text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_document(text) is 'determine if a string is well formed XML document';

alter function pg_catalog.xml_is_well_formed_document(text) owner to "kim-uijin";

create function pg_catalog.xml_is_well_formed_content(text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xml_is_well_formed_content(text) is 'determine if a string is well formed XML content';

alter function pg_catalog.xml_is_well_formed_content(text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_vacuum_count(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_vacuum_count(oid) is 'statistics: number of manual vacuums for a table';

alter function pg_catalog.pg_stat_get_vacuum_count(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_autovacuum_count(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autovacuum_count(oid) is 'statistics: number of auto vacuums for a table';

alter function pg_catalog.pg_stat_get_autovacuum_count(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_analyze_count(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_analyze_count(oid) is 'statistics: number of manual analyzes for a table';

alter function pg_catalog.pg_stat_get_analyze_count(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_autoanalyze_count(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_autoanalyze_count(oid) is 'statistics: number of auto analyzes for a table';

alter function pg_catalog.pg_stat_get_autoanalyze_count(oid) owner to "kim-uijin";

create function pg_catalog.concat("any") returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat("any") is 'concatenate values';

alter function pg_catalog.concat("any") owner to "kim-uijin";

create function pg_catalog.concat_ws(text, "any") returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.concat_ws(text, "any") is 'concatenate values with separators';

alter function pg_catalog.concat_ws(text, "any") owner to "kim-uijin";

create function pg_catalog."left"(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."left"(text, integer) is 'extract the first n characters';

alter function pg_catalog."left"(text, integer) owner to "kim-uijin";

create function pg_catalog."right"(text, integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog."right"(text, integer) is 'extract the last n characters';

alter function pg_catalog."right"(text, integer) owner to "kim-uijin";

create function pg_catalog.reverse(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.reverse(text) is 'reverse text';

alter function pg_catalog.reverse(text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_buf_fsync_backend() returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_buf_fsync_backend() is 'statistics: number of backend buffer writes that did their own fsync';

alter function pg_catalog.pg_stat_get_buf_fsync_backend() owner to "kim-uijin";

create function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_point_distance(internal, point, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) is 'statistics: recovery conflicts in database caused by drop tablespace';

alter function pg_catalog.pg_stat_get_db_conflict_tablespace(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_lock(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_lock(oid) is 'statistics: recovery conflicts in database caused by relation lock';

alter function pg_catalog.pg_stat_get_db_conflict_lock(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) is 'statistics: recovery conflicts in database caused by snapshot expiry';

alter function pg_catalog.pg_stat_get_db_conflict_snapshot(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) is 'statistics: recovery conflicts in database caused by shared buffer pin';

alter function pg_catalog.pg_stat_get_db_conflict_bufferpin(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) is 'statistics: recovery conflicts in database caused by buffer deadlock';

alter function pg_catalog.pg_stat_get_db_conflict_startup_deadlock(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_conflict_all(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_conflict_all(oid) is 'statistics: recovery conflicts in database';

alter function pg_catalog.pg_stat_get_db_conflict_all(oid) owner to "kim-uijin";

create function pg_catalog.pg_wal_replay_pause() returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_pause() is 'pause wal replay';

alter function pg_catalog.pg_wal_replay_pause() owner to "kim-uijin";

create function pg_catalog.pg_wal_replay_resume() returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_replay_resume() is 'resume wal replay, if it was paused';

alter function pg_catalog.pg_wal_replay_resume() owner to "kim-uijin";

create function pg_catalog.pg_is_wal_replay_paused() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_wal_replay_paused() is 'true if wal replay is paused';

alter function pg_catalog.pg_is_wal_replay_paused() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_stat_reset_time(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_stat_reset_time(oid) is 'statistics: last reset for a database';

alter function pg_catalog.pg_stat_get_db_stat_reset_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() is 'statistics: last reset for the bgwriter';

alter function pg_catalog.pg_stat_get_bgwriter_stat_reset_time() owner to "kim-uijin";

create function pg_catalog.ginarrayextract(anyarray, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarrayextract(anyarray, internal) is 'GIN array support (obsolete)';

alter function pg_catalog.ginarrayextract(anyarray, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_tsvector(tsvector, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal) owner to "kim-uijin";

create function pg_catalog.pg_sequence_parameters(sequence_oid oid, out start_value bigint, out minimum_value bigint, out maximum_value bigint, out increment bigint, out cycle_option boolean, out cache_size bigint, out data_type oid) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean, out bigint, out oid) is 'sequence parameters, for use by information schema';

alter function pg_catalog.pg_sequence_parameters(oid, out bigint, out bigint, out bigint, out bigint, out boolean, out bigint, out oid) owner to "kim-uijin";

create function pg_catalog.pg_available_extensions(out name name, out default_version text, out comment text) returns setof setof record
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_available_extensions(out name, out text, out text) is 'list available extensions';

alter function pg_catalog.pg_available_extensions(out name, out text, out text) owner to "kim-uijin";

create function pg_catalog.pg_available_extension_versions(out name name, out version text, out superuser boolean, out trusted boolean, out relocatable boolean, out schema name, out requires name[], out comment text) returns setof setof record
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out boolean, out name, out name[], out text) is 'list available extension versions';

alter function pg_catalog.pg_available_extension_versions(out name, out text, out boolean, out boolean, out boolean, out name, out name[], out text) owner to "kim-uijin";

create function pg_catalog.pg_extension_update_paths(name name, out source text, out target text, out path text) returns setof setof record
    stable
    strict
    parallel safe
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_extension_update_paths(name, out text, out text, out text) is 'list an extension''s version update paths';

alter function pg_catalog.pg_extension_update_paths(name, out text, out text, out text) owner to "kim-uijin";

create function pg_catalog.pg_extension_config_dump(regclass, text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_extension_config_dump(regclass, text) is 'flag an extension''s table contents to be emitted by pg_dump';

alter function pg_catalog.pg_extension_config_dump(regclass, text) owner to "kim-uijin";

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, unknown, unknown) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, unknown, unknown) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, unknown, unknown) owner to "kim-uijin";

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, unknown, unknown) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, unknown, unknown) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, unknown, unknown) owner to "kim-uijin";

create function pg_catalog.pg_advisory_xact_lock(bigint) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_xact_lock_shared(bigint) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(bigint) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_xact_lock(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(bigint) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(bigint) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(bigint) owner to "kim-uijin";

create function pg_catalog.pg_advisory_xact_lock(integer, integer) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock';

alter function pg_catalog.pg_advisory_xact_lock(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock';

alter function pg_catalog.pg_advisory_xact_lock_shared(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_xact_lock(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock(integer, integer) is 'obtain exclusive advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock(integer, integer) owner to "kim-uijin";

create function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) is 'obtain shared advisory lock if available';

alter function pg_catalog.pg_try_advisory_xact_lock_shared(integer, integer) owner to "kim-uijin";

create function pg_catalog.varchar_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varchar_support(internal) is 'planner support for varchar length coercion';

alter function pg_catalog.varchar_support(internal) owner to "kim-uijin";

create function pg_catalog.pg_create_restore_point(text) returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_restore_point(text) is 'create a named restore point';

alter function pg_catalog.pg_create_restore_point(text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_wal_senders(out pid integer, out state text, out sent_lsn pg_lsn, out write_lsn pg_lsn, out flush_lsn pg_lsn, out replay_lsn pg_lsn, out write_lag interval, out flush_lag interval, out replay_lag interval, out sync_priority integer, out sync_state text, out reply_time timestamp with time zone) returns setof setof record
    stable
    parallel restricted
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out interval, out interval, out interval, out integer, out text, out timestamp with time zone) is 'statistics: information about currently active replication';

alter function pg_catalog.pg_stat_get_wal_senders(out integer, out text, out pg_lsn, out pg_lsn, out pg_lsn, out pg_lsn, out interval, out interval, out interval, out integer, out text, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.row_number() returns bigint
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_number() is 'row number within partition';

alter function pg_catalog.row_number() owner to "kim-uijin";

create function pg_catalog.rank() returns bigint
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank() is 'integer rank with gaps';

alter function pg_catalog.rank() owner to "kim-uijin";

create function pg_catalog.dense_rank() returns bigint
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank() is 'integer rank without gaps';

alter function pg_catalog.dense_rank() owner to "kim-uijin";

create function pg_catalog.percent_rank() returns double precision
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank() is 'fractional rank within partition';

alter function pg_catalog.percent_rank() owner to "kim-uijin";

create function pg_catalog.cume_dist() returns double precision
    immutable
    window
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist() is 'fractional row number within partition';

alter function pg_catalog.cume_dist() owner to "kim-uijin";

create function pg_catalog.ntile(integer) returns integer
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ntile(integer) is 'split rows into N groups';

alter function pg_catalog.ntile(integer) owner to "kim-uijin";

create function pg_catalog.lag(anyelement, unknown) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anyelement, unknown) is 'fetch the preceding row value';

alter function pg_catalog.lag(anyelement, unknown) owner to "kim-uijin";

create function pg_catalog.lag(anyelement, integer) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anyelement, integer) is 'fetch the Nth preceding row value';

alter function pg_catalog.lag(anyelement, integer) owner to "kim-uijin";

create function pg_catalog.lag(anycompatible, integer, anycompatible) returns anycompatible
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lag(anycompatible, integer, anycompatible) is 'fetch the Nth preceding row value with default';

alter function pg_catalog.lag(anycompatible, integer, anycompatible) owner to "kim-uijin";

create function pg_catalog.lead(anyelement, unknown) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anyelement, unknown) is 'fetch the following row value';

alter function pg_catalog.lead(anyelement, unknown) owner to "kim-uijin";

create function pg_catalog.lead(anyelement, integer) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anyelement, integer) is 'fetch the Nth following row value';

alter function pg_catalog.lead(anyelement, integer) owner to "kim-uijin";

create function pg_catalog.lead(anycompatible, integer, anycompatible) returns anycompatible
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lead(anycompatible, integer, anycompatible) is 'fetch the Nth following row value with default';

alter function pg_catalog.lead(anycompatible, integer, anycompatible) owner to "kim-uijin";

create function pg_catalog.first_value(anyelement) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.first_value(anyelement) is 'fetch the first row value';

alter function pg_catalog.first_value(anyelement) owner to "kim-uijin";

create function pg_catalog.last_value(anyelement) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.last_value(anyelement) is 'fetch the last row value';

alter function pg_catalog.last_value(anyelement) owner to "kim-uijin";

create function pg_catalog.nth_value(anyelement, integer) returns anyelement
    immutable
    window
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nth_value(anyelement, integer) is 'fetch the Nth row value';

alter function pg_catalog.nth_value(anyelement, integer) owner to "kim-uijin";

create function pg_catalog.fdw_handler_in(cstring) returns fdw_handler
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_in(cstring) is 'I/O';

alter function pg_catalog.fdw_handler_in(cstring) owner to "kim-uijin";

create function pg_catalog.fdw_handler_out(fdw_handler) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.fdw_handler_out(fdw_handler) is 'I/O';

alter function pg_catalog.fdw_handler_out(fdw_handler) owner to "kim-uijin";

create function pg_catalog.void_recv(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_recv(internal) is 'I/O';

alter function pg_catalog.void_recv(internal) owner to "kim-uijin";

create function pg_catalog.void_send(void) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.void_send(void) is 'I/O';

alter function pg_catalog.void_send(void) owner to "kim-uijin";

create function pg_catalog.btint2sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint2sortsupport(internal) is 'sort support';

alter function pg_catalog.btint2sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btint4sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint4sortsupport(internal) is 'sort support';

alter function pg_catalog.btint4sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btint8sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btint8sortsupport(internal) is 'sort support';

alter function pg_catalog.btint8sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btfloat4sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat4sortsupport(internal) is 'sort support';

alter function pg_catalog.btfloat4sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btfloat8sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btfloat8sortsupport(internal) is 'sort support';

alter function pg_catalog.btfloat8sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btoidsortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btoidsortsupport(internal) is 'sort support';

alter function pg_catalog.btoidsortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btnamesortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btnamesortsupport(internal) is 'sort support';

alter function pg_catalog.btnamesortsupport(internal) owner to "kim-uijin";

create function pg_catalog.date_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_sortsupport(internal) is 'sort support';

alter function pg_catalog.date_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.timestamp_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_sortsupport(internal) is 'sort support';

alter function pg_catalog.timestamp_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(name, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, text, text) is 'user privilege on type by username, type name';

alter function pg_catalog.has_type_privilege(name, text, text) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(name, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(name, oid, text) is 'user privilege on type by username, type oid';

alter function pg_catalog.has_type_privilege(name, oid, text) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(oid, text, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, text, text) is 'user privilege on type by user oid, type name';

alter function pg_catalog.has_type_privilege(oid, text, text) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(oid, oid, text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, oid, text) is 'user privilege on type by user oid, type oid';

alter function pg_catalog.has_type_privilege(oid, oid, text) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(text, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(text, text, unknown) is 'current user privilege on type by type name';

alter function pg_catalog.has_type_privilege(text, text, unknown) owner to "kim-uijin";

create function pg_catalog.has_type_privilege(oid, text, unknown) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.has_type_privilege(oid, text, unknown) is 'current user privilege on type by type oid';

alter function pg_catalog.has_type_privilege(oid, text, unknown) owner to "kim-uijin";

create function pg_catalog.macaddr_not(macaddr) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_not(macaddr) is 'implementation of ~ operator';

alter function pg_catalog.macaddr_not(macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_and(macaddr, macaddr) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_and(macaddr, macaddr) is 'implementation of & operator';

alter function pg_catalog.macaddr_and(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr_or(macaddr, macaddr) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_or(macaddr, macaddr) is 'implementation of | operator';

alter function pg_catalog.macaddr_or(macaddr, macaddr) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_temp_files(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_files(oid) is 'statistics: number of temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_files(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_temp_bytes(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_temp_bytes(oid) is 'statistics: number of bytes in temporary files written';

alter function pg_catalog.pg_stat_get_db_temp_bytes(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_deadlocks(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_deadlocks(oid) is 'statistics: deadlocks detected in database';

alter function pg_catalog.pg_stat_get_db_deadlocks(oid) owner to "kim-uijin";

create function pg_catalog.array_to_json(anyarray) returns json
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(anyarray) is 'map array to json';

alter function pg_catalog.array_to_json(anyarray) owner to "kim-uijin";

create function pg_catalog.array_to_json(anyarray, boolean) returns json
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_json(anyarray, boolean) is 'map array to json with optional pretty printing';

alter function pg_catalog.array_to_json(anyarray, boolean) owner to "kim-uijin";

create function pg_catalog.row_to_json(record) returns json
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(record) is 'map row to json';

alter function pg_catalog.row_to_json(record) owner to "kim-uijin";

create function pg_catalog.row_to_json(record, boolean) returns json
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_to_json(record, boolean) is 'map row to json with optional pretty printing';

alter function pg_catalog.row_to_json(record, boolean) owner to "kim-uijin";

create function pg_catalog.numeric_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_support(internal) is 'planner support for numeric length coercion';

alter function pg_catalog.numeric_support(internal) owner to "kim-uijin";

create function pg_catalog.varbit_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.varbit_support(internal) is 'planner support for varbit length coercion';

alter function pg_catalog.varbit_support(internal) owner to "kim-uijin";

create function pg_catalog.pg_get_viewdef(oid, integer) returns text
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_viewdef(oid, integer) is 'select statement of a view with pretty-printing and specified line wrapping';

alter function pg_catalog.pg_get_viewdef(oid, integer) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_checkpoint_write_time() returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_write_time() is 'statistics: checkpoint time spent writing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_write_time() owner to "kim-uijin";

create function pg_catalog.pg_stat_get_checkpoint_sync_time() returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_checkpoint_sync_time() is 'statistics: checkpoint time spent synchronizing buffers to disk, in milliseconds';

alter function pg_catalog.pg_stat_get_checkpoint_sync_time() owner to "kim-uijin";

create function pg_catalog.pg_collation_for("any") returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_for("any") is 'collation of the argument; implementation of the COLLATION FOR expression';

alter function pg_catalog.pg_collation_for("any") owner to "kim-uijin";

create function pg_catalog.pg_trigger_depth() returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_trigger_depth() is 'current trigger depth';

alter function pg_catalog.pg_trigger_depth() owner to "kim-uijin";

create function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) is 'difference in bytes, given two wal locations';

alter function pg_catalog.pg_wal_lsn_diff(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_size_pretty(numeric) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_pretty(numeric) is 'convert a numeric to a human readable text using size units';

alter function pg_catalog.pg_size_pretty(numeric) owner to "kim-uijin";

create function pg_catalog.array_remove(anycompatiblearray, anycompatible) returns anycompatiblearray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_remove(anycompatiblearray, anycompatible) is 'remove any occurrences of an element from an array';

alter function pg_catalog.array_remove(anycompatiblearray, anycompatible) owner to "kim-uijin";

create function pg_catalog.array_replace(anycompatiblearray, anycompatible, anycompatible) returns anycompatiblearray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_replace(anycompatiblearray, anycompatible, anycompatible) is 'replace any occurrences of an element in an array';

alter function pg_catalog.array_replace(anycompatiblearray, anycompatible, anycompatible) owner to "kim-uijin";

create function pg_catalog.rangesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rangesel(internal, oid, internal, integer) is 'restriction selectivity for range operators';

alter function pg_catalog.rangesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.lo_lseek64(integer, bigint, integer) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_lseek64(integer, bigint, integer) is 'large object seek (64 bit)';

alter function pg_catalog.lo_lseek64(integer, bigint, integer) owner to "kim-uijin";

create function pg_catalog.lo_tell64(integer) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_tell64(integer) is 'large object position (64 bit)';

alter function pg_catalog.lo_tell64(integer) owner to "kim-uijin";

create function pg_catalog.lo_truncate64(integer, bigint) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_truncate64(integer, bigint) is 'truncate large object (64 bit)';

alter function pg_catalog.lo_truncate64(integer, bigint) owner to "kim-uijin";

create function pg_catalog.json_agg_transfn(internal, anyelement) returns internal
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_transfn(internal, anyelement) is 'json aggregate transition function';

alter function pg_catalog.json_agg_transfn(internal, anyelement) owner to "kim-uijin";

create function pg_catalog.json_agg_finalfn(internal) returns json
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_agg_finalfn(internal) is 'json aggregate final function';

alter function pg_catalog.json_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.to_json(anyelement) returns json
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_json(anyelement) is 'map input to json';

alter function pg_catalog.to_json(anyelement) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_mod_since_analyze(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_mod_since_analyze(oid) is 'statistics: number of tuples changed since last analyze';

alter function pg_catalog.pg_stat_get_mod_since_analyze(oid) owner to "kim-uijin";

create function pg_catalog.numeric_sum(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sum(internal) is 'aggregate final function';

alter function pg_catalog.numeric_sum(internal) owner to "kim-uijin";

create function pg_catalog.cardinality(anyarray) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cardinality(anyarray) is 'array cardinality';

alter function pg_catalog.cardinality(anyarray) owner to "kim-uijin";

create function pg_catalog.json_object_agg_transfn(internal, "any", "any") returns internal
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_transfn(internal, "any", "any") is 'json object aggregate transition function';

alter function pg_catalog.json_object_agg_transfn(internal, "any", "any") owner to "kim-uijin";

create function pg_catalog.record_image_eq(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_eq(record, record) is 'implementation of *= operator';

alter function pg_catalog.record_image_eq(record, record) owner to "kim-uijin";

create function pg_catalog.record_image_ne(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ne(record, record) is 'implementation of *<> operator';

alter function pg_catalog.record_image_ne(record, record) owner to "kim-uijin";

create function pg_catalog.record_image_lt(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_lt(record, record) is 'implementation of *< operator';

alter function pg_catalog.record_image_lt(record, record) owner to "kim-uijin";

create function pg_catalog.record_image_gt(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_gt(record, record) is 'implementation of *> operator';

alter function pg_catalog.record_image_gt(record, record) owner to "kim-uijin";

create function pg_catalog.record_image_le(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_le(record, record) is 'implementation of *<= operator';

alter function pg_catalog.record_image_le(record, record) owner to "kim-uijin";

create function pg_catalog.record_image_ge(record, record) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.record_image_ge(record, record) is 'implementation of *>= operator';

alter function pg_catalog.record_image_ge(record, record) owner to "kim-uijin";

create function pg_catalog.btrecordimagecmp(record, record) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btrecordimagecmp(record, record) is 'less-equal-greater based on byte images';

alter function pg_catalog.btrecordimagecmp(record, record) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_archiver(out archived_count bigint, out last_archived_wal text, out last_archived_time timestamp with time zone, out failed_count bigint, out last_failed_wal text, out last_failed_time timestamp with time zone, out stats_reset timestamp with time zone) returns record
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone) is 'statistics: information about WAL archiver';

alter function pg_catalog.pg_stat_get_archiver(out bigint, out text, out timestamp with time zone, out bigint, out text, out timestamp with time zone, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.json_object_agg_finalfn(internal) returns json
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_agg_finalfn(internal) is 'json object aggregate final function';

alter function pg_catalog.json_object_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.json_build_array("any") returns json
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array("any") is 'build a json array from any inputs';

alter function pg_catalog.json_build_array("any") owner to "kim-uijin";

create function pg_catalog.json_build_array() returns json
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_array() is 'build an empty json array';

alter function pg_catalog.json_build_array() owner to "kim-uijin";

create function pg_catalog.json_build_object("any") returns json
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object("any") is 'build a json object from pairwise key/value inputs';

alter function pg_catalog.json_build_object("any") owner to "kim-uijin";

create function pg_catalog.json_build_object() returns json
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_build_object() is 'build an empty json object';

alter function pg_catalog.json_build_object() owner to "kim-uijin";

create function pg_catalog.json_object(text[]) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(text[]) is 'map text array of key value pairs to json object';

alter function pg_catalog.json_object(text[]) owner to "kim-uijin";

create function pg_catalog.json_object(text[], text[]) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object(text[], text[]) is 'map text arrays of keys and values to json object';

alter function pg_catalog.json_object(text[], text[]) owner to "kim-uijin";

create function pg_catalog.json_to_record(json) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_record(json) is 'get record fields from a json object';

alter function pg_catalog.json_to_record(json) owner to "kim-uijin";

create function pg_catalog.json_to_recordset(json) returns setof setof record
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_to_recordset(json) is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_to_recordset(json) owner to "kim-uijin";

create function pg_catalog.jsonb_array_length(jsonb) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_length(jsonb) is 'length of jsonb array';

alter function pg_catalog.jsonb_array_length(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_each(from_json jsonb, out key text, out value jsonb) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_each(jsonb, out text, out jsonb) is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each(jsonb, out text, out jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_populate_record(anyelement, jsonb) returns anyelement
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_populate_record(anyelement, jsonb) is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_populate_record(anyelement, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_typeof(jsonb) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_typeof(jsonb) is 'get the type of a jsonb value';

alter function pg_catalog.jsonb_typeof(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_object_field_text(from_json jsonb, field_name text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field_text(jsonb, text) is 'implementation of ->> operator';

alter function pg_catalog.jsonb_object_field_text(jsonb, text) owner to "kim-uijin";

create function pg_catalog.jsonb_array_element(from_json jsonb, element_index integer) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element(jsonb, integer) is 'implementation of -> operator';

alter function pg_catalog.jsonb_array_element(jsonb, integer) owner to "kim-uijin";

create function pg_catalog.jsonb_array_element_text(from_json jsonb, element_index integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_array_element_text(jsonb, integer) is 'implementation of ->> operator';

alter function pg_catalog.jsonb_array_element_text(jsonb, integer) owner to "kim-uijin";

create function pg_catalog.jsonb_extract_path(from_json jsonb, path_elems text[]) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path(jsonb, text[]) is 'get value from jsonb with path elements';

alter function pg_catalog.jsonb_extract_path(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.width_bucket(anycompatible, anycompatiblearray, unknown, unknown) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.width_bucket(anycompatible, anycompatiblearray, unknown, unknown) is 'bucket number of operand given a sorted array of bucket lower bounds';

alter function pg_catalog.width_bucket(anycompatible, anycompatiblearray, unknown, unknown) owner to "kim-uijin";

create function pg_catalog.jsonb_array_elements(from_json jsonb, out value jsonb) returns setof setof jsonb
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_array_elements(jsonb, out jsonb) is 'elements of a jsonb array';

alter function pg_catalog.jsonb_array_elements(jsonb, out jsonb) owner to "kim-uijin";

create function pg_catalog.pg_lsn_in(cstring) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_in(cstring) is 'I/O';

alter function pg_catalog.pg_lsn_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_lsn_out(pg_lsn) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_out(pg_lsn) is 'I/O';

alter function pg_catalog.pg_lsn_out(pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) is 'implementation of < operator';

alter function pg_catalog.pg_lsn_lt(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) is 'implementation of <= operator';

alter function pg_catalog.pg_lsn_le(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) is 'implementation of = operator';

alter function pg_catalog.pg_lsn_eq(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) is 'implementation of >= operator';

alter function pg_catalog.pg_lsn_ge(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) is 'implementation of > operator';

alter function pg_catalog.pg_lsn_gt(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) is 'implementation of <> operator';

alter function pg_catalog.pg_lsn_ne(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) is 'implementation of - operator';

alter function pg_catalog.pg_lsn_mi(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_recv(internal) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_recv(internal) is 'I/O';

alter function pg_catalog.pg_lsn_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_lsn_send(pg_lsn) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_send(pg_lsn) is 'I/O';

alter function pg_catalog.pg_lsn_send(pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) is 'less-equal-greater';

alter function pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_hash(pg_lsn) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash(pg_lsn) is 'hash';

alter function pg_catalog.pg_lsn_hash(pg_lsn) owner to "kim-uijin";

create function pg_catalog.bttextsortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttextsortsupport(internal) is 'sort support';

alter function pg_catalog.bttextsortsupport(internal) owner to "kim-uijin";

create function pg_catalog.generate_series(numeric, numeric, numeric) returns setof setof numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric, numeric) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric, numeric) owner to "kim-uijin";

create function pg_catalog.generate_series(numeric, numeric, unknown) returns setof setof numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.generate_series(numeric, numeric, unknown) is 'non-persistent series generator';

alter function pg_catalog.generate_series(numeric, numeric, unknown) owner to "kim-uijin";

create function pg_catalog.json_strip_nulls(json) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_strip_nulls(json) is 'remove object fields with null values from json';

alter function pg_catalog.json_strip_nulls(json) owner to "kim-uijin";

create function pg_catalog.jsonb_strip_nulls(jsonb) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_strip_nulls(jsonb) is 'remove object fields with null values from jsonb';

alter function pg_catalog.jsonb_strip_nulls(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_object(text[]) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(text[]) is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text[]) owner to "kim-uijin";

create function pg_catalog.jsonb_object(text[], text[]) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object(text[], text[]) is 'map text array of key value pairs to jsonb object';

alter function pg_catalog.jsonb_object(text[], text[]) owner to "kim-uijin";

create function pg_catalog.jsonb_agg_transfn(internal, anyelement) returns internal
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_transfn(internal, anyelement) is 'jsonb aggregate transition function';

alter function pg_catalog.jsonb_agg_transfn(internal, anyelement) owner to "kim-uijin";

create function pg_catalog.jsonb_agg_finalfn(internal) returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_agg_finalfn(internal) is 'jsonb aggregate final function';

alter function pg_catalog.jsonb_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") returns internal
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") is 'jsonb object aggregate transition function';

alter function pg_catalog.jsonb_object_agg_transfn(internal, "any", "any") owner to "kim-uijin";

create function pg_catalog.jsonb_object_agg_finalfn(internal) returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_agg_finalfn(internal) is 'jsonb object aggregate final function';

alter function pg_catalog.jsonb_object_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.jsonb_build_array("any") returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array("any") is 'build a jsonb array from any inputs';

alter function pg_catalog.jsonb_build_array("any") owner to "kim-uijin";

create function pg_catalog.jsonb_build_array() returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_array() is 'build an empty jsonb array';

alter function pg_catalog.jsonb_build_array() owner to "kim-uijin";

create function pg_catalog.jsonb_build_object("any") returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object("any") is 'build a jsonb object from pairwise key/value inputs';

alter function pg_catalog.jsonb_build_object("any") owner to "kim-uijin";

create function pg_catalog.jsonb_build_object() returns jsonb
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_build_object() is 'build an empty jsonb object';

alter function pg_catalog.jsonb_build_object() owner to "kim-uijin";

create function pg_catalog.dist_ppoly(point, polygon) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_ppoly(point, polygon) is 'implementation of <-> operator';

alter function pg_catalog.dist_ppoly(point, polygon) owner to "kim-uijin";

create function pg_catalog.array_position(anycompatiblearray, anycompatible) returns integer
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(anycompatiblearray, anycompatible) is 'returns an offset of value in array';

alter function pg_catalog.array_position(anycompatiblearray, anycompatible) owner to "kim-uijin";

create function pg_catalog.array_position(anycompatiblearray, anycompatible, integer) returns integer
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_position(anycompatiblearray, anycompatible, integer) is 'returns an offset of value in array with start index';

alter function pg_catalog.array_position(anycompatiblearray, anycompatible, integer) owner to "kim-uijin";

create function pg_catalog.array_positions(anycompatiblearray, anycompatible) returns integer[]
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_positions(anycompatiblearray, anycompatible) is 'returns an array of offsets of some value in array';

alter function pg_catalog.array_positions(anycompatiblearray, anycompatible) owner to "kim-uijin";

create function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.scale(numeric) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.scale(numeric) is 'number of decimal digits in the fractional part';

alter function pg_catalog.scale(numeric) owner to "kim-uijin";

create function pg_catalog.gist_point_fetch(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_fetch(internal) is 'GiST support';

alter function pg_catalog.gist_point_fetch(internal) owner to "kim-uijin";

create function pg_catalog.numeric_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_sortsupport(internal) is 'sort support';

alter function pg_catalog.numeric_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.dist_cpoint(circle, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_cpoint(circle, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_cpoint(circle, point) owner to "kim-uijin";

create function pg_catalog.dist_polyp(polygon, point) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dist_polyp(polygon, point) is 'implementation of <-> operator';

alter function pg_catalog.dist_polyp(polygon, point) owner to "kim-uijin";

create function pg_catalog.pg_read_file(text, bigint, bigint, boolean) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text, bigint, bigint, boolean) is 'read text from a file';

alter function pg_catalog.pg_read_file(text, bigint, bigint, boolean) owner to "kim-uijin";

create function pg_catalog.current_setting(text, boolean) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.current_setting(text, boolean) is 'SHOW X as a function, optionally no error for missing variable';

alter function pg_catalog.current_setting(text, boolean) owner to "kim-uijin";

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) returns bytea
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) owner to "kim-uijin";

create function pg_catalog.pg_notification_queue_usage() returns double precision
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_notification_queue_usage() is 'get the fraction of the asynchronous notification queue currently in use';

alter function pg_catalog.pg_notification_queue_usage() owner to "kim-uijin";

create function pg_catalog.pg_ls_dir(text, boolean, boolean) returns setof setof text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_dir(text, boolean, boolean) is 'list all files in a directory';

alter function pg_catalog.pg_ls_dir(text, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.row_security_active(oid) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(oid) is 'row security for current context active on table by table oid';

alter function pg_catalog.row_security_active(oid) owner to "kim-uijin";

create function pg_catalog.row_security_active(text) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.row_security_active(text) is 'row security for current context active on table by table name';

alter function pg_catalog.row_security_active(text) owner to "kim-uijin";

create function pg_catalog.uuid_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_sortsupport(internal) is 'sort support';

alter function pg_catalog.uuid_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.jsonb_concat(jsonb, jsonb) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_concat(jsonb, jsonb) is 'implementation of || operator';

alter function pg_catalog.jsonb_concat(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_delete(jsonb, text) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, text) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, text) owner to "kim-uijin";

create function pg_catalog.jsonb_delete(jsonb, integer) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, integer) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, integer) owner to "kim-uijin";

create function pg_catalog.jsonb_delete_path(jsonb, text[]) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete_path(jsonb, text[]) is 'implementation of #- operator';

alter function pg_catalog.jsonb_delete_path(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.jsonb_set(jsonb_in jsonb, path text[], replacement jsonb, create_if_missing boolean default true) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) is 'Set part of a jsonb';

alter function pg_catalog.jsonb_set(jsonb, text[], jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_pretty(jsonb) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_pretty(jsonb) is 'Indented text from jsonb';

alter function pg_catalog.jsonb_pretty(jsonb) owner to "kim-uijin";

create function pg_catalog.pg_stat_file(filename text, missing_ok boolean, out size bigint, out access timestamp with time zone, out modification timestamp with time zone, out change timestamp with time zone, out creation timestamp with time zone, out isdir boolean) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) is 'get information about file';

alter function pg_catalog.pg_stat_file(text, boolean, out bigint, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out timestamp with time zone, out boolean) owner to "kim-uijin";

create function pg_catalog.xidneq(xid, xid) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneq(xid, xid) is 'implementation of <> operator';

alter function pg_catalog.xidneq(xid, xid) owner to "kim-uijin";

create function pg_catalog.xidneqint4(xid, integer) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xidneqint4(xid, integer) is 'implementation of <> operator';

alter function pg_catalog.xidneqint4(xid, integer) owner to "kim-uijin";

create function pg_catalog.tsm_handler_in(cstring) returns tsm_handler
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_in(cstring) is 'I/O';

alter function pg_catalog.tsm_handler_in(cstring) owner to "kim-uijin";

create function pg_catalog.tsm_handler_out(tsm_handler) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsm_handler_out(tsm_handler) is 'I/O';

alter function pg_catalog.tsm_handler_out(tsm_handler) owner to "kim-uijin";

create function pg_catalog.bernoulli(internal) returns tsm_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bernoulli(internal) is 'BERNOULLI tablesample method handler';

alter function pg_catalog.bernoulli(internal) owner to "kim-uijin";

create function pg_catalog.system(internal) returns tsm_handler
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.system(internal) is 'SYSTEM tablesample method handler';

alter function pg_catalog.system(internal) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_wal_receiver(out pid integer, out status text, out receive_start_lsn pg_lsn, out receive_start_tli integer, out written_lsn pg_lsn, out flushed_lsn pg_lsn, out received_tli integer, out last_msg_send_time timestamp with time zone, out last_msg_receipt_time timestamp with time zone, out latest_end_lsn pg_lsn, out latest_end_time timestamp with time zone, out slot_name text, out sender_host text, out sender_port integer, out conninfo text) returns record
    stable
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text, out integer, out text) is 'statistics: information about WAL receiver';

alter function pg_catalog.pg_stat_get_wal_receiver(out integer, out text, out pg_lsn, out integer, out pg_lsn, out pg_lsn, out integer, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone, out text, out text, out integer, out text) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_progress_info(cmdtype text, out pid integer, out datid oid, out relid oid, out param1 bigint, out param2 bigint, out param3 bigint, out param4 bigint, out param5 bigint, out param6 bigint, out param7 bigint, out param8 bigint, out param9 bigint, out param10 bigint, out param11 bigint, out param12 bigint, out param13 bigint, out param14 bigint, out param15 bigint, out param16 bigint, out param17 bigint, out param18 bigint, out param19 bigint, out param20 bigint) returns setof setof record
    stable
    strict
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint) is 'statistics: information about progress of backends running maintenance command';

alter function pg_catalog.pg_stat_get_progress_info(text, out integer, out oid, out oid, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint) owner to "kim-uijin";

create function pg_catalog.ts_filter(tsvector, "char"[]) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_filter(tsvector, "char"[]) is 'delete lexemes that do not have one of the given weights';

alter function pg_catalog.ts_filter(tsvector, "char"[]) owner to "kim-uijin";

create function pg_catalog.setweight(tsvector, "char", text[]) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(tsvector, "char", text[]) is 'set given weight for given lexemes';

alter function pg_catalog.setweight(tsvector, "char", text[]) owner to "kim-uijin";

create function pg_catalog.ts_delete(tsvector, text) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(tsvector, text) is 'delete lexeme';

alter function pg_catalog.ts_delete(tsvector, text) owner to "kim-uijin";

create function pg_catalog.unnest(tsvector tsvector, out lexeme text, out positions smallint[], out weights text[]) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.unnest(tsvector, out text, out smallint[], out text[]) is 'expand tsvector to set of rows';

alter function pg_catalog.unnest(tsvector, out text, out smallint[], out text[]) owner to "kim-uijin";

create function pg_catalog.ts_delete(tsvector, text[]) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_delete(tsvector, text[]) is 'delete given lexemes';

alter function pg_catalog.ts_delete(tsvector, text[]) owner to "kim-uijin";

create function pg_catalog.int4_avg_combine(bigint[], bigint[]) returns bigint[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_combine(bigint[], bigint[]) is 'aggregate combine function';

alter function pg_catalog.int4_avg_combine(bigint[], bigint[]) owner to "kim-uijin";

create function pg_catalog.interval_combine(interval[], interval[]) returns interval[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_combine(interval[], interval[]) is 'aggregate combine function';

alter function pg_catalog.interval_combine(interval[], interval[]) owner to "kim-uijin";

create function pg_catalog.tsvector_to_array(tsvector) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_to_array(tsvector) is 'convert tsvector to array of lexemes';

alter function pg_catalog.tsvector_to_array(tsvector) owner to "kim-uijin";

create function pg_catalog.array_to_tsvector(text[]) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_to_tsvector(text[]) is 'build tsvector from array of lexemes';

alter function pg_catalog.array_to_tsvector(text[]) owner to "kim-uijin";

create function pg_catalog.bpchar_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bpchar_sortsupport(internal) is 'sort support';

alter function pg_catalog.bpchar_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.pg_show_all_file_settings(out sourcefile text, out sourceline integer, out seqno integer, out name text, out setting text, out applied boolean, out error text) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text) is 'show config file settings';

alter function pg_catalog.pg_show_all_file_settings(out text, out integer, out integer, out text, out text, out boolean, out text) owner to "kim-uijin";

create function pg_catalog.pg_current_wal_flush_lsn() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_wal_flush_lsn() is 'current wal flush location';

alter function pg_catalog.pg_current_wal_flush_lsn() owner to "kim-uijin";

create function pg_catalog.bytea_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_sortsupport(internal) is 'sort support';

alter function pg_catalog.bytea_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.bttext_pattern_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bttext_pattern_sortsupport(internal) is 'sort support';

alter function pg_catalog.bttext_pattern_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.btbpchar_pattern_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btbpchar_pattern_sortsupport(internal) is 'sort support';

alter function pg_catalog.btbpchar_pattern_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.pg_size_bytes(text) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_size_bytes(text) is 'convert a size in human-readable format with size units into bytes';

alter function pg_catalog.pg_size_bytes(text) owner to "kim-uijin";

create function pg_catalog.numeric_serialize(internal) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_serialize(internal) owner to "kim-uijin";

create function pg_catalog.numeric_deserialize(bytea, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_deserialize(bytea, internal) owner to "kim-uijin";

create function pg_catalog.numeric_avg_combine(internal, internal) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_avg_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_avg_combine(internal, internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_combine(internal, internal) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_poly_combine(internal, internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_serialize(internal) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_serialize(internal) is 'aggregate serial function';

alter function pg_catalog.numeric_poly_serialize(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_deserialize(bytea, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_deserialize(bytea, internal) is 'aggregate deserial function';

alter function pg_catalog.numeric_poly_deserialize(bytea, internal) owner to "kim-uijin";

create function pg_catalog.numeric_combine(internal, internal) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_combine(internal, internal) is 'aggregate combine function';

alter function pg_catalog.numeric_combine(internal, internal) owner to "kim-uijin";

create function pg_catalog.float8_regr_combine(double precision[], double precision[]) returns double precision[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float8_regr_combine(double precision[], double precision[]) is 'aggregate combine function';

alter function pg_catalog.float8_regr_combine(double precision[], double precision[]) owner to "kim-uijin";

create function pg_catalog.jsonb_delete(from_json jsonb, path_elems text[]) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_delete(jsonb, text[]) is 'implementation of - operator';

alter function pg_catalog.jsonb_delete(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.cash_mul_int8(money, bigint) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_mul_int8(money, bigint) is 'implementation of * operator';

alter function pg_catalog.cash_mul_int8(money, bigint) owner to "kim-uijin";

create function pg_catalog.cash_div_int8(money, bigint) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_int8(money, bigint) is 'implementation of / operator';

alter function pg_catalog.cash_div_int8(money, bigint) owner to "kim-uijin";

create function pg_catalog.txid_current_if_assigned() returns bigint
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_current_if_assigned() is 'get current transaction ID';

alter function pg_catalog.txid_current_if_assigned() owner to "kim-uijin";

create function pg_catalog.pg_get_partkeydef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partkeydef(oid) is 'partition key description';

alter function pg_catalog.pg_get_partkeydef(oid) owner to "kim-uijin";

create function pg_catalog.pg_ls_logdir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone) is 'list files in the log directory';

alter function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone) owner to "kim-uijin";

grant execute on function pg_catalog.pg_ls_logdir(out text, out bigint, out timestamp with time zone) to pg_monitor;

create function pg_catalog.pg_ls_waldir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone) is 'list of files in the WAL directory';

alter function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone) owner to "kim-uijin";

grant execute on function pg_catalog.pg_ls_waldir(out text, out bigint, out timestamp with time zone) to pg_monitor;

create function pg_catalog.pg_ndistinct_in(cstring) returns pg_ndistinct
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_in(cstring) is 'I/O';

alter function pg_catalog.pg_ndistinct_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_ndistinct_out(pg_ndistinct) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_out(pg_ndistinct) is 'I/O';

alter function pg_catalog.pg_ndistinct_out(pg_ndistinct) owner to "kim-uijin";

create function pg_catalog.pg_ndistinct_recv(internal) returns pg_ndistinct
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_recv(internal) is 'I/O';

alter function pg_catalog.pg_ndistinct_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_ndistinct_send(pg_ndistinct) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ndistinct_send(pg_ndistinct) is 'I/O';

alter function pg_catalog.pg_ndistinct_send(pg_ndistinct) owner to "kim-uijin";

create function pg_catalog.macaddr_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr_sortsupport(internal) is 'sort support';

alter function pg_catalog.macaddr_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.txid_status(bigint) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.txid_status(bigint) is 'commit status of transaction';

alter function pg_catalog.txid_status(bigint) owner to "kim-uijin";

create function pg_catalog.pg_safe_snapshot_blocking_pids(integer) returns integer[]
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_safe_snapshot_blocking_pids(integer) is 'get array of PIDs of sessions blocking specified backend PID from acquiring a safe snapshot';

alter function pg_catalog.pg_safe_snapshot_blocking_pids(integer) owner to "kim-uijin";

create function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) is 'isolationtester support function';

alter function pg_catalog.pg_isolation_test_session_is_blocked(integer, integer[]) owner to "kim-uijin";

create function pg_catalog.pg_identify_object_as_address(classid oid, objid oid, objsubid integer, out type text, out object_names text[], out object_args text[]) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text[], out text[]) is 'get identification of SQL object for pg_get_object_address()';

alter function pg_catalog.pg_identify_object_as_address(oid, oid, integer, out text, out text[], out text[]) owner to "kim-uijin";

create function pg_catalog.brin_minmax_opcinfo(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_opcinfo(internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_opcinfo(internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_add_value(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_consistent(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_consistent(internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_consistent(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_union(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_union(internal, internal, internal) is 'BRIN minmax support';

alter function pg_catalog.brin_minmax_union(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.int8_avg_accum_inv(internal, bigint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_avg_accum_inv(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_avg_accum_inv(internal, bigint) owner to "kim-uijin";

create function pg_catalog.numeric_poly_sum(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_sum(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_sum(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_avg(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_avg(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_avg(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_var_pop(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_pop(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_var_samp(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_var_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_var_samp(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_stddev_pop(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_pop(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_pop(internal) owner to "kim-uijin";

create function pg_catalog.numeric_poly_stddev_samp(internal) returns numeric
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_poly_stddev_samp(internal) is 'aggregate final function';

alter function pg_catalog.numeric_poly_stddev_samp(internal) owner to "kim-uijin";

create function pg_catalog.regexp_match(text, text) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(text, text) is 'find first match for regexp';

alter function pg_catalog.regexp_match(text, text) owner to "kim-uijin";

create function pg_catalog.regexp_match(text, text, text) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regexp_match(text, text, text) is 'find first match for regexp';

alter function pg_catalog.regexp_match(text, text, text) owner to "kim-uijin";

create function pg_catalog.int8_mul_cash(bigint, money) returns money
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_mul_cash(bigint, money) is 'implementation of * operator';

alter function pg_catalog.int8_mul_cash(bigint, money) owner to "kim-uijin";

create function pg_catalog.pg_config(out name text, out setting text) returns setof setof record
    stable
    strict
    parallel restricted
    cost 1
    rows 23
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_config(out text, out text) is 'pg_config binary as a function';

alter function pg_catalog.pg_config(out text, out text) owner to "kim-uijin";

create function pg_catalog.pg_hba_file_rules(out line_number integer, out type text, out database text[], out user_name text[], out address text, out netmask text, out auth_method text, out options text[], out error text) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_hba_file_rules(out integer, out text, out text[], out text[], out text, out text, out text, out text[], out text) is 'show pg_hba.conf rules';

alter function pg_catalog.pg_hba_file_rules(out integer, out text, out text[], out text[], out text, out text, out text, out text[], out text) owner to "kim-uijin";

create function pg_catalog.pg_statistics_obj_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_statistics_obj_is_visible(oid) is 'is statistics object visible in search path?';

alter function pg_catalog.pg_statistics_obj_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_dependencies_in(cstring) returns pg_dependencies
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_in(cstring) is 'I/O';

alter function pg_catalog.pg_dependencies_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_dependencies_out(pg_dependencies) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_out(pg_dependencies) is 'I/O';

alter function pg_catalog.pg_dependencies_out(pg_dependencies) owner to "kim-uijin";

create function pg_catalog.pg_dependencies_recv(internal) returns pg_dependencies
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_recv(internal) is 'I/O';

alter function pg_catalog.pg_dependencies_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_dependencies_send(pg_dependencies) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_dependencies_send(pg_dependencies) is 'I/O';

alter function pg_catalog.pg_dependencies_send(pg_dependencies) owner to "kim-uijin";

create function pg_catalog.pg_get_partition_constraintdef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_partition_constraintdef(oid) is 'partition constraint description';

alter function pg_catalog.pg_get_partition_constraintdef(oid) owner to "kim-uijin";

create function pg_catalog.time_hash_extended(time, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_hash_extended(time, bigint) is 'hash';

alter function pg_catalog.time_hash_extended(time, bigint) owner to "kim-uijin";

create function pg_catalog.timetz_hash_extended(time with time zone, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timetz_hash_extended(time with time zone, bigint) is 'hash';

alter function pg_catalog.timetz_hash_extended(time with time zone, bigint) owner to "kim-uijin";

create function pg_catalog.timestamp_hash_extended(timestamp, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_hash_extended(timestamp, bigint) is 'hash';

alter function pg_catalog.timestamp_hash_extended(timestamp, bigint) owner to "kim-uijin";

create function pg_catalog.uuid_hash_extended(uuid, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uuid_hash_extended(uuid, bigint) is 'hash';

alter function pg_catalog.uuid_hash_extended(uuid, bigint) owner to "kim-uijin";

create function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) is 'hash';

alter function pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint) owner to "kim-uijin";

create function pg_catalog.hashenumextended(anyenum, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenumextended(anyenum, bigint) is 'hash';

alter function pg_catalog.hashenumextended(anyenum, bigint) owner to "kim-uijin";

create function pg_catalog.pg_get_statisticsobjdef(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef(oid) is 'extended statistics object description';

alter function pg_catalog.pg_get_statisticsobjdef(oid) owner to "kim-uijin";

create function pg_catalog.jsonb_hash_extended(jsonb, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash_extended(jsonb, bigint) is 'hash';

alter function pg_catalog.jsonb_hash_extended(jsonb, bigint) owner to "kim-uijin";

create function pg_catalog.hash_range_extended(anyrange, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range_extended(anyrange, bigint) is 'hash a range';

alter function pg_catalog.hash_range_extended(anyrange, bigint) owner to "kim-uijin";

create function pg_catalog.interval_hash_extended(interval, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_hash_extended(interval, bigint) is 'hash';

alter function pg_catalog.interval_hash_extended(interval, bigint) owner to "kim-uijin";

create function pg_catalog.sha224(bytea) returns bytea
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha224(bytea) is 'SHA-224 hash';

alter function pg_catalog.sha224(bytea) owner to "kim-uijin";

create function pg_catalog.sha256(bytea) returns bytea
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha256(bytea) is 'SHA-256 hash';

alter function pg_catalog.sha256(bytea) owner to "kim-uijin";

create function pg_catalog.sha384(bytea) returns bytea
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha384(bytea) is 'SHA-384 hash';

alter function pg_catalog.sha384(bytea) owner to "kim-uijin";

create function pg_catalog.sha512(bytea) returns bytea
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sha512(bytea) is 'SHA-512 hash';

alter function pg_catalog.sha512(bytea) owner to "kim-uijin";

create function pg_catalog.pg_partition_tree(rootrelid regclass, out relid regclass, out parentrelid regclass, out isleaf boolean, out level integer) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_partition_tree(regclass, out regclass, out regclass, out boolean, out integer) is 'view partition tree tables';

alter function pg_catalog.pg_partition_tree(regclass, out regclass, out regclass, out boolean, out integer) owner to "kim-uijin";

create function pg_catalog.pg_partition_root(regclass) returns regclass
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_partition_root(regclass) is 'get top-most partition root parent';

alter function pg_catalog.pg_partition_root(regclass) owner to "kim-uijin";

create function pg_catalog.pg_partition_ancestors(partitionid regclass, out relid regclass) returns setof setof regclass
    strict
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_partition_ancestors(regclass, out regclass) is 'view ancestors of the partition';

alter function pg_catalog.pg_partition_ancestors(regclass, out regclass) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_checksum_failures(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_failures(oid) is 'statistics: checksum failures detected in database';

alter function pg_catalog.pg_stat_get_db_checksum_failures(oid) owner to "kim-uijin";

create function pg_catalog.pg_mcv_list_items(mcv_list pg_mcv_list, out index integer, out values text[], out nulls boolean[], out frequency double precision, out base_frequency double precision) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_mcv_list_items(pg_mcv_list, out integer, out text[], out boolean[], out double precision, out double precision) is 'details about MCV list items';

alter function pg_catalog.pg_mcv_list_items(pg_mcv_list, out integer, out text[], out boolean[], out double precision, out double precision) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_checksum_last_failure(oid) returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_checksum_last_failure(oid) is 'statistics: when last checksum failure was detected in database';

alter function pg_catalog.pg_stat_get_db_checksum_last_failure(oid) owner to "kim-uijin";

create function pg_catalog.gen_random_uuid() returns uuid
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gen_random_uuid() is 'generate random UUID';

alter function pg_catalog.gen_random_uuid() owner to "kim-uijin";

create function pg_catalog.gtsvector_options(internal) returns void
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_options(internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_options(internal) owner to "kim-uijin";

create function pg_catalog.gist_point_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_point_sortsupport(internal) is 'sort support';

alter function pg_catalog.gist_point_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.pg_promote(wait boolean default true, wait_seconds integer default 60) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_promote(boolean, integer) is 'promote standby server';

alter function pg_catalog.pg_promote(boolean, integer) owner to "kim-uijin";

create function pg_catalog.prefixsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixsel(internal, oid, internal, integer) is 'restriction selectivity of exact prefix';

alter function pg_catalog.prefixsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of exact prefix';

alter function pg_catalog.prefixjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.pg_control_system(out pg_control_version integer, out catalog_version_no integer, out system_identifier bigint, out pg_control_last_modified timestamp with time zone) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone) is 'pg_controldata general state information as a function';

alter function pg_catalog.pg_control_system(out integer, out integer, out bigint, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_control_checkpoint(out checkpoint_lsn pg_lsn, out redo_lsn pg_lsn, out redo_wal_file text, out timeline_id integer, out prev_timeline_id integer, out full_page_writes boolean, out next_xid text, out next_oid oid, out next_multixact_id xid, out next_multi_offset xid, out oldest_xid xid, out oldest_xid_dbid oid, out oldest_active_xid xid, out oldest_multi_xid xid, out oldest_multi_dbid oid, out oldest_commit_ts_xid xid, out newest_commit_ts_xid xid, out checkpoint_time timestamp with time zone) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone) is 'pg_controldata checkpoint state information as a function';

alter function pg_catalog.pg_control_checkpoint(out pg_lsn, out pg_lsn, out text, out integer, out integer, out boolean, out text, out oid, out xid, out xid, out xid, out oid, out xid, out xid, out oid, out xid, out xid, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_control_recovery(out min_recovery_end_lsn pg_lsn, out min_recovery_end_timeline integer, out backup_start_lsn pg_lsn, out backup_end_lsn pg_lsn, out end_of_backup_record_required boolean) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean) is 'pg_controldata recovery state information as a function';

alter function pg_catalog.pg_control_recovery(out pg_lsn, out integer, out pg_lsn, out pg_lsn, out boolean) owner to "kim-uijin";

create function pg_catalog.pg_control_init(out max_data_alignment integer, out database_block_size integer, out blocks_per_segment integer, out wal_block_size integer, out bytes_per_wal_segment integer, out max_identifier_length integer, out max_index_columns integer, out max_toast_chunk_size integer, out large_object_chunk_size integer, out float8_pass_by_value boolean, out data_page_checksum_version integer) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out integer) is 'pg_controldata init state information as a function';

alter function pg_catalog.pg_control_init(out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out integer, out boolean, out integer) owner to "kim-uijin";

create function pg_catalog.pg_import_system_collations(regnamespace) returns integer
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_import_system_collations(regnamespace) is 'import collations from operating system';

alter function pg_catalog.pg_import_system_collations(regnamespace) owner to "kim-uijin";

create function pg_catalog.macaddr8_recv(internal) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_recv(internal) is 'I/O';

alter function pg_catalog.macaddr8_recv(internal) owner to "kim-uijin";

create function pg_catalog.macaddr8_send(macaddr8) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_send(macaddr8) is 'I/O';

alter function pg_catalog.macaddr8_send(macaddr8) owner to "kim-uijin";

create function pg_catalog.pg_collation_actual_version(oid) returns text
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_actual_version(oid) is 'get actual version of collation from operating system';

alter function pg_catalog.pg_collation_actual_version(oid) owner to "kim-uijin";

create function pg_catalog.numeric(jsonb) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(jsonb) is 'convert jsonb to numeric';

alter function pg_catalog.numeric(jsonb) owner to "kim-uijin";

create function pg_catalog.int2(jsonb) returns smallint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2(jsonb) is 'convert jsonb to int2';

alter function pg_catalog.int2(jsonb) owner to "kim-uijin";

create function pg_catalog.int4(jsonb) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4(jsonb) is 'convert jsonb to int4';

alter function pg_catalog.int4(jsonb) owner to "kim-uijin";

create function pg_catalog.int8(jsonb) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8(jsonb) is 'convert jsonb to int8';

alter function pg_catalog.int8(jsonb) owner to "kim-uijin";

create function pg_catalog.float4(jsonb) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.float4(jsonb) is 'convert jsonb to float4';

alter function pg_catalog.float4(jsonb) owner to "kim-uijin";

create function pg_catalog.pg_filenode_relation(oid, oid) returns regclass
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_filenode_relation(oid, oid) is 'relation OID for filenode and tablespace';

alter function pg_catalog.pg_filenode_relation(oid, oid) owner to "kim-uijin";

create function pg_catalog.lo_from_bytea(oid, bytea) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_from_bytea(oid, bytea) is 'create new large object with given content';

alter function pg_catalog.lo_from_bytea(oid, bytea) owner to "kim-uijin";

create function pg_catalog.lo_get(oid) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(oid) is 'read entire large object';

alter function pg_catalog.lo_get(oid) owner to "kim-uijin";

create function pg_catalog.lo_get(oid, bigint, integer) returns bytea
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_get(oid, bigint, integer) is 'read large object from offset for length';

alter function pg_catalog.lo_get(oid, bigint, integer) owner to "kim-uijin";

create function pg_catalog.lo_put(oid, bigint, bytea) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lo_put(oid, bigint, bytea) is 'write data at offset';

alter function pg_catalog.lo_put(oid, bigint, bytea) owner to "kim-uijin";

create function pg_catalog.make_timestamp(year integer, month integer, mday integer, hour integer, min integer, sec double precision) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) is 'construct timestamp';

alter function pg_catalog.make_timestamp(integer, integer, integer, integer, integer, double precision) owner to "kim-uijin";

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer, sec double precision) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision) owner to "kim-uijin";

create function pg_catalog.make_timestamptz(year integer, month integer, mday integer, hour integer, min integer, sec double precision, timezone text) returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) is 'construct timestamp with time zone';

alter function pg_catalog.make_timestamptz(integer, integer, integer, integer, integer, double precision, text) owner to "kim-uijin";

create function pg_catalog.make_interval(years integer default 0, months integer default 0, weeks integer default 0, days integer default 0, hours integer default 0, mins integer default 0, secs double precision default 0.0) returns interval
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) is 'construct interval';

alter function pg_catalog.make_interval(integer, integer, integer, integer, integer, integer, double precision) owner to "kim-uijin";

create function pg_catalog.jsonb_array_elements_text(from_json jsonb, out value text) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_array_elements_text(jsonb, out text) is 'elements of jsonb array';

alter function pg_catalog.jsonb_array_elements_text(jsonb, out text) owner to "kim-uijin";

create function pg_catalog.spg_range_quad_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_config(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_range_quad_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_choose(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_range_quad_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_range_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over range';

alter function pg_catalog.spg_range_quad_leaf_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) returns setof setof anyelement
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_populate_recordset(anyelement, jsonb) owner to "kim-uijin";

create function pg_catalog.to_regoperator(text) returns regoperator
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoperator(text) is 'convert operator name to regoperator';

alter function pg_catalog.to_regoperator(text) owner to "kim-uijin";

create function pg_catalog.jsonb_object_field(from_json jsonb, field_name text) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_object_field(jsonb, text) is 'implementation of -> operator';

alter function pg_catalog.jsonb_object_field(jsonb, text) owner to "kim-uijin";

create function pg_catalog.to_regprocedure(text) returns regprocedure
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regprocedure(text) is 'convert proname to regprocedure';

alter function pg_catalog.to_regprocedure(text) owner to "kim-uijin";

create function pg_catalog.gin_compare_jsonb(text, text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_compare_jsonb(text, text) is 'GIN support';

alter function pg_catalog.gin_compare_jsonb(text, text) owner to "kim-uijin";

create function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb(jsonb, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) is 'GIN support';

alter function pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.jsonb_to_record(jsonb) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_record(jsonb) is 'get record fields from a jsonb object';

alter function pg_catalog.jsonb_to_record(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_to_recordset(jsonb) returns setof setof record
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_to_recordset(jsonb) is 'get set of records with fields from a jsonb array of objects';

alter function pg_catalog.jsonb_to_recordset(jsonb) owner to "kim-uijin";

create function pg_catalog.to_regoper(text) returns regoper
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regoper(text) is 'convert operator name to regoper';

alter function pg_catalog.to_regoper(text) owner to "kim-uijin";

create function pg_catalog.to_regtype(text) returns regtype
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regtype(text) is 'convert type name to regtype';

alter function pg_catalog.to_regtype(text) owner to "kim-uijin";

create function pg_catalog.to_regproc(text) returns regproc
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regproc(text) is 'convert proname to regproc';

alter function pg_catalog.to_regproc(text) owner to "kim-uijin";

create function pg_catalog.to_regclass(text) returns regclass
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regclass(text) is 'convert classname to regclass';

alter function pg_catalog.to_regclass(text) owner to "kim-uijin";

create function pg_catalog.bool_accum(internal, boolean) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum(internal, boolean) is 'aggregate transition function';

alter function pg_catalog.bool_accum(internal, boolean) owner to "kim-uijin";

create function pg_catalog.bool_accum_inv(internal, boolean) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_accum_inv(internal, boolean) is 'aggregate transition function';

alter function pg_catalog.bool_accum_inv(internal, boolean) owner to "kim-uijin";

create function pg_catalog.bool_alltrue(internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_alltrue(internal) is 'aggregate final function';

alter function pg_catalog.bool_alltrue(internal) owner to "kim-uijin";

create function pg_catalog.bool_anytrue(internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool_anytrue(internal) is 'aggregate final function';

alter function pg_catalog.bool_anytrue(internal) owner to "kim-uijin";

create function pg_catalog.anyenum_in(cstring) returns anyenum
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_in(cstring) is 'I/O';

alter function pg_catalog.anyenum_in(cstring) owner to "kim-uijin";

create function pg_catalog.anyenum_out(anyenum) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyenum_out(anyenum) is 'I/O';

alter function pg_catalog.anyenum_out(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_in(cstring, oid) returns anyenum
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_in(cstring, oid) is 'I/O';

alter function pg_catalog.enum_in(cstring, oid) owner to "kim-uijin";

create function pg_catalog.enum_out(anyenum) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_out(anyenum) is 'I/O';

alter function pg_catalog.enum_out(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_eq(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_eq(anyenum, anyenum) is 'implementation of = operator';

alter function pg_catalog.enum_eq(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_ne(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ne(anyenum, anyenum) is 'implementation of <> operator';

alter function pg_catalog.enum_ne(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_lt(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_lt(anyenum, anyenum) is 'implementation of < operator';

alter function pg_catalog.enum_lt(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_gt(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_gt(anyenum, anyenum) is 'implementation of > operator';

alter function pg_catalog.enum_gt(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_le(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_le(anyenum, anyenum) is 'implementation of <= operator';

alter function pg_catalog.enum_le(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_ge(anyenum, anyenum) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_ge(anyenum, anyenum) is 'implementation of >= operator';

alter function pg_catalog.enum_ge(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_cmp(anyenum, anyenum) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_cmp(anyenum, anyenum) is 'less-equal-greater';

alter function pg_catalog.enum_cmp(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.hashenum(anyenum) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hashenum(anyenum) is 'hash';

alter function pg_catalog.hashenum(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_smaller(anyenum, anyenum) returns anyenum
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_smaller(anyenum, anyenum) is 'smaller of two';

alter function pg_catalog.enum_smaller(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_larger(anyenum, anyenum) returns anyenum
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_larger(anyenum, anyenum) is 'larger of two';

alter function pg_catalog.enum_larger(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_first(anyenum) returns anyenum
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_first(anyenum) is 'first value of the input enum type';

alter function pg_catalog.enum_first(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_last(anyenum) returns anyenum
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_last(anyenum) is 'last value of the input enum type';

alter function pg_catalog.enum_last(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_range(anyenum, anyenum) returns anyarray
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(anyenum, anyenum) is 'range between the two given enum values, as an ordered array';

alter function pg_catalog.enum_range(anyenum, anyenum) owner to "kim-uijin";

create function pg_catalog.enum_range(anyenum) returns anyarray
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_range(anyenum) is 'range of the given enum type, as an ordered array';

alter function pg_catalog.enum_range(anyenum) owner to "kim-uijin";

create function pg_catalog.enum_recv(internal, oid) returns anyenum
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_recv(internal, oid) is 'I/O';

alter function pg_catalog.enum_recv(internal, oid) owner to "kim-uijin";

create function pg_catalog.enum_send(anyenum) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.enum_send(anyenum) is 'I/O';

alter function pg_catalog.enum_send(anyenum) owner to "kim-uijin";

create function pg_catalog.string_agg_transfn(internal, text, text) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_transfn(internal, text, text) is 'aggregate transition function';

alter function pg_catalog.string_agg_transfn(internal, text, text) owner to "kim-uijin";

create function pg_catalog.string_agg_finalfn(internal) returns text
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.string_agg_finalfn(internal) is 'aggregate final function';

alter function pg_catalog.string_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.pg_describe_object(oid, oid, integer) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_describe_object(oid, oid, integer) is 'get identification of SQL object';

alter function pg_catalog.pg_describe_object(oid, oid, integer) owner to "kim-uijin";

create function pg_catalog.format(text, "any") returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(text, "any") is 'format text message';

alter function pg_catalog.format(text, "any") owner to "kim-uijin";

create function pg_catalog.format(text, unknown) returns text
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.format(text, unknown) is 'format text message';

alter function pg_catalog.format(text, unknown) owner to "kim-uijin";

create function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) is 'aggregate transition function';

alter function pg_catalog.bytea_string_agg_transfn(internal, bytea, bytea) owner to "kim-uijin";

create function pg_catalog.bytea_string_agg_finalfn(internal) returns bytea
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bytea_string_agg_finalfn(internal) is 'aggregate final function';

alter function pg_catalog.bytea_string_agg_finalfn(internal) owner to "kim-uijin";

create function pg_catalog.int8dec(bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec(bigint) is 'decrement';

alter function pg_catalog.int8dec(bigint) owner to "kim-uijin";

create function pg_catalog.int8dec_any(bigint, "any") returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8dec_any(bigint, "any") is 'decrement, ignores second argument';

alter function pg_catalog.int8dec_any(bigint, "any") owner to "kim-uijin";

create function pg_catalog.numeric_accum_inv(internal, numeric) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric_accum_inv(internal, numeric) is 'aggregate transition function';

alter function pg_catalog.numeric_accum_inv(internal, numeric) owner to "kim-uijin";

create function pg_catalog.interval_accum_inv(interval[], interval) returns interval[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_accum_inv(interval[], interval) is 'aggregate transition function';

alter function pg_catalog.interval_accum_inv(interval[], interval) owner to "kim-uijin";

create function pg_catalog.network_overlap(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_overlap(inet, inet) is 'implementation of && operator';

alter function pg_catalog.network_overlap(inet, inet) owner to "kim-uijin";

create function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.inet_gist_union(internal, internal) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_union(internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_union(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_gist_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_compress(internal) is 'GiST support';

alter function pg_catalog.inet_gist_compress(internal) owner to "kim-uijin";

create function pg_catalog.bool(jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bool(jsonb) is 'convert jsonb to boolean';

alter function pg_catalog.bool(jsonb) owner to "kim-uijin";

create function pg_catalog.inet_gist_penalty(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_penalty(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_gist_picksplit(internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.inet_gist_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_gist_same(inet, inet, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_same(inet, inet, internal) is 'GiST support';

alter function pg_catalog.inet_gist_same(inet, inet, internal) owner to "kim-uijin";

create function pg_catalog.networksel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networksel(internal, oid, internal, integer) is 'restriction selectivity for network operators';

alter function pg_catalog.networksel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for network operators';

alter function pg_catalog.networkjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.network_larger(inet, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_larger(inet, inet) is 'larger of two';

alter function pg_catalog.network_larger(inet, inet) owner to "kim-uijin";

create function pg_catalog.network_smaller(inet, inet) returns inet
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_smaller(inet, inet) is 'smaller of two';

alter function pg_catalog.network_smaller(inet, inet) owner to "kim-uijin";

create function pg_catalog.pg_event_trigger_dropped_objects(out classid oid, out objid oid, out objsubid integer, out original boolean, out normal boolean, out is_temporary boolean, out object_type text, out schema_name text, out object_name text, out object_identity text, out address_names text[], out address_args text[]) returns setof setof record
    stable
    strict
    parallel restricted
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text[], out text[]) is 'list objects dropped by the current command';

alter function pg_catalog.pg_event_trigger_dropped_objects(out oid, out oid, out integer, out boolean, out boolean, out boolean, out text, out text, out text, out text, out text[], out text[]) owner to "kim-uijin";

create function pg_catalog.int2_accum_inv(internal, smallint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_accum_inv(internal, smallint) is 'aggregate transition function';

alter function pg_catalog.int2_accum_inv(internal, smallint) owner to "kim-uijin";

create function pg_catalog.int4_accum_inv(internal, integer) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_accum_inv(internal, integer) is 'aggregate transition function';

alter function pg_catalog.int4_accum_inv(internal, integer) owner to "kim-uijin";

create function pg_catalog.int8_accum_inv(internal, bigint) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8_accum_inv(internal, bigint) is 'aggregate transition function';

alter function pg_catalog.int8_accum_inv(internal, bigint) owner to "kim-uijin";

create function pg_catalog.int2_avg_accum_inv(bigint[], smallint) returns bigint[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2_avg_accum_inv(bigint[], smallint) is 'aggregate transition function';

alter function pg_catalog.int2_avg_accum_inv(bigint[], smallint) owner to "kim-uijin";

create function pg_catalog.int4_avg_accum_inv(bigint[], integer) returns bigint[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4_avg_accum_inv(bigint[], integer) is 'aggregate transition function';

alter function pg_catalog.int4_avg_accum_inv(bigint[], integer) owner to "kim-uijin";

create function pg_catalog.int2int4_sum(bigint[]) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int2int4_sum(bigint[]) is 'aggregate final function';

alter function pg_catalog.int2int4_sum(bigint[]) owner to "kim-uijin";

create function pg_catalog.inet_gist_fetch(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_gist_fetch(internal) is 'GiST support';

alter function pg_catalog.inet_gist_fetch(internal) owner to "kim-uijin";

create function pg_catalog.pg_logical_emit_message(boolean, text, text) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, text) is 'emit a textual logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, text) owner to "kim-uijin";

create function pg_catalog.pg_logical_emit_message(boolean, text, bytea) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_logical_emit_message(boolean, text, bytea) is 'emit a binary logical decoding message';

alter function pg_catalog.pg_logical_emit_message(boolean, text, bytea) owner to "kim-uijin";

create function pg_catalog.jsonb_insert(jsonb_in jsonb, path text[], replacement jsonb, insert_after boolean default false) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) is 'Insert value into a jsonb';

alter function pg_catalog.jsonb_insert(jsonb, text[], jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.pg_xact_commit_timestamp(xid) returns timestamp with time zone
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp(xid) is 'get commit timestamp of a transaction';

alter function pg_catalog.pg_xact_commit_timestamp(xid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_type_oid(oid) owner to "kim-uijin";

create function pg_catalog.pg_last_committed_xact(out xid xid, out timestamp timestamp with time zone, out roident oid) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone, out oid) is 'get transaction Id, commit timestamp and replication origin of latest transaction commit';

alter function pg_catalog.pg_last_committed_xact(out xid, out timestamp with time zone, out oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_array_pg_type_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_heap_pg_class_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_index_pg_class_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_toast_pg_class_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_enum_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_pg_authid_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) returns void
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_create_empty_extension(text, text, boolean, text, oid[], text[], text[]) owner to "kim-uijin";

create function pg_catalog.event_trigger_in(cstring) returns event_trigger
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_in(cstring) is 'I/O';

alter function pg_catalog.event_trigger_in(cstring) owner to "kim-uijin";

create function pg_catalog.event_trigger_out(event_trigger) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.event_trigger_out(event_trigger) is 'I/O';

alter function pg_catalog.event_trigger_out(event_trigger) owner to "kim-uijin";

create function pg_catalog.tsvectorin(cstring) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorin(cstring) is 'I/O';

alter function pg_catalog.tsvectorin(cstring) owner to "kim-uijin";

create function pg_catalog.tsvectorout(tsvector) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorout(tsvector) is 'I/O';

alter function pg_catalog.tsvectorout(tsvector) owner to "kim-uijin";

create function pg_catalog.tsqueryin(cstring) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryin(cstring) is 'I/O';

alter function pg_catalog.tsqueryin(cstring) owner to "kim-uijin";

create function pg_catalog.tsqueryout(tsquery) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryout(tsquery) is 'I/O';

alter function pg_catalog.tsqueryout(tsquery) owner to "kim-uijin";

create function pg_catalog.tsvector_lt(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_lt(tsvector, tsvector) is 'implementation of < operator';

alter function pg_catalog.tsvector_lt(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_le(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_le(tsvector, tsvector) is 'implementation of <= operator';

alter function pg_catalog.tsvector_le(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_eq(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_eq(tsvector, tsvector) is 'implementation of = operator';

alter function pg_catalog.tsvector_eq(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_ne(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ne(tsvector, tsvector) is 'implementation of <> operator';

alter function pg_catalog.tsvector_ne(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_ge(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_ge(tsvector, tsvector) is 'implementation of >= operator';

alter function pg_catalog.tsvector_ge(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_gt(tsvector, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_gt(tsvector, tsvector) is 'implementation of > operator';

alter function pg_catalog.tsvector_gt(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvector_cmp(tsvector, tsvector) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_cmp(tsvector, tsvector) is 'less-equal-greater';

alter function pg_catalog.tsvector_cmp(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.strip(tsvector) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.strip(tsvector) is 'strip position information';

alter function pg_catalog.strip(tsvector) owner to "kim-uijin";

create function pg_catalog.setweight(tsvector, "char", unknown) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.setweight(tsvector, "char", unknown) is 'set given weight for whole tsvector';

alter function pg_catalog.setweight(tsvector, "char", unknown) owner to "kim-uijin";

create function pg_catalog.tsvector_concat(tsvector, tsvector) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_concat(tsvector, tsvector) is 'implementation of || operator';

alter function pg_catalog.tsvector_concat(tsvector, tsvector) owner to "kim-uijin";

create function pg_catalog.ts_match_vq(tsvector, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_vq(tsvector, tsquery) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_vq(tsvector, tsquery) owner to "kim-uijin";

create function pg_catalog.ts_match_qv(tsquery, tsvector) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_qv(tsquery, tsvector) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_qv(tsquery, tsvector) owner to "kim-uijin";

create function pg_catalog.tsvectorsend(tsvector) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorsend(tsvector) is 'I/O';

alter function pg_catalog.tsvectorsend(tsvector) owner to "kim-uijin";

create function pg_catalog.tsvectorrecv(internal) returns tsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvectorrecv(internal) is 'I/O';

alter function pg_catalog.tsvectorrecv(internal) owner to "kim-uijin";

create function pg_catalog.tsquerysend(tsquery) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquerysend(tsquery) is 'I/O';

alter function pg_catalog.tsquerysend(tsquery) owner to "kim-uijin";

create function pg_catalog.tsqueryrecv(internal) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsqueryrecv(internal) is 'I/O';

alter function pg_catalog.tsqueryrecv(internal) owner to "kim-uijin";

create function pg_catalog.gtsvectorin(cstring) returns gtsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorin(cstring) is 'I/O';

alter function pg_catalog.gtsvectorin(cstring) owner to "kim-uijin";

create function pg_catalog.gtsvectorout(gtsvector) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvectorout(gtsvector) is 'I/O';

alter function pg_catalog.gtsvectorout(gtsvector) owner to "kim-uijin";

create function pg_catalog.gtsvector_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_compress(internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_compress(internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_decompress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_decompress(internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_decompress(internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_picksplit(internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_picksplit(internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_union(internal, internal) returns gtsvector
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_union(internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_union(internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_same(gtsvector, gtsvector, internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_penalty(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_penalty(internal, internal, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_penalty(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) is 'GiST tsvector support';

alter function pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsvector(tsvector, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.tsquery_lt(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_lt(tsquery, tsquery) is 'implementation of < operator';

alter function pg_catalog.tsquery_lt(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_le(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_le(tsquery, tsquery) is 'implementation of <= operator';

alter function pg_catalog.tsquery_le(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_eq(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_eq(tsquery, tsquery) is 'implementation of = operator';

alter function pg_catalog.tsquery_eq(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_ne(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ne(tsquery, tsquery) is 'implementation of <> operator';

alter function pg_catalog.tsquery_ne(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_ge(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_ge(tsquery, tsquery) is 'implementation of >= operator';

alter function pg_catalog.tsquery_ge(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_gt(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_gt(tsquery, tsquery) is 'implementation of > operator';

alter function pg_catalog.tsquery_gt(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_cmp(tsquery, tsquery) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_cmp(tsquery, tsquery) is 'less-equal-greater';

alter function pg_catalog.tsquery_cmp(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_and(tsquery, tsquery) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_and(tsquery, tsquery) is 'implementation of && operator';

alter function pg_catalog.tsquery_and(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_or(tsquery, tsquery) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_or(tsquery, tsquery) is 'implementation of || operator';

alter function pg_catalog.tsquery_or(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_not(tsquery) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_not(tsquery) is 'implementation of !! operator';

alter function pg_catalog.tsquery_not(tsquery) owner to "kim-uijin";

create function pg_catalog.numnode(tsquery) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numnode(tsquery) is 'number of nodes';

alter function pg_catalog.numnode(tsquery) owner to "kim-uijin";

create function pg_catalog.querytree(tsquery) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.querytree(tsquery) is 'show real useful query for GiST index';

alter function pg_catalog.querytree(tsquery) owner to "kim-uijin";

create function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.ts_rewrite(tsquery, text) returns tsquery
    strict
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rewrite(tsquery, text) is 'rewrite tsquery';

alter function pg_catalog.ts_rewrite(tsquery, text) owner to "kim-uijin";

create function pg_catalog.tsmatchsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchsel(internal, oid, internal, integer) is 'restriction selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity of tsvector @@ tsquery';

alter function pg_catalog.tsmatchjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.ts_typanalyze(internal) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_typanalyze(internal) is 'tsvector typanalyze';

alter function pg_catalog.ts_typanalyze(internal) owner to "kim-uijin";

create function pg_catalog.ts_stat(query text, out word text, out ndoc integer, out nentry integer) returns setof setof record
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_stat(text, out text, out integer, out integer) is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, out text, out integer, out integer) owner to "kim-uijin";

create function pg_catalog.ts_stat(query text, weights text, out word text, out ndoc integer, out nentry integer) returns setof setof record
    strict
    cost 10
    rows 10000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_stat(text, text, out text, out integer, out integer) is 'statistics of tsvector column';

alter function pg_catalog.ts_stat(text, text, out text, out integer, out integer) owner to "kim-uijin";

create function pg_catalog.tsq_mcontains(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontains(tsquery, tsquery) is 'implementation of @> operator';

alter function pg_catalog.tsq_mcontains(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsq_mcontained(tsquery, tsquery) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsq_mcontained(tsquery, tsquery) is 'implementation of <@ operator';

alter function pg_catalog.tsq_mcontained(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.gtsquery_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_compress(internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_compress(internal) owner to "kim-uijin";

create function pg_catalog.starts_with(text, text) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.starts_with(text, text) is 'implementation of ^@ operator';

alter function pg_catalog.starts_with(text, text) owner to "kim-uijin";

create function pg_catalog.gtsquery_picksplit(internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_picksplit(internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsquery_union(internal, internal) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_union(internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_union(internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsquery_same(bigint, bigint, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_same(bigint, bigint, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_same(bigint, bigint, internal) owner to "kim-uijin";

create function pg_catalog.gtsquery_penalty(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_penalty(internal, internal, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_penalty(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) is 'GiST tsquery support';

alter function pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank(real[], tsvector, tsquery, integer) owner to "kim-uijin";

create function pg_catalog.ts_rank(real[], tsvector, tsquery, unknown) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(real[], tsvector, tsquery, unknown) is 'relevance';

alter function pg_catalog.ts_rank(real[], tsvector, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_rank(tsvector, tsquery, integer) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery, integer) owner to "kim-uijin";

create function pg_catalog.ts_rank(tsvector, tsquery, unknown) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank(tsvector, tsquery, unknown) is 'relevance';

alter function pg_catalog.ts_rank(tsvector, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, integer) owner to "kim-uijin";

create function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, unknown) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, unknown) is 'relevance';

alter function pg_catalog.ts_rank_cd(real[], tsvector, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery, integer) owner to "kim-uijin";

create function pg_catalog.ts_rank_cd(tsvector, tsquery, unknown) returns real
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_rank_cd(tsvector, tsquery, unknown) is 'relevance';

alter function pg_catalog.ts_rank_cd(tsvector, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.length(tsvector) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.length(tsvector) is 'number of lexemes';

alter function pg_catalog.length(tsvector) owner to "kim-uijin";

create function pg_catalog.ts_token_type(parser_oid oid, out tokid integer, out alias text, out description text) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_token_type(oid, out integer, out text, out text) is 'get parser''s token types';

alter function pg_catalog.ts_token_type(oid, out integer, out text, out text) owner to "kim-uijin";

create function pg_catalog.ts_token_type(parser_name text, out tokid integer, out alias text, out description text) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    rows 16
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_token_type(text, out integer, out text, out text) is 'get parser''s token types';

alter function pg_catalog.ts_token_type(text, out integer, out text, out text) owner to "kim-uijin";

create function pg_catalog.ts_parse(parser_oid oid, txt text, out tokid integer, out token text) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_parse(oid, text, out integer, out text) is 'parse text to tokens';

alter function pg_catalog.ts_parse(oid, text, out integer, out text) owner to "kim-uijin";

create function pg_catalog.ts_parse(parser_name text, txt text, out tokid integer, out token text) returns setof setof record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.ts_parse(text, text, out integer, out text) is 'parse text to tokens';

alter function pg_catalog.ts_parse(text, text, out integer, out text) owner to "kim-uijin";

create function pg_catalog.prsd_start(internal, integer) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_start(internal, integer) is '(internal)';

alter function pg_catalog.prsd_start(internal, integer) owner to "kim-uijin";

create function pg_catalog.prsd_nexttoken(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_nexttoken(internal, internal, internal) is '(internal)';

alter function pg_catalog.prsd_nexttoken(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.prsd_end(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_end(internal) is '(internal)';

alter function pg_catalog.prsd_end(internal) owner to "kim-uijin";

create function pg_catalog.prsd_headline(internal, internal, tsquery) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_headline(internal, internal, tsquery) is '(internal)';

alter function pg_catalog.prsd_headline(internal, internal, tsquery) owner to "kim-uijin";

create function pg_catalog.prsd_lextype(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.prsd_lextype(internal) is '(internal)';

alter function pg_catalog.prsd_lextype(internal) owner to "kim-uijin";

create function pg_catalog.ts_lexize(regdictionary, text) returns text[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_lexize(regdictionary, text) is 'normalize one word by dictionary';

alter function pg_catalog.ts_lexize(regdictionary, text) owner to "kim-uijin";

create function pg_catalog.gin_cmp_tslexeme(text, text) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_cmp_tslexeme(text, text) is 'GIN tsvector support';

alter function pg_catalog.gin_cmp_tslexeme(text, text) owner to "kim-uijin";

create function pg_catalog.dsimple_init(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_init(internal) is '(internal)';

alter function pg_catalog.dsimple_init(internal) owner to "kim-uijin";

create function pg_catalog.dsimple_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsimple_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dsimple_lexize(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.dsynonym_init(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_init(internal) is '(internal)';

alter function pg_catalog.dsynonym_init(internal) owner to "kim-uijin";

create function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dsynonym_lexize(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.dispell_init(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_init(internal) is '(internal)';

alter function pg_catalog.dispell_init(internal) owner to "kim-uijin";

create function pg_catalog.dispell_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dispell_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.dispell_lexize(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.regconfigin(cstring) returns regconfig
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigin(cstring) is 'I/O';

alter function pg_catalog.regconfigin(cstring) owner to "kim-uijin";

create function pg_catalog.regconfigout(regconfig) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigout(regconfig) is 'I/O';

alter function pg_catalog.regconfigout(regconfig) owner to "kim-uijin";

create function pg_catalog.regconfigrecv(internal) returns regconfig
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigrecv(internal) is 'I/O';

alter function pg_catalog.regconfigrecv(internal) owner to "kim-uijin";

create function pg_catalog.regconfigsend(regconfig) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regconfigsend(regconfig) is 'I/O';

alter function pg_catalog.regconfigsend(regconfig) owner to "kim-uijin";

create function pg_catalog.thesaurus_init(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_init(internal) is '(internal)';

alter function pg_catalog.thesaurus_init(internal) owner to "kim-uijin";

create function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) is '(internal)';

alter function pg_catalog.thesaurus_lexize(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, text, tsquery, text) returns text
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, text) is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, text, tsquery, unknown) returns text
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, text, tsquery, unknown) is 'generate headline';

alter function pg_catalog.ts_headline(regconfig, text, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.to_tsvector(regconfig, text) returns tsvector
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, text) is 'transform to tsvector';

alter function pg_catalog.to_tsvector(regconfig, text) owner to "kim-uijin";

create function pg_catalog.to_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(regconfig, text) is 'make tsquery';

alter function pg_catalog.to_tsquery(regconfig, text) owner to "kim-uijin";

create function pg_catalog.plainto_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(regconfig, text) is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(regconfig, text) owner to "kim-uijin";

create function pg_catalog.to_tsvector(text) returns tsvector
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(text) is 'transform to tsvector';

alter function pg_catalog.to_tsvector(text) owner to "kim-uijin";

create function pg_catalog.to_tsquery(text) returns tsquery
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsquery(text) is 'make tsquery';

alter function pg_catalog.to_tsquery(text) owner to "kim-uijin";

create function pg_catalog.plainto_tsquery(text) returns tsquery
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.plainto_tsquery(text) is 'transform to tsquery';

alter function pg_catalog.plainto_tsquery(text) owner to "kim-uijin";

create function pg_catalog.tsvector_update_trigger() returns trigger
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger() owner to "kim-uijin";

create function pg_catalog.tsvector_update_trigger_column() returns trigger
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsvector_update_trigger_column() is 'trigger for automatic update of tsvector column';

alter function pg_catalog.tsvector_update_trigger_column() owner to "kim-uijin";

create function pg_catalog.ts_headline(text, tsquery, text) returns text
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text, tsquery, text) is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(text, tsquery, unknown) returns text
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(text, tsquery, unknown) is 'generate headline';

alter function pg_catalog.ts_headline(text, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.pg_ts_parser_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_parser_is_visible(oid) is 'is text search parser visible in search path?';

alter function pg_catalog.pg_ts_parser_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_ts_dict_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_dict_is_visible(oid) is 'is text search dictionary visible in search path?';

alter function pg_catalog.pg_ts_dict_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_ts_config_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_config_is_visible(oid) is 'is text search configuration visible in search path?';

alter function pg_catalog.pg_ts_config_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.get_current_ts_config() returns regconfig
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.get_current_ts_config() is 'get current tsearch configuration';

alter function pg_catalog.get_current_ts_config() owner to "kim-uijin";

create function pg_catalog.ts_match_tt(text, text) returns boolean
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tt(text, text) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tt(text, text) owner to "kim-uijin";

create function pg_catalog.ts_match_tq(text, tsquery) returns boolean
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_match_tq(text, tsquery) is 'implementation of @@ operator';

alter function pg_catalog.ts_match_tq(text, tsquery) owner to "kim-uijin";

create function pg_catalog.pg_ts_template_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_ts_template_is_visible(oid) is 'is text search template visible in search path?';

alter function pg_catalog.pg_ts_template_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.regdictionaryin(cstring) returns regdictionary
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryin(cstring) is 'I/O';

alter function pg_catalog.regdictionaryin(cstring) owner to "kim-uijin";

create function pg_catalog.regdictionaryout(regdictionary) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryout(regdictionary) is 'I/O';

alter function pg_catalog.regdictionaryout(regdictionary) owner to "kim-uijin";

create function pg_catalog.regdictionaryrecv(internal) returns regdictionary
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionaryrecv(internal) is 'I/O';

alter function pg_catalog.regdictionaryrecv(internal) owner to "kim-uijin";

create function pg_catalog.regdictionarysend(regdictionary) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regdictionarysend(regdictionary) is 'I/O';

alter function pg_catalog.regdictionarysend(regdictionary) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset_shared(text) returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_shared(text) is 'statistics: reset collected statistics shared across the cluster';

alter function pg_catalog.pg_stat_reset_shared(text) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset_single_table_counters(oid) returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_table_counters(oid) is 'statistics: reset collected statistics for a single table or index in the current database';

alter function pg_catalog.pg_stat_reset_single_table_counters(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset_single_function_counters(oid) returns void
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_single_function_counters(oid) is 'statistics: reset collected statistics for a single function in the current database';

alter function pg_catalog.pg_stat_reset_single_function_counters(oid) owner to "kim-uijin";

create function pg_catalog.pg_tablespace_location(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_tablespace_location(oid) is 'tablespace location';

alter function pg_catalog.pg_tablespace_location(oid) owner to "kim-uijin";

create function pg_catalog.pg_create_physical_replication_slot(slot_name name, immediately_reserve boolean default false, temporary boolean default false, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn) is 'create a physical replication slot';

alter function pg_catalog.pg_create_physical_replication_slot(name, boolean, boolean, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_drop_replication_slot(name) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_drop_replication_slot(name) is 'drop a replication slot';

alter function pg_catalog.pg_drop_replication_slot(name) owner to "kim-uijin";

create function pg_catalog.pg_get_replication_slots(out slot_name name, out plugin name, out slot_type text, out datoid oid, out temporary boolean, out active boolean, out active_pid integer, out xmin xid, out catalog_xmin xid, out restart_lsn pg_lsn, out confirmed_flush_lsn pg_lsn, out wal_status text, out safe_wal_size bigint, out two_phase boolean) returns setof setof record
    stable
    parallel safe
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn, out text, out bigint, out boolean) is 'information about replication slots currently in use';

alter function pg_catalog.pg_get_replication_slots(out name, out name, out text, out oid, out boolean, out boolean, out integer, out xid, out xid, out pg_lsn, out pg_lsn, out text, out bigint, out boolean) owner to "kim-uijin";

create function pg_catalog.pg_logical_slot_get_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data text) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'get changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) owner to "kim-uijin";

create function pg_catalog.pg_logical_slot_get_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data bytea) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'get binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_get_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) owner to "kim-uijin";

create function pg_catalog.pg_logical_slot_peek_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data text) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) is 'peek at changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out text) owner to "kim-uijin";

create function pg_catalog.pg_logical_slot_peek_binary_changes(slot_name name, upto_lsn pg_lsn, upto_nchanges integer, options text[] default '{}'::text[], out lsn pg_lsn, out xid xid, out data bytea) returns setof setof record
    cost 1000
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) is 'peek at binary changes from replication slot';

alter function pg_catalog.pg_logical_slot_peek_binary_changes(name, pg_lsn, integer, text[], out pg_lsn, out xid, out bytea) owner to "kim-uijin";

create function pg_catalog.pg_create_logical_replication_slot(slot_name name, plugin name, temporary boolean default false, twophase boolean default false, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, boolean, out name, out pg_lsn) is 'set up a logical replication slot';

alter function pg_catalog.pg_create_logical_replication_slot(name, name, boolean, boolean, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.to_jsonb(anyelement) returns jsonb
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_jsonb(anyelement) is 'map input to jsonb';

alter function pg_catalog.to_jsonb(anyelement) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_snapshot_timestamp() returns timestamp with time zone
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_snapshot_timestamp() is 'statistics: timestamp of the current statistics snapshot';

alter function pg_catalog.pg_stat_get_snapshot_timestamp() owner to "kim-uijin";

create function pg_catalog.gin_clean_pending_list(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_clean_pending_list(regclass) is 'clean up GIN pending list';

alter function pg_catalog.gin_clean_pending_list(regclass) owner to "kim-uijin";

create function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) is 'GiST tsvector support (obsolete)';

alter function pg_catalog.gtsvector_consistent(internal, gtsvector, integer, oid, internal) owner to "kim-uijin";

create function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_extract_tsquery(tsquery, internal, smallint, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) is 'GIN tsvector support (obsolete)';

alter function pg_catalog.gin_tsquery_consistent(internal, smallint, tsquery, integer, internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) is 'GiST tsquery support (obsolete)';

alter function pg_catalog.gtsquery_consistent(internal, internal, integer, oid, internal) owner to "kim-uijin";

create function pg_catalog.inet_spg_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_config(internal, internal) is 'SP-GiST support';

alter function pg_catalog.inet_spg_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_spg_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_choose(internal, internal) is 'SP-GiST support';

alter function pg_catalog.inet_spg_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_spg_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_picksplit(internal, internal) is 'SP-GiST support';

alter function pg_catalog.inet_spg_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_spg_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_inner_consistent(internal, internal) is 'SP-GiST support';

alter function pg_catalog.inet_spg_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.inet_spg_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_spg_leaf_consistent(internal, internal) is 'SP-GiST support';

alter function pg_catalog.inet_spg_leaf_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.pg_current_logfile() returns text
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile() is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile() owner to "kim-uijin";

create function pg_catalog.pg_current_logfile(text) returns text
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_logfile(text) is 'current logging collector file location';

alter function pg_catalog.pg_current_logfile(text) owner to "kim-uijin";

create function pg_catalog.jsonb_send(jsonb) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_send(jsonb) is 'I/O';

alter function pg_catalog.jsonb_send(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_out(jsonb) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_out(jsonb) is 'I/O';

alter function pg_catalog.jsonb_out(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_recv(internal) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_recv(internal) is 'I/O';

alter function pg_catalog.jsonb_recv(internal) owner to "kim-uijin";

create function pg_catalog.jsonb_in(cstring) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_in(cstring) is 'I/O';

alter function pg_catalog.jsonb_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_get_function_arg_default(oid, integer) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_arg_default(oid, integer) is 'function argument default';

alter function pg_catalog.pg_get_function_arg_default(oid, integer) owner to "kim-uijin";

create function pg_catalog.pg_export_snapshot() returns text
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_export_snapshot() is 'export a snapshot';

alter function pg_catalog.pg_export_snapshot() owner to "kim-uijin";

create function pg_catalog.pg_is_in_recovery() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_recovery() is 'true if server is in recovery';

alter function pg_catalog.pg_is_in_recovery() owner to "kim-uijin";

create function pg_catalog.money(integer) returns money
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(integer) is 'convert int4 to money';

alter function pg_catalog.money(integer) owner to "kim-uijin";

create function pg_catalog.money(bigint) returns money
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(bigint) is 'convert int8 to money';

alter function pg_catalog.money(bigint) owner to "kim-uijin";

create function pg_catalog.pg_is_in_backup() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_is_in_backup() is 'true if server is in online backup';

alter function pg_catalog.pg_is_in_backup() owner to "kim-uijin";

create function pg_catalog.pg_backup_start_time() returns timestamp with time zone
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_backup_start_time() is 'start time of an online backup';

alter function pg_catalog.pg_backup_start_time() owner to "kim-uijin";

create function pg_catalog.pg_collation_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_collation_is_visible(oid) is 'is collation visible in search path?';

alter function pg_catalog.pg_collation_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.array_typanalyze(internal) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_typanalyze(internal) is 'array typanalyze';

alter function pg_catalog.array_typanalyze(internal) owner to "kim-uijin";

create function pg_catalog.arraycontsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontsel(internal, oid, internal, integer) is 'restriction selectivity for array-containment operators';

alter function pg_catalog.arraycontsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for array-containment operators';

alter function pg_catalog.arraycontjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.pg_get_multixact_members(multixid xid, out xid xid, out mode text) returns setof setof record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_multixact_members(xid, out xid, out text) is 'view members of a multixactid';

alter function pg_catalog.pg_get_multixact_members(xid, out xid, out text) owner to "kim-uijin";

create function pg_catalog.pg_last_wal_receive_lsn() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_receive_lsn() is 'current wal flush location';

alter function pg_catalog.pg_last_wal_receive_lsn() owner to "kim-uijin";

create function pg_catalog.pg_last_wal_replay_lsn() returns pg_lsn
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_wal_replay_lsn() is 'last wal replay location';

alter function pg_catalog.pg_last_wal_replay_lsn() owner to "kim-uijin";

create function pg_catalog.cash_div_cash(money, money) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cash_div_cash(money, money) is 'implementation of / operator';

alter function pg_catalog.cash_div_cash(money, money) owner to "kim-uijin";

create function pg_catalog.numeric(money, unknown) returns numeric
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numeric(money, unknown) is 'convert money to numeric';

alter function pg_catalog.numeric(money, unknown) owner to "kim-uijin";

create function pg_catalog.money(numeric) returns money
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.money(numeric) is 'convert numeric to money';

alter function pg_catalog.money(numeric) owner to "kim-uijin";

create function pg_catalog.pg_read_file(text, unknown, unknown) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file(text, unknown, unknown) is 'read text from a file';

alter function pg_catalog.pg_read_file(text, unknown, unknown) owner to "kim-uijin";

create function pg_catalog.pg_read_binary_file(text, bigint, bigint, unknown) returns bytea
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text, bigint, bigint, unknown) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text, bigint, bigint, unknown) owner to "kim-uijin";

create function pg_catalog.pg_read_binary_file(text) returns bytea
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_binary_file(text) is 'read bytea from a file';

alter function pg_catalog.pg_read_binary_file(text) owner to "kim-uijin";

create function pg_catalog.pg_opfamily_is_visible(oid) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_opfamily_is_visible(oid) is 'is opfamily visible in search path?';

alter function pg_catalog.pg_opfamily_is_visible(oid) owner to "kim-uijin";

create function pg_catalog.pg_last_xact_replay_timestamp() returns timestamp with time zone
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_last_xact_replay_timestamp() is 'timestamp of last replay xact';

alter function pg_catalog.pg_last_xact_replay_timestamp() owner to "kim-uijin";

create function pg_catalog.anyrange_in(cstring, oid, integer) returns anyrange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.anyrange_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.anyrange_out(anyrange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anyrange_out(anyrange) is 'I/O';

alter function pg_catalog.anyrange_out(anyrange) owner to "kim-uijin";

create function pg_catalog.range_in(cstring, oid, integer) returns anyrange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.range_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.range_out(anyrange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_out(anyrange) is 'I/O';

alter function pg_catalog.range_out(anyrange) owner to "kim-uijin";

create function pg_catalog.range_recv(internal, oid, integer) returns anyrange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.range_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.range_send(anyrange) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_send(anyrange) is 'I/O';

alter function pg_catalog.range_send(anyrange) owner to "kim-uijin";

create function pg_catalog.pg_identify_object(classid oid, objid oid, objsubid integer, out type text, out schema text, out name text, out identity text) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text) is 'get machine-parseable identification of SQL object';

alter function pg_catalog.pg_identify_object(oid, oid, integer, out text, out text, out text, out text) owner to "kim-uijin";

create function pg_catalog.int4range(integer, integer) returns int4range
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(integer, integer) is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer) owner to "kim-uijin";

create function pg_catalog.int4range(integer, integer, text) returns int4range
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range(integer, integer, text) is 'int4range constructor';

alter function pg_catalog.int4range(integer, integer, text) owner to "kim-uijin";

create function pg_catalog.pg_relation_is_updatable(regclass, boolean) returns integer
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_updatable(regclass, boolean) is 'is a relation insertable/updatable/deletable';

alter function pg_catalog.pg_relation_is_updatable(regclass, boolean) owner to "kim-uijin";

create function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) returns boolean
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) is 'is a column updatable';

alter function pg_catalog.pg_column_is_updatable(regclass, smallint, boolean) owner to "kim-uijin";

create function pg_catalog.numrange(numeric, numeric) returns numrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(numeric, numeric) is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.numrange(numeric, numeric, text) returns numrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange(numeric, numeric, text) is 'numrange constructor';

alter function pg_catalog.numrange(numeric, numeric, text) owner to "kim-uijin";

create function pg_catalog.make_date(year integer, month integer, day integer) returns date
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_date(integer, integer, integer) is 'construct date';

alter function pg_catalog.make_date(integer, integer, integer) owner to "kim-uijin";

create function pg_catalog.make_time(hour integer, min integer, sec double precision) returns time
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.make_time(integer, integer, double precision) is 'construct time';

alter function pg_catalog.make_time(integer, integer, double precision) owner to "kim-uijin";

create function pg_catalog.lower(anyrange) returns anyelement
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(anyrange) is 'lower bound of range';

alter function pg_catalog.lower(anyrange) owner to "kim-uijin";

create function pg_catalog.upper(anyrange) returns anyelement
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(anyrange) is 'upper bound of range';

alter function pg_catalog.upper(anyrange) owner to "kim-uijin";

create function pg_catalog.isempty(anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty(anyrange) is 'is the range empty?';

alter function pg_catalog.isempty(anyrange) owner to "kim-uijin";

create function pg_catalog.lower_inc(anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc(anyrange) is 'is the range''s lower bound inclusive?';

alter function pg_catalog.lower_inc(anyrange) owner to "kim-uijin";

create function pg_catalog.upper_inc(anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc(anyrange) is 'is the range''s upper bound inclusive?';

alter function pg_catalog.upper_inc(anyrange) owner to "kim-uijin";

create function pg_catalog.lower_inf(anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf(anyrange) is 'is the range''s lower bound infinite?';

alter function pg_catalog.lower_inf(anyrange) owner to "kim-uijin";

create function pg_catalog.upper_inf(anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf(anyrange) is 'is the range''s upper bound infinite?';

alter function pg_catalog.upper_inf(anyrange) owner to "kim-uijin";

create function pg_catalog.range_eq(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_eq(anyrange, anyrange) is 'implementation of = operator';

alter function pg_catalog.range_eq(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_ne(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ne(anyrange, anyrange) is 'implementation of <> operator';

alter function pg_catalog.range_ne(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_overlaps(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps(anyrange, anyrange) is 'implementation of && operator';

alter function pg_catalog.range_overlaps(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_contains_elem(anyrange, anyelement) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_elem(anyrange, anyelement) is 'implementation of @> operator';

alter function pg_catalog.range_contains_elem(anyrange, anyelement) owner to "kim-uijin";

create function pg_catalog.range_contains(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains(anyrange, anyrange) is 'implementation of @> operator';

alter function pg_catalog.range_contains(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.elem_contained_by_range(anyelement, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_range(anyelement, anyrange) is 'implementation of <@ operator';

alter function pg_catalog.elem_contained_by_range(anyelement, anyrange) owner to "kim-uijin";

create function pg_catalog.range_contained_by(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by(anyrange, anyrange) is 'implementation of <@ operator';

alter function pg_catalog.range_contained_by(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_adjacent(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent(anyrange, anyrange) is 'implementation of -|- operator';

alter function pg_catalog.range_adjacent(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_before(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before(anyrange, anyrange) is 'implementation of << operator';

alter function pg_catalog.range_before(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_after(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after(anyrange, anyrange) is 'implementation of >> operator';

alter function pg_catalog.range_after(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_overleft(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft(anyrange, anyrange) is 'implementation of &< operator';

alter function pg_catalog.range_overleft(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_overright(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright(anyrange, anyrange) is 'implementation of &> operator';

alter function pg_catalog.range_overright(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_union(anyrange, anyrange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_union(anyrange, anyrange) is 'implementation of + operator';

alter function pg_catalog.range_union(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_intersect(anyrange, anyrange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect(anyrange, anyrange) is 'implementation of * operator';

alter function pg_catalog.range_intersect(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_minus(anyrange, anyrange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_minus(anyrange, anyrange) is 'implementation of - operator';

alter function pg_catalog.range_minus(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_cmp(anyrange, anyrange) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_cmp(anyrange, anyrange) is 'less-equal-greater';

alter function pg_catalog.range_cmp(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_lt(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_lt(anyrange, anyrange) is 'implementation of < operator';

alter function pg_catalog.range_lt(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_le(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_le(anyrange, anyrange) is 'implementation of <= operator';

alter function pg_catalog.range_le(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_ge(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_ge(anyrange, anyrange) is 'implementation of >= operator';

alter function pg_catalog.range_ge(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_gt(anyrange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gt(anyrange, anyrange) is 'implementation of > operator';

alter function pg_catalog.range_gt(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.range_gist_union(internal, internal) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_union(internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_union(internal, internal) owner to "kim-uijin";

create function pg_catalog.pg_replication_slot_advance(slot_name name, upto_lsn pg_lsn, out slot_name name, out end_lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_slot_advance(name, pg_lsn, out name, out pg_lsn) is 'advance logical replication slot';

alter function pg_catalog.pg_replication_slot_advance(name, pg_lsn, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.range_gist_penalty(internal, internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_penalty(internal, internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_penalty(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.range_gist_picksplit(internal, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_picksplit(internal, internal) is 'GiST support';

alter function pg_catalog.range_gist_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.range_gist_same(anyrange, anyrange, internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_gist_same(anyrange, anyrange, internal) is 'GiST support';

alter function pg_catalog.range_gist_same(anyrange, anyrange, internal) owner to "kim-uijin";

create function pg_catalog.hash_range(anyrange) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_range(anyrange) is 'hash a range';

alter function pg_catalog.hash_range(anyrange) owner to "kim-uijin";

create function pg_catalog.int4range_canonical(int4range) returns int4range
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_canonical(int4range) is 'convert an int4 range to canonical form';

alter function pg_catalog.int4range_canonical(int4range) owner to "kim-uijin";

create function pg_catalog.daterange_canonical(daterange) returns daterange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_canonical(daterange) is 'convert a date range to canonical form';

alter function pg_catalog.daterange_canonical(daterange) owner to "kim-uijin";

create function pg_catalog.range_typanalyze(internal) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_typanalyze(internal) is 'range typanalyze';

alter function pg_catalog.range_typanalyze(internal) owner to "kim-uijin";

create function pg_catalog.timestamp_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.timestamp_support(internal) is 'planner support for timestamp length coercion';

alter function pg_catalog.timestamp_support(internal) owner to "kim-uijin";

create function pg_catalog.interval_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.interval_support(internal) is 'planner support for interval length coercion';

alter function pg_catalog.interval_support(internal) owner to "kim-uijin";

create function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) is 'GIN array support';

alter function pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) returns "char"
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) is 'GIN tsvector support';

alter function pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.int4range_subdiff(integer, integer) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4range_subdiff(integer, integer) is 'float8 difference of two int4 values';

alter function pg_catalog.int4range_subdiff(integer, integer) owner to "kim-uijin";

create function pg_catalog.int8range_subdiff(bigint, bigint) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_subdiff(bigint, bigint) is 'float8 difference of two int8 values';

alter function pg_catalog.int8range_subdiff(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.numrange_subdiff(numeric, numeric) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.numrange_subdiff(numeric, numeric) is 'float8 difference of two numeric values';

alter function pg_catalog.numrange_subdiff(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.daterange_subdiff(date, date) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange_subdiff(date, date) is 'float8 difference of two date values';

alter function pg_catalog.daterange_subdiff(date, date) owner to "kim-uijin";

create function pg_catalog.int8range_canonical(int8range) returns int8range
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range_canonical(int8range) is 'convert an int8 range to canonical form';

alter function pg_catalog.int8range_canonical(int8range) owner to "kim-uijin";

create function pg_catalog.tsrange_subdiff(timestamp, timestamp) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange_subdiff(timestamp, timestamp) is 'float8 difference of two timestamp values';

alter function pg_catalog.tsrange_subdiff(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) is 'float8 difference of two timestamp with time zone values';

alter function pg_catalog.tstzrange_subdiff(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.jsonb_object_keys(jsonb) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_object_keys(jsonb) is 'get jsonb object keys';

alter function pg_catalog.jsonb_object_keys(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_each_text(from_json jsonb, out key text, out value text) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_each_text(jsonb, out text, out text) is 'key value pairs of a jsonb object';

alter function pg_catalog.jsonb_each_text(jsonb, out text, out text) owner to "kim-uijin";

create function pg_catalog.tsrange(timestamp, timestamp) returns tsrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(timestamp, timestamp) is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.tsrange(timestamp, timestamp, text) returns tsrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsrange(timestamp, timestamp, text) is 'tsrange constructor';

alter function pg_catalog.tsrange(timestamp, timestamp, text) owner to "kim-uijin";

create function pg_catalog.pg_sleep_for(interval) returns void
    strict
    parallel safe
    cost 1
    language sql
RETURN pg_sleep(((EXTRACT(epoch FROM (clock_timestamp() + $1)) - EXTRACT(epoch FROM clock_timestamp())))::double precision);

comment on function pg_catalog.pg_sleep_for(interval) is 'sleep for the specified interval';

alter function pg_catalog.pg_sleep_for(interval) owner to "kim-uijin";

create function pg_catalog.pg_sleep_until(timestamp with time zone) returns void
    strict
    parallel safe
    cost 1
    language sql
RETURN pg_sleep(((EXTRACT(epoch FROM $1) - EXTRACT(epoch FROM clock_timestamp())))::double precision);

comment on function pg_catalog.pg_sleep_until(timestamp with time zone) is 'sleep until the specified time';

alter function pg_catalog.pg_sleep_until(timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) returns tstzrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) returns tstzrange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) is 'tstzrange constructor';

alter function pg_catalog.tstzrange(timestamp with time zone, timestamp with time zone, text) owner to "kim-uijin";

create function pg_catalog.mxid_age(xid) returns integer
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mxid_age(xid) is 'age of a multi-transaction ID, in multi-transactions before current multi-transaction';

alter function pg_catalog.mxid_age(xid) owner to "kim-uijin";

create function pg_catalog.jsonb_extract_path_text(from_json jsonb, path_elems text[]) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_extract_path_text(jsonb, text[]) is 'get value from jsonb as text with path elements';

alter function pg_catalog.jsonb_extract_path_text(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.daterange(date, date) returns daterange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(date, date) is 'daterange constructor';

alter function pg_catalog.daterange(date, date) owner to "kim-uijin";

create function pg_catalog.daterange(date, date, text) returns daterange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.daterange(date, date, text) is 'daterange constructor';

alter function pg_catalog.daterange(date, date, text) owner to "kim-uijin";

create function pg_catalog.acldefault("char", oid) returns aclitem[]
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.acldefault("char", oid) is 'show hardwired default privileges, primarily for use by the information schema';

alter function pg_catalog.acldefault("char", oid) owner to "kim-uijin";

create function pg_catalog.time_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.time_support(internal) is 'planner support for time length coercion';

alter function pg_catalog.time_support(internal) owner to "kim-uijin";

create function pg_catalog.int8range(bigint, bigint) returns int8range
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(bigint, bigint) is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.int8range(bigint, bigint, text) returns int8range
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8range(bigint, bigint, text) is 'int8range constructor';

alter function pg_catalog.int8range(bigint, bigint, text) owner to "kim-uijin";

create function pg_catalog.json_object_field(from_json json, field_name text) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field(json, text) is 'implementation of -> operator';

alter function pg_catalog.json_object_field(json, text) owner to "kim-uijin";

create function pg_catalog.json_object_field_text(from_json json, field_name text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_object_field_text(json, text) is 'implementation of ->> operator';

alter function pg_catalog.json_object_field_text(json, text) owner to "kim-uijin";

create function pg_catalog.json_array_element(from_json json, element_index integer) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element(json, integer) is 'implementation of -> operator';

alter function pg_catalog.json_array_element(json, integer) owner to "kim-uijin";

create function pg_catalog.json_array_element_text(from_json json, element_index integer) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_element_text(json, integer) is 'implementation of ->> operator';

alter function pg_catalog.json_array_element_text(json, integer) owner to "kim-uijin";

create function pg_catalog.json_extract_path(from_json json, path_elems text[]) returns json
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path(json, text[]) is 'get value from json with path elements';

alter function pg_catalog.json_extract_path(json, text[]) owner to "kim-uijin";

create function pg_catalog.brin_summarize_new_values(regclass) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_new_values(regclass) is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_new_values(regclass) owner to "kim-uijin";

create function pg_catalog.json_extract_path_text(from_json json, path_elems text[]) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_extract_path_text(json, text[]) is 'get value from json as text with path elements';

alter function pg_catalog.json_extract_path_text(json, text[]) owner to "kim-uijin";

create function pg_catalog.pg_get_object_address(type text, object_names text[], object_args text[], out classid oid, out objid oid, out objsubid integer) returns record
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_object_address(text, text[], text[], out oid, out oid, out integer) is 'get OID-based object address from name/args arrays';

alter function pg_catalog.pg_get_object_address(text, text[], text[], out oid, out oid, out integer) owner to "kim-uijin";

create function pg_catalog.json_array_elements(from_json json, out value json) returns setof setof json
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_array_elements(json, out json) is 'key value pairs of a json object';

alter function pg_catalog.json_array_elements(json, out json) owner to "kim-uijin";

create function pg_catalog.json_array_length(json) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_array_length(json) is 'length of json array';

alter function pg_catalog.json_array_length(json) owner to "kim-uijin";

create function pg_catalog.json_object_keys(json) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_object_keys(json) is 'get json object keys';

alter function pg_catalog.json_object_keys(json) owner to "kim-uijin";

create function pg_catalog.json_each(from_json json, out key text, out value json) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_each(json, out text, out json) is 'key value pairs of a json object';

alter function pg_catalog.json_each(json, out text, out json) owner to "kim-uijin";

create function pg_catalog.json_each_text(from_json json, out key text, out value text) returns setof setof record
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_each_text(json, out text, out text) is 'key value pairs of a json object';

alter function pg_catalog.json_each_text(json, out text, out text) owner to "kim-uijin";

create function pg_catalog.json_populate_record(base anyelement, from_json json, use_json_as_text boolean default false) returns anyelement
    stable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_populate_record(anyelement, json, boolean) is 'get record fields from a json object';

alter function pg_catalog.json_populate_record(anyelement, json, boolean) owner to "kim-uijin";

create function pg_catalog.json_populate_recordset(base anyelement, from_json json, use_json_as_text boolean default false) returns setof setof anyelement
    stable
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_populate_recordset(anyelement, json, boolean) is 'get set of records with fields from a json array of objects';

alter function pg_catalog.json_populate_recordset(anyelement, json, boolean) owner to "kim-uijin";

create function pg_catalog.json_typeof(json) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_typeof(json) is 'get the type of a json value';

alter function pg_catalog.json_typeof(json) owner to "kim-uijin";

create function pg_catalog.json_array_elements_text(from_json json, out value text) returns setof setof text
    immutable
    strict
    parallel safe
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.json_array_elements_text(json, out text) is 'elements of json array';

alter function pg_catalog.json_array_elements_text(json, out text) owner to "kim-uijin";

create function pg_catalog.ordered_set_transition(internal, "any") returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition(internal, "any") is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition(internal, "any") owner to "kim-uijin";

create function pg_catalog.ordered_set_transition_multi(internal, "any") returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ordered_set_transition_multi(internal, "any") is 'aggregate transition function';

alter function pg_catalog.ordered_set_transition_multi(internal, "any") owner to "kim-uijin";

create function pg_catalog.percentile_disc_final(internal, double precision, anyelement) returns anyelement
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_final(internal, double precision, anyelement) is 'aggregate final function';

alter function pg_catalog.percentile_disc_final(internal, double precision, anyelement) owner to "kim-uijin";

create function pg_catalog.percentile_cont_float8_final(internal, double precision) returns double precision
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_final(internal, double precision) is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_final(internal, double precision) owner to "kim-uijin";

create function pg_catalog.percentile_cont_interval_final(internal, double precision) returns interval
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_final(internal, double precision) is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_final(internal, double precision) owner to "kim-uijin";

create function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) returns anyarray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) is 'aggregate final function';

alter function pg_catalog.percentile_disc_multi_final(internal, double precision[], anyelement) owner to "kim-uijin";

create function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) returns double precision[]
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) is 'aggregate final function';

alter function pg_catalog.percentile_cont_float8_multi_final(internal, double precision[]) owner to "kim-uijin";

create function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) returns interval[]
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) is 'aggregate final function';

alter function pg_catalog.percentile_cont_interval_multi_final(internal, double precision[]) owner to "kim-uijin";

create function pg_catalog.mode_final(internal, anyelement) returns anyelement
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mode_final(internal, anyelement) is 'aggregate final function';

alter function pg_catalog.mode_final(internal, anyelement) owner to "kim-uijin";

create function pg_catalog.rank_final(internal, "any") returns bigint
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.rank_final(internal, "any") owner to "kim-uijin";

create function pg_catalog.percent_rank_final(internal, "any") returns double precision
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.percent_rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.percent_rank_final(internal, "any") owner to "kim-uijin";

create function pg_catalog.cume_dist_final(internal, "any") returns double precision
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.cume_dist_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.cume_dist_final(internal, "any") owner to "kim-uijin";

create function pg_catalog.dense_rank_final(internal, "any") returns bigint
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.dense_rank_final(internal, "any") is 'aggregate final function';

alter function pg_catalog.dense_rank_final(internal, "any") owner to "kim-uijin";

create function pg_catalog.generate_series_int4_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int4_support(internal) is 'planner support for generate_series';

alter function pg_catalog.generate_series_int4_support(internal) owner to "kim-uijin";

create function pg_catalog.generate_series_int8_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.generate_series_int8_support(internal) is 'planner support for generate_series';

alter function pg_catalog.generate_series_int8_support(internal) owner to "kim-uijin";

create function pg_catalog.array_unnest_support(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_unnest_support(internal) is 'planner support for array_unnest';

alter function pg_catalog.array_unnest_support(internal) owner to "kim-uijin";

create function pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.gist_box_distance(internal, box, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.brin_summarize_range(regclass, bigint) returns integer
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_summarize_range(regclass, bigint) is 'brin: standalone scan new table pages';

alter function pg_catalog.brin_summarize_range(regclass, bigint) owner to "kim-uijin";

create function pg_catalog.jsonpath_in(cstring) returns jsonpath
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_in(cstring) is 'I/O';

alter function pg_catalog.jsonpath_in(cstring) owner to "kim-uijin";

create function pg_catalog.jsonpath_recv(internal) returns jsonpath
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_recv(internal) is 'I/O';

alter function pg_catalog.jsonpath_recv(internal) owner to "kim-uijin";

create function pg_catalog.jsonpath_out(jsonpath) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_out(jsonpath) is 'I/O';

alter function pg_catalog.jsonpath_out(jsonpath) owner to "kim-uijin";

create function pg_catalog.jsonpath_send(jsonpath) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonpath_send(jsonpath) is 'I/O';

alter function pg_catalog.jsonpath_send(jsonpath) owner to "kim-uijin";

create function pg_catalog.jsonb_path_exists(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists(jsonb, jsonpath, jsonb, boolean) is 'jsonpath exists test';

alter function pg_catalog.jsonb_path_exists(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns setof setof jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.jsonb_path_query(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query';

alter function pg_catalog.jsonb_path_query(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query_array(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_array(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query wrapped into array';

alter function pg_catalog.jsonb_path_query_array(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_query_first(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns jsonb
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_query_first(jsonb, jsonpath, jsonb, boolean) is 'jsonpath query first item';

alter function pg_catalog.jsonb_path_query_first(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_match(target jsonb, path jsonpath, vars jsonb default '{}'::jsonb, silent boolean default false) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match(jsonb, jsonpath, jsonb, boolean) is 'jsonpath match';

alter function pg_catalog.jsonb_path_match(jsonb, jsonpath, jsonb, boolean) owner to "kim-uijin";

create function pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) is 'implementation of @? operator';

alter function pg_catalog.jsonb_path_exists_opr(jsonb, jsonpath) owner to "kim-uijin";

create function pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) is 'implementation of @@ operator';

alter function pg_catalog.jsonb_path_match_opr(jsonb, jsonpath) owner to "kim-uijin";

create function pg_catalog.brin_desummarize_range(regclass, bigint) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_desummarize_range(regclass, bigint) is 'brin: desummarize page range';

alter function pg_catalog.brin_desummarize_range(regclass, bigint) owner to "kim-uijin";

create function pg_catalog.spg_quad_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_config(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_quad_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_choose(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_quad_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over point';

alter function pg_catalog.spg_quad_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree and k-d tree over point';

alter function pg_catalog.spg_quad_leaf_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_kd_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_config(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_kd_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_choose(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_kd_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_picksplit(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_kd_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_kd_inner_consistent(internal, internal) is 'SP-GiST support for k-d tree over point';

alter function pg_catalog.spg_kd_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_text_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_config(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_text_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_choose(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_text_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_picksplit(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_text_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_inner_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_text_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_text_leaf_consistent(internal, internal) is 'SP-GiST support for radix tree over text';

alter function pg_catalog.spg_text_leaf_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.pg_sequence_last_value(regclass) returns bigint
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_sequence_last_value(regclass) is 'sequence last value';

alter function pg_catalog.pg_sequence_last_value(regclass) owner to "kim-uijin";

create function pg_catalog.jsonb_ne(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ne(jsonb, jsonb) is 'implementation of <> operator';

alter function pg_catalog.jsonb_ne(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_lt(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_lt(jsonb, jsonb) is 'implementation of < operator';

alter function pg_catalog.jsonb_lt(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_gt(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_gt(jsonb, jsonb) is 'implementation of > operator';

alter function pg_catalog.jsonb_gt(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_le(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_le(jsonb, jsonb) is 'implementation of <= operator';

alter function pg_catalog.jsonb_le(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_ge(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_ge(jsonb, jsonb) is 'implementation of >= operator';

alter function pg_catalog.jsonb_ge(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_eq(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_eq(jsonb, jsonb) is 'implementation of = operator';

alter function pg_catalog.jsonb_eq(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_cmp(jsonb, jsonb) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_cmp(jsonb, jsonb) is 'less-equal-greater';

alter function pg_catalog.jsonb_cmp(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_hash(jsonb) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_hash(jsonb) is 'hash';

alter function pg_catalog.jsonb_hash(jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_contains(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contains(jsonb, jsonb) is 'implementation of @> operator';

alter function pg_catalog.jsonb_contains(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.jsonb_exists(jsonb, text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists(jsonb, text) is 'implementation of ? operator';

alter function pg_catalog.jsonb_exists(jsonb, text) owner to "kim-uijin";

create function pg_catalog.jsonb_exists_any(jsonb, text[]) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_any(jsonb, text[]) is 'implementation of ?| operator';

alter function pg_catalog.jsonb_exists_any(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.jsonb_exists_all(jsonb, text[]) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_exists_all(jsonb, text[]) is 'implementation of ?& operator';

alter function pg_catalog.jsonb_exists_all(jsonb, text[]) owner to "kim-uijin";

create function pg_catalog.jsonb_contained(jsonb, jsonb) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_contained(jsonb, jsonb) is 'implementation of <@ operator';

alter function pg_catalog.jsonb_contained(jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.array_agg_array_transfn(internal, anyarray) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_transfn(internal, anyarray) is 'aggregate transition function';

alter function pg_catalog.array_agg_array_transfn(internal, anyarray) owner to "kim-uijin";

create function pg_catalog.array_agg_array_finalfn(internal, anyarray) returns anyarray
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_agg_array_finalfn(internal, anyarray) is 'aggregate final function';

alter function pg_catalog.array_agg_array_finalfn(internal, anyarray) owner to "kim-uijin";

create function pg_catalog.range_merge(anyrange, anyrange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge(anyrange, anyrange) is 'the smallest range which includes both of the given ranges';

alter function pg_catalog.range_merge(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.inet_merge(inet, inet) returns cidr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_merge(inet, inet) is 'the smallest network which includes both of the given networks';

alter function pg_catalog.inet_merge(inet, inet) owner to "kim-uijin";

create function pg_catalog.bound_box(box, box) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bound_box(box, box) is 'bounding box of two boxes';

alter function pg_catalog.bound_box(box, box) owner to "kim-uijin";

create function pg_catalog.inet_same_family(inet, inet) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.inet_same_family(inet, inet) is 'are the addresses from the same family?';

alter function pg_catalog.inet_same_family(inet, inet) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_record_init_privs(boolean) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_record_init_privs(boolean) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_record_init_privs(boolean) owner to "kim-uijin";

create function pg_catalog.regnamespacein(cstring) returns regnamespace
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacein(cstring) is 'I/O';

alter function pg_catalog.regnamespacein(cstring) owner to "kim-uijin";

create function pg_catalog.regnamespaceout(regnamespace) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespaceout(regnamespace) is 'I/O';

alter function pg_catalog.regnamespaceout(regnamespace) owner to "kim-uijin";

create function pg_catalog.to_regnamespace(text) returns regnamespace
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regnamespace(text) is 'convert namespace name to regnamespace';

alter function pg_catalog.to_regnamespace(text) owner to "kim-uijin";

create function pg_catalog.regnamespacerecv(internal) returns regnamespace
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacerecv(internal) is 'I/O';

alter function pg_catalog.regnamespacerecv(internal) owner to "kim-uijin";

create function pg_catalog.regnamespacesend(regnamespace) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regnamespacesend(regnamespace) is 'I/O';

alter function pg_catalog.regnamespacesend(regnamespace) owner to "kim-uijin";

create function pg_catalog.box(point) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.box(point) is 'convert point to empty box';

alter function pg_catalog.box(point) owner to "kim-uijin";

create function pg_catalog.regroleout(regrole) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regroleout(regrole) is 'I/O';

alter function pg_catalog.regroleout(regrole) owner to "kim-uijin";

create function pg_catalog.to_regrole(text) returns regrole
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regrole(text) is 'convert role name to regrole';

alter function pg_catalog.to_regrole(text) owner to "kim-uijin";

create function pg_catalog.regrolerecv(internal) returns regrole
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolerecv(internal) is 'I/O';

alter function pg_catalog.regrolerecv(internal) owner to "kim-uijin";

create function pg_catalog.regrolesend(regrole) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolesend(regrole) is 'I/O';

alter function pg_catalog.regrolesend(regrole) owner to "kim-uijin";

create function pg_catalog.regrolein(cstring) returns regrole
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regrolein(cstring) is 'I/O';

alter function pg_catalog.regrolein(cstring) owner to "kim-uijin";

create function pg_catalog.pg_rotate_logfile_old() returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_rotate_logfile_old() is 'rotate log file - old version for adminpack 1.0';

alter function pg_catalog.pg_rotate_logfile_old() owner to "kim-uijin";

create function pg_catalog.pg_read_file_old(text, bigint, bigint) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_read_file_old(text, bigint, bigint) is 'read text from a file - old version for adminpack 1.0';

alter function pg_catalog.pg_read_file_old(text, bigint, bigint) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_missing_value(oid, text, text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_missing_value(oid, text, text) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_missing_value(oid, text, text) owner to "kim-uijin";

create function pg_catalog.brin_inclusion_opcinfo(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_opcinfo(internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_opcinfo(internal) owner to "kim-uijin";

create function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_inclusion_consistent(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_consistent(internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_consistent(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_inclusion_union(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_inclusion_union(internal, internal, internal) is 'BRIN inclusion support';

alter function pg_catalog.brin_inclusion_union(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.macaddr8_in(cstring) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_in(cstring) is 'I/O';

alter function pg_catalog.macaddr8_in(cstring) owner to "kim-uijin";

create function pg_catalog.macaddr8_out(macaddr8) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_out(macaddr8) is 'I/O';

alter function pg_catalog.macaddr8_out(macaddr8) owner to "kim-uijin";

create function pg_catalog.trunc(macaddr8, unknown) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trunc(macaddr8, unknown) is 'MACADDR8 manufacturer fields';

alter function pg_catalog.trunc(macaddr8, unknown) owner to "kim-uijin";

create function pg_catalog.macaddr8_eq(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_eq(macaddr8, macaddr8) is 'implementation of = operator';

alter function pg_catalog.macaddr8_eq(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_lt(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_lt(macaddr8, macaddr8) is 'implementation of < operator';

alter function pg_catalog.macaddr8_lt(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_le(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_le(macaddr8, macaddr8) is 'implementation of <= operator';

alter function pg_catalog.macaddr8_le(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_gt(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_gt(macaddr8, macaddr8) is 'implementation of > operator';

alter function pg_catalog.macaddr8_gt(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_ge(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ge(macaddr8, macaddr8) is 'implementation of >= operator';

alter function pg_catalog.macaddr8_ge(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_ne(macaddr8, macaddr8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_ne(macaddr8, macaddr8) is 'implementation of <> operator';

alter function pg_catalog.macaddr8_ne(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_cmp(macaddr8, macaddr8) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_cmp(macaddr8, macaddr8) is 'less-equal-greater';

alter function pg_catalog.macaddr8_cmp(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_not(macaddr8) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_not(macaddr8) is 'implementation of ~ operator';

alter function pg_catalog.macaddr8_not(macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_and(macaddr8, macaddr8) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_and(macaddr8, macaddr8) is 'implementation of & operator';

alter function pg_catalog.macaddr8_and(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_or(macaddr8, macaddr8) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_or(macaddr8, macaddr8) is 'implementation of | operator';

alter function pg_catalog.macaddr8_or(macaddr8, macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8(macaddr) returns macaddr8
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8(macaddr) is 'convert macaddr to macaddr8';

alter function pg_catalog.macaddr8(macaddr) owner to "kim-uijin";

create function pg_catalog.macaddr(macaddr8) returns macaddr
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr(macaddr8) is 'convert macaddr8 to macaddr';

alter function pg_catalog.macaddr(macaddr8) owner to "kim-uijin";

create function pg_catalog.macaddr8_set7bit(macaddr8) returns macaddr8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.macaddr8_set7bit(macaddr8) is 'set 7th bit in macaddr8';

alter function pg_catalog.macaddr8_set7bit(macaddr8) owner to "kim-uijin";

create function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(integer, integer, bigint, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, bigint, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(integer, integer, bigint, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(integer, integer, integer, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, integer, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(integer, integer, integer, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(integer, integer, smallint, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(integer, integer, smallint, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(integer, integer, smallint, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, integer, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(date, date, interval, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(date, date, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(date, date, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(interval, interval, interval, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(interval, interval, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(interval, interval, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(time, time, interval, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time, time, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(time, time, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(real, real, double precision, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(real, real, double precision, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(real, real, double precision, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) is 'window RANGE support';

alter function pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean) owner to "kim-uijin";

create function pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) is 'larger of two';

alter function pg_catalog.pg_lsn_larger(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) is 'smaller of two';

alter function pg_catalog.pg_lsn_smaller(pg_lsn, pg_lsn) owner to "kim-uijin";

create function pg_catalog.regcollationin(cstring) returns regcollation
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationin(cstring) is 'I/O';

alter function pg_catalog.regcollationin(cstring) owner to "kim-uijin";

create function pg_catalog.regcollationout(regcollation) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationout(regcollation) is 'I/O';

alter function pg_catalog.regcollationout(regcollation) owner to "kim-uijin";

create function pg_catalog.to_regcollation(text) returns regcollation
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_regcollation(text) is 'convert classname to regcollation';

alter function pg_catalog.to_regcollation(text) owner to "kim-uijin";

create function pg_catalog.regcollationrecv(internal) returns regcollation
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationrecv(internal) is 'I/O';

alter function pg_catalog.regcollationrecv(internal) owner to "kim-uijin";

create function pg_catalog.regcollationsend(regcollation) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.regcollationsend(regcollation) is 'I/O';

alter function pg_catalog.regcollationsend(regcollation) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) returns jsonb
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(regconfig, jsonb, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, jsonb, tsquery, unknown) returns jsonb
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, jsonb, tsquery, unknown) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(regconfig, jsonb, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_headline(jsonb, tsquery, text) returns jsonb
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, tsquery, text) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(jsonb, tsquery, unknown) returns jsonb
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(jsonb, tsquery, unknown) is 'generate headline from jsonb';

alter function pg_catalog.ts_headline(jsonb, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, json, tsquery, text) returns json
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery, text) is 'generate headline from json';

alter function pg_catalog.ts_headline(regconfig, json, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(regconfig, json, tsquery, unknown) returns json
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(regconfig, json, tsquery, unknown) is 'generate headline from json';

alter function pg_catalog.ts_headline(regconfig, json, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.ts_headline(json, tsquery, text) returns json
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, tsquery, text) is 'generate headline from json';

alter function pg_catalog.ts_headline(json, tsquery, text) owner to "kim-uijin";

create function pg_catalog.ts_headline(json, tsquery, unknown) returns json
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ts_headline(json, tsquery, unknown) is 'generate headline from json';

alter function pg_catalog.ts_headline(json, tsquery, unknown) owner to "kim-uijin";

create function pg_catalog.to_tsvector(jsonb, unknown) returns tsvector
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(jsonb, unknown) is 'transform string values from jsonb to tsvector';

alter function pg_catalog.to_tsvector(jsonb, unknown) owner to "kim-uijin";

create function pg_catalog.to_tsvector(json) returns tsvector
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(json) is 'transform string values from json to tsvector';

alter function pg_catalog.to_tsvector(json) owner to "kim-uijin";

create function pg_catalog.to_tsvector(regconfig, jsonb) returns tsvector
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, jsonb) is 'transform string values from jsonb to tsvector';

alter function pg_catalog.to_tsvector(regconfig, jsonb) owner to "kim-uijin";

create function pg_catalog.to_tsvector(regconfig, json) returns tsvector
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.to_tsvector(regconfig, json) is 'transform string values from json to tsvector';

alter function pg_catalog.to_tsvector(regconfig, json) owner to "kim-uijin";

create function pg_catalog.jsonb_to_tsvector(jsonb, jsonb, unknown) returns tsvector
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(jsonb, jsonb, unknown) is 'transform specified values from jsonb to tsvector';

alter function pg_catalog.jsonb_to_tsvector(jsonb, jsonb, unknown) owner to "kim-uijin";

create function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) returns tsvector
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) is 'transform specified values from jsonb to tsvector';

alter function pg_catalog.jsonb_to_tsvector(regconfig, jsonb, jsonb) owner to "kim-uijin";

create function pg_catalog.json_to_tsvector(json, jsonb, unknown) returns tsvector
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(json, jsonb, unknown) is 'transform specified values from json to tsvector';

alter function pg_catalog.json_to_tsvector(json, jsonb, unknown) owner to "kim-uijin";

create function pg_catalog.json_to_tsvector(regconfig, json, jsonb) returns tsvector
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.json_to_tsvector(regconfig, json, jsonb) is 'transform specified values from json to tsvector';

alter function pg_catalog.json_to_tsvector(regconfig, json, jsonb) owner to "kim-uijin";

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(name, name, boolean, out name, out pg_lsn) is 'copy a physical replication slot, changing temporality';

alter function pg_catalog.pg_copy_physical_replication_slot(name, name, boolean, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_copy_physical_replication_slot(src_slot_name name, dst_slot_name name, out slot_name name, out lsn pg_lsn, out lsn unknown) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_physical_replication_slot(name, name, out name, out pg_lsn, out unknown) is 'copy a physical replication slot';

alter function pg_catalog.pg_copy_physical_replication_slot(name, name, out name, out pg_lsn, out unknown) owner to "kim-uijin";

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, plugin name, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, name, out name, out pg_lsn) is 'copy a logical replication slot, changing temporality and plugin';

alter function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, name, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, temporary boolean, out slot_name name, out lsn pg_lsn) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, out name, out pg_lsn) is 'copy a logical replication slot, changing temporality';

alter function pg_catalog.pg_copy_logical_replication_slot(name, name, boolean, out name, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_copy_logical_replication_slot(src_slot_name name, dst_slot_name name, out slot_name name, out lsn pg_lsn, out slot_name unknown, out lsn unknown) returns record
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_copy_logical_replication_slot(name, name, out name, out pg_lsn, out unknown, out unknown) is 'copy a logical replication slot';

alter function pg_catalog.pg_copy_logical_replication_slot(name, name, out name, out pg_lsn, out unknown, out unknown) owner to "kim-uijin";

create function pg_catalog.anycompatiblemultirange_in(cstring, oid, integer) returns anycompatiblemultirange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblemultirange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.anycompatiblemultirange_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.anycompatiblemultirange_out(anycompatiblemultirange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblemultirange_out(anycompatiblemultirange) is 'I/O';

alter function pg_catalog.anycompatiblemultirange_out(anycompatiblemultirange) owner to "kim-uijin";

create function pg_catalog.range_merge(anymultirange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_merge(anymultirange) is 'the smallest range which includes the whole multirange';

alter function pg_catalog.range_merge(anymultirange) owner to "kim-uijin";

create function pg_catalog.anymultirange_in(cstring, oid, integer) returns anymultirange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anymultirange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.anymultirange_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.anymultirange_out(anymultirange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anymultirange_out(anymultirange) is 'I/O';

alter function pg_catalog.anymultirange_out(anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_in(cstring, oid, integer) returns anymultirange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.multirange_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.multirange_out(anymultirange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_out(anymultirange) is 'I/O';

alter function pg_catalog.multirange_out(anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_recv(internal, oid, integer) returns anymultirange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_recv(internal, oid, integer) is 'I/O';

alter function pg_catalog.multirange_recv(internal, oid, integer) owner to "kim-uijin";

create function pg_catalog.multirange_send(anymultirange) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_send(anymultirange) is 'I/O';

alter function pg_catalog.multirange_send(anymultirange) owner to "kim-uijin";

create function pg_catalog.lower(anymultirange) returns anyelement
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower(anymultirange) is 'lower bound of multirange';

alter function pg_catalog.lower(anymultirange) owner to "kim-uijin";

create function pg_catalog.upper(anymultirange) returns anyelement
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper(anymultirange) is 'upper bound of multirange';

alter function pg_catalog.upper(anymultirange) owner to "kim-uijin";

create function pg_catalog.isempty(anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.isempty(anymultirange) is 'is the multirange empty?';

alter function pg_catalog.isempty(anymultirange) owner to "kim-uijin";

create function pg_catalog.lower_inc(anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inc(anymultirange) is 'is the multirange''s lower bound inclusive?';

alter function pg_catalog.lower_inc(anymultirange) owner to "kim-uijin";

create function pg_catalog.upper_inc(anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inc(anymultirange) is 'is the multirange''s upper bound inclusive?';

alter function pg_catalog.upper_inc(anymultirange) owner to "kim-uijin";

create function pg_catalog.lower_inf(anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lower_inf(anymultirange) is 'is the multirange''s lower bound infinite?';

alter function pg_catalog.lower_inf(anymultirange) owner to "kim-uijin";

create function pg_catalog.upper_inf(anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.upper_inf(anymultirange) is 'is the multirange''s upper bound infinite?';

alter function pg_catalog.upper_inf(anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_typanalyze(internal) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_typanalyze(internal) is 'multirange typanalyze';

alter function pg_catalog.multirange_typanalyze(internal) owner to "kim-uijin";

create function pg_catalog.multirangesel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirangesel(internal, oid, internal, integer) is 'restriction selectivity for multirange operators';

alter function pg_catalog.multirangesel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.multirange_eq(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_eq(anymultirange, anymultirange) is 'implementation of = operator';

alter function pg_catalog.multirange_eq(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_ne(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_ne(anymultirange, anymultirange) is 'implementation of <> operator';

alter function pg_catalog.multirange_ne(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_overlaps_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overlaps_multirange(anyrange, anymultirange) is 'implementation of && operator';

alter function pg_catalog.range_overlaps_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_overlaps_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overlaps_range(anymultirange, anyrange) is 'implementation of && operator';

alter function pg_catalog.multirange_overlaps_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_overlaps_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overlaps_multirange(anymultirange, anymultirange) is 'implementation of && operator';

alter function pg_catalog.multirange_overlaps_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_contains_elem(anymultirange, anyelement) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_elem(anymultirange, anyelement) is 'implementation of @> operator';

alter function pg_catalog.multirange_contains_elem(anymultirange, anyelement) owner to "kim-uijin";

create function pg_catalog.multirange_contains_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_range(anymultirange, anyrange) is 'implementation of @> operator';

alter function pg_catalog.multirange_contains_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_contains_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contains_multirange(anymultirange, anymultirange) is 'implementation of @> operator';

alter function pg_catalog.multirange_contains_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.elem_contained_by_multirange(anyelement, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.elem_contained_by_multirange(anyelement, anymultirange) is 'implementation of <@ operator';

alter function pg_catalog.elem_contained_by_multirange(anyelement, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_contained_by_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contained_by_multirange(anyrange, anymultirange) is 'implementation of <@ operator';

alter function pg_catalog.range_contained_by_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_contained_by_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contained_by_multirange(anymultirange, anymultirange) is 'implementation of <@ operator';

alter function pg_catalog.multirange_contained_by_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_adjacent_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_adjacent_multirange(anyrange, anymultirange) is 'implementation of -|- operator';

alter function pg_catalog.range_adjacent_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_adjacent_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_adjacent_multirange(anymultirange, anymultirange) is 'implementation of -|- operator';

alter function pg_catalog.multirange_adjacent_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_adjacent_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_adjacent_range(anymultirange, anyrange) is 'implementation of -|- operator';

alter function pg_catalog.multirange_adjacent_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_before_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_before_multirange(anyrange, anymultirange) is 'implementation of << operator';

alter function pg_catalog.range_before_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_before_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_before_range(anymultirange, anyrange) is 'implementation of << operator';

alter function pg_catalog.multirange_before_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_before_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_before_multirange(anymultirange, anymultirange) is 'implementation of << operator';

alter function pg_catalog.multirange_before_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_after_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_after_multirange(anyrange, anymultirange) is 'implementation of >> operator';

alter function pg_catalog.range_after_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_after_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_after_range(anymultirange, anyrange) is 'implementation of >> operator';

alter function pg_catalog.multirange_after_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_after_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_after_multirange(anymultirange, anymultirange) is 'implementation of >> operator';

alter function pg_catalog.multirange_after_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_overleft_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overleft_multirange(anyrange, anymultirange) is 'implementation of &< operator';

alter function pg_catalog.range_overleft_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_overleft_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overleft_range(anymultirange, anyrange) is 'implementation of &< operator';

alter function pg_catalog.multirange_overleft_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_overleft_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overleft_multirange(anymultirange, anymultirange) is 'implementation of &< operator';

alter function pg_catalog.multirange_overleft_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.range_overright_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_overright_multirange(anyrange, anymultirange) is 'implementation of &> operator';

alter function pg_catalog.range_overright_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_overright_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overright_range(anymultirange, anyrange) is 'implementation of &> operator';

alter function pg_catalog.multirange_overright_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.multirange_overright_multirange(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_overright_multirange(anymultirange, anymultirange) is 'implementation of &> operator';

alter function pg_catalog.multirange_overright_multirange(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_union(anymultirange, anymultirange) returns anymultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_union(anymultirange, anymultirange) is 'implementation of + operator';

alter function pg_catalog.multirange_union(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_minus(anymultirange, anymultirange) returns anymultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_minus(anymultirange, anymultirange) is 'implementation of - operator';

alter function pg_catalog.multirange_minus(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_intersect(anymultirange, anymultirange) returns anymultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_intersect(anymultirange, anymultirange) is 'implementation of * operator';

alter function pg_catalog.multirange_intersect(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_cmp(anymultirange, anymultirange) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_cmp(anymultirange, anymultirange) is 'less-equal-greater';

alter function pg_catalog.multirange_cmp(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_lt(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_lt(anymultirange, anymultirange) is 'implementation of < operator';

alter function pg_catalog.multirange_lt(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_le(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_le(anymultirange, anymultirange) is 'implementation of <= operator';

alter function pg_catalog.multirange_le(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_ge(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_ge(anymultirange, anymultirange) is 'implementation of >= operator';

alter function pg_catalog.multirange_ge(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_gt(anymultirange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gt(anymultirange, anymultirange) is 'implementation of > operator';

alter function pg_catalog.multirange_gt(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.hash_multirange(anymultirange) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_multirange(anymultirange) is 'hash a multirange';

alter function pg_catalog.hash_multirange(anymultirange) owner to "kim-uijin";

create function pg_catalog.hash_multirange_extended(anymultirange, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_multirange_extended(anymultirange, bigint) is 'hash a multirange';

alter function pg_catalog.hash_multirange_extended(anymultirange, bigint) owner to "kim-uijin";

create function pg_catalog.int4multirange() returns int4multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange() is 'int4multirange constructor';

alter function pg_catalog.int4multirange() owner to "kim-uijin";

create function pg_catalog.int4multirange(int4range) returns int4multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange(int4range) is 'int4multirange constructor';

alter function pg_catalog.int4multirange(int4range) owner to "kim-uijin";

create function pg_catalog.int4multirange(int4range[]) returns int4multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int4multirange(int4range[]) is 'int4multirange constructor';

alter function pg_catalog.int4multirange(int4range[]) owner to "kim-uijin";

create function pg_catalog.nummultirange() returns nummultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange() is 'nummultirange constructor';

alter function pg_catalog.nummultirange() owner to "kim-uijin";

create function pg_catalog.nummultirange(numrange) returns nummultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange(numrange) is 'nummultirange constructor';

alter function pg_catalog.nummultirange(numrange) owner to "kim-uijin";

create function pg_catalog.nummultirange(numrange[]) returns nummultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.nummultirange(numrange[]) is 'nummultirange constructor';

alter function pg_catalog.nummultirange(numrange[]) owner to "kim-uijin";

create function pg_catalog.tsmultirange() returns tsmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange() is 'tsmultirange constructor';

alter function pg_catalog.tsmultirange() owner to "kim-uijin";

create function pg_catalog.tsmultirange(tsrange) returns tsmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange(tsrange) is 'tsmultirange constructor';

alter function pg_catalog.tsmultirange(tsrange) owner to "kim-uijin";

create function pg_catalog.tsmultirange(tsrange[]) returns tsmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsmultirange(tsrange[]) is 'tsmultirange constructor';

alter function pg_catalog.tsmultirange(tsrange[]) owner to "kim-uijin";

create function pg_catalog.tstzmultirange() returns tstzmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange() is 'tstzmultirange constructor';

alter function pg_catalog.tstzmultirange() owner to "kim-uijin";

create function pg_catalog.tstzmultirange(tstzrange) returns tstzmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange(tstzrange) is 'tstzmultirange constructor';

alter function pg_catalog.tstzmultirange(tstzrange) owner to "kim-uijin";

create function pg_catalog.tstzmultirange(tstzrange[]) returns tstzmultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tstzmultirange(tstzrange[]) is 'tstzmultirange constructor';

alter function pg_catalog.tstzmultirange(tstzrange[]) owner to "kim-uijin";

create function pg_catalog.datemultirange() returns datemultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange() is 'datemultirange constructor';

alter function pg_catalog.datemultirange() owner to "kim-uijin";

create function pg_catalog.datemultirange(daterange) returns datemultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange(daterange) is 'datemultirange constructor';

alter function pg_catalog.datemultirange(daterange) owner to "kim-uijin";

create function pg_catalog.datemultirange(daterange[]) returns datemultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.datemultirange(daterange[]) is 'datemultirange constructor';

alter function pg_catalog.datemultirange(daterange[]) owner to "kim-uijin";

create function pg_catalog.int8multirange() returns int8multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange() is 'int8multirange constructor';

alter function pg_catalog.int8multirange() owner to "kim-uijin";

create function pg_catalog.int8multirange(int8range) returns int8multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange(int8range) is 'int8multirange constructor';

alter function pg_catalog.int8multirange(int8range) owner to "kim-uijin";

create function pg_catalog.int8multirange(int8range[]) returns int8multirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.int8multirange(int8range[]) is 'int8multirange constructor';

alter function pg_catalog.int8multirange(int8range[]) owner to "kim-uijin";

create function pg_catalog.multirange(anyrange) returns anymultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange(anyrange) is 'anymultirange cast';

alter function pg_catalog.multirange(anyrange) owner to "kim-uijin";

create function pg_catalog.range_agg_transfn(internal, anyrange) returns internal
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_agg_transfn(internal, anyrange) is 'aggregate transition function';

alter function pg_catalog.range_agg_transfn(internal, anyrange) owner to "kim-uijin";

create function pg_catalog.range_agg_finalfn(internal, anyrange) returns anymultirange
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_agg_finalfn(internal, anyrange) is 'aggregate final function';

alter function pg_catalog.range_agg_finalfn(internal, anyrange) owner to "kim-uijin";

create function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8R to MULE_INTERNAL';

alter function pg_catalog.koi8r_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to KOI8R';

alter function pg_catalog.mic_to_koi8r(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for ISO-8859-5 to MULE_INTERNAL';

alter function pg_catalog.iso_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to ISO-8859-5';

alter function pg_catalog.mic_to_iso(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1251 to MULE_INTERNAL';

alter function pg_catalog.win1251_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to WIN1251';

alter function pg_catalog.mic_to_win1251(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN866 to MULE_INTERNAL';

alter function pg_catalog.win866_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to WIN866';

alter function pg_catalog.mic_to_win866(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8R to WIN1251';

alter function pg_catalog.koi8r_to_win1251(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1251 to KOI8R';

alter function pg_catalog.win1251_to_koi8r(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8R to WIN866';

alter function pg_catalog.koi8r_to_win866(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN866 to KOI8R';

alter function pg_catalog.win866_to_koi8r(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN866 to WIN1251';

alter function pg_catalog.win866_to_win1251(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1251 to WIN866';

alter function pg_catalog.win1251_to_win866(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for ISO-8859-5 to KOI8R';

alter function pg_catalog.iso_to_koi8r(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8R to ISO-8859-5';

alter function pg_catalog.koi8r_to_iso(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for ISO-8859-5 to WIN1251';

alter function pg_catalog.iso_to_win1251(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1251 to ISO-8859-5';

alter function pg_catalog.win1251_to_iso(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for ISO-8859-5 to WIN866';

alter function pg_catalog.iso_to_win866(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN866 to ISO-8859-5';

alter function pg_catalog.win866_to_iso(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_CN to MULE_INTERNAL';

alter function pg_catalog.euc_cn_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to EUC_CN';

alter function pg_catalog.mic_to_euc_cn(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_JP to SJIS';

alter function pg_catalog.euc_jp_to_sjis(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for SJIS to EUC_JP';

alter function pg_catalog.sjis_to_euc_jp(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_JP to MULE_INTERNAL';

alter function pg_catalog.euc_jp_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for SJIS to MULE_INTERNAL';

alter function pg_catalog.sjis_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to EUC_JP';

alter function pg_catalog.mic_to_euc_jp(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to SJIS';

alter function pg_catalog.mic_to_sjis(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_KR to MULE_INTERNAL';

alter function pg_catalog.euc_kr_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to EUC_KR';

alter function pg_catalog.mic_to_euc_kr(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_TW to BIG5';

alter function pg_catalog.euc_tw_to_big5(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for BIG5 to EUC_TW';

alter function pg_catalog.big5_to_euc_tw(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_TW to MULE_INTERNAL';

alter function pg_catalog.euc_tw_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for BIG5 to MULE_INTERNAL';

alter function pg_catalog.big5_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to EUC_TW';

alter function pg_catalog.mic_to_euc_tw(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to BIG5';

alter function pg_catalog.mic_to_big5(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN2 to MULE_INTERNAL';

alter function pg_catalog.latin2_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to LATIN2';

alter function pg_catalog.mic_to_latin2(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1250 to MULE_INTERNAL';

alter function pg_catalog.win1250_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to WIN1250';

alter function pg_catalog.mic_to_win1250(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN2 to WIN1250';

alter function pg_catalog.latin2_to_win1250(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN1250 to LATIN2';

alter function pg_catalog.win1250_to_latin2(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN1 to MULE_INTERNAL';

alter function pg_catalog.latin1_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to LATIN1';

alter function pg_catalog.mic_to_latin1(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN3 to MULE_INTERNAL';

alter function pg_catalog.latin3_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to LATIN3';

alter function pg_catalog.mic_to_latin3(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN4 to MULE_INTERNAL';

alter function pg_catalog.latin4_to_mic(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for MULE_INTERNAL to LATIN4';

alter function pg_catalog.mic_to_latin4(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.normalize(text, text default 'NFC'::text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.normalize(text, text) is 'Unicode normalization';

alter function pg_catalog.normalize(text, text) owner to "kim-uijin";

create function pg_catalog.is_normalized(text, text default 'NFC'::text) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.is_normalized(text, text) is 'check Unicode normalization';

alter function pg_catalog.is_normalized(text, text) owner to "kim-uijin";

create function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for BIG5 to UTF8';

alter function pg_catalog.big5_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to BIG5';

alter function pg_catalog.utf8_to_big5(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to KOI8R';

alter function pg_catalog.utf8_to_koi8r(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8R to UTF8';

alter function pg_catalog.koi8r_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to KOI8U';

alter function pg_catalog.utf8_to_koi8u(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for KOI8U to UTF8';

alter function pg_catalog.koi8u_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to WIN';

alter function pg_catalog.utf8_to_win(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for WIN to UTF8';

alter function pg_catalog.win_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_CN to UTF8';

alter function pg_catalog.euc_cn_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to EUC_CN';

alter function pg_catalog.utf8_to_euc_cn(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_JP to UTF8';

alter function pg_catalog.euc_jp_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to EUC_JP';

alter function pg_catalog.utf8_to_euc_jp(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_KR to UTF8';

alter function pg_catalog.euc_kr_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to EUC_KR';

alter function pg_catalog.utf8_to_euc_kr(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_TW to UTF8';

alter function pg_catalog.euc_tw_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to EUC_TW';

alter function pg_catalog.utf8_to_euc_tw(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for GB18030 to UTF8';

alter function pg_catalog.gb18030_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to GB18030';

alter function pg_catalog.utf8_to_gb18030(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for GBK to UTF8';

alter function pg_catalog.gbk_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to GBK';

alter function pg_catalog.utf8_to_gbk(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to ISO-8859 2-16';

alter function pg_catalog.utf8_to_iso8859(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for ISO-8859 2-16 to UTF8';

alter function pg_catalog.iso8859_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for LATIN1 to UTF8';

alter function pg_catalog.iso8859_1_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to LATIN1';

alter function pg_catalog.utf8_to_iso8859_1(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for JOHAB to UTF8';

alter function pg_catalog.johab_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to JOHAB';

alter function pg_catalog.utf8_to_johab(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for SJIS to UTF8';

alter function pg_catalog.sjis_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to SJIS';

alter function pg_catalog.utf8_to_sjis(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UHC to UTF8';

alter function pg_catalog.uhc_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to UHC';

alter function pg_catalog.utf8_to_uhc(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_JIS_2004 to UTF8';

alter function pg_catalog.euc_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to EUC_JIS_2004';

alter function pg_catalog.utf8_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for SHIFT_JIS_2004 to UTF8';

alter function pg_catalog.shift_jis_2004_to_utf8(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for UTF8 to SHIFT_JIS_2004';

alter function pg_catalog.utf8_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for EUC_JIS_2004 to SHIFT_JIS_2004';

alter function pg_catalog.euc_jis_2004_to_shift_jis_2004(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) returns integer
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) is 'internal conversion function for SHIFT_JIS_2004 to EUC_JIS_2004';

alter function pg_catalog.shift_jis_2004_to_euc_jis_2004(integer, integer, cstring, internal, integer, boolean) owner to "kim-uijin";

create function pg_catalog.multirange_intersect_agg_transfn(anymultirange, anymultirange) returns anymultirange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_intersect_agg_transfn(anymultirange, anymultirange) is 'range aggregate by intersecting';

alter function pg_catalog.multirange_intersect_agg_transfn(anymultirange, anymultirange) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_multirange_pg_type_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_multirange_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_multirange_pg_type_oid(oid) owner to "kim-uijin";

create function pg_catalog.binary_upgrade_set_next_multirange_array_pg_type_oid(oid) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.binary_upgrade_set_next_multirange_array_pg_type_oid(oid) is 'for use by pg_upgrade';

alter function pg_catalog.binary_upgrade_set_next_multirange_array_pg_type_oid(oid) owner to "kim-uijin";

create function pg_catalog.range_intersect_agg_transfn(anyrange, anyrange) returns anyrange
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_intersect_agg_transfn(anyrange, anyrange) is 'range aggregate by intersecting';

alter function pg_catalog.range_intersect_agg_transfn(anyrange, anyrange) owner to "kim-uijin";

create function pg_catalog.range_contains_multirange(anyrange, anymultirange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.range_contains_multirange(anyrange, anymultirange) is 'implementation of @> operator';

alter function pg_catalog.range_contains_multirange(anyrange, anymultirange) owner to "kim-uijin";

create function pg_catalog.multirange_contained_by_range(anymultirange, anyrange) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_contained_by_range(anymultirange, anyrange) is 'implementation of <@ operator';

alter function pg_catalog.multirange_contained_by_range(anymultirange, anyrange) owner to "kim-uijin";

create function pg_catalog.pg_log_backend_memory_contexts(integer) returns boolean
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_log_backend_memory_contexts(integer) is 'log memory contexts of the specified backend';

alter function pg_catalog.pg_log_backend_memory_contexts(integer) owner to "kim-uijin";

create function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid oid) returns oid
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid) is 'return Oid of the table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_oid(out oid) owner to "kim-uijin";

create function pg_catalog.pg_event_trigger_table_rewrite_reason() returns integer
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_event_trigger_table_rewrite_reason() is 'return reason code for table getting rewritten';

alter function pg_catalog.pg_event_trigger_table_rewrite_reason() owner to "kim-uijin";

create function pg_catalog.pg_event_trigger_ddl_commands(out classid oid, out objid oid, out objsubid integer, out command_tag text, out object_type text, out schema_name text, out object_identity text, out in_extension boolean, out command pg_ddl_command) returns setof setof record
    stable
    strict
    parallel restricted
    cost 10
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command) is 'list DDL actions being executed by the current command';

alter function pg_catalog.pg_event_trigger_ddl_commands(out oid, out oid, out integer, out text, out text, out text, out text, out boolean, out pg_ddl_command) owner to "kim-uijin";

create function pg_catalog.brin_bloom_opcinfo(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_opcinfo(internal) is 'BRIN bloom support';

alter function pg_catalog.brin_bloom_opcinfo(internal) owner to "kim-uijin";

create function pg_catalog.brin_bloom_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_add_value(internal, internal, internal, internal) is 'BRIN bloom support';

alter function pg_catalog.brin_bloom_add_value(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_bloom_consistent(internal, internal, internal, integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_consistent(internal, internal, internal, integer) is 'BRIN bloom support';

alter function pg_catalog.brin_bloom_consistent(internal, internal, internal, integer) owner to "kim-uijin";

create function pg_catalog.brin_bloom_union(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_union(internal, internal, internal) is 'BRIN bloom support';

alter function pg_catalog.brin_bloom_union(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_bloom_options(internal) returns void
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_options(internal) is 'BRIN bloom support';

alter function pg_catalog.brin_bloom_options(internal) owner to "kim-uijin";

create function pg_catalog.brin_bloom_summary_in(cstring) returns pg_brin_bloom_summary
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_in(cstring) is 'I/O';

alter function pg_catalog.brin_bloom_summary_in(cstring) owner to "kim-uijin";

create function pg_catalog.brin_bloom_summary_out(pg_brin_bloom_summary) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_out(pg_brin_bloom_summary) is 'I/O';

alter function pg_catalog.brin_bloom_summary_out(pg_brin_bloom_summary) owner to "kim-uijin";

create function pg_catalog.brin_bloom_summary_recv(internal) returns pg_brin_bloom_summary
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_recv(internal) is 'I/O';

alter function pg_catalog.brin_bloom_summary_recv(internal) owner to "kim-uijin";

create function pg_catalog.brin_bloom_summary_send(pg_brin_bloom_summary) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_bloom_summary_send(pg_brin_bloom_summary) is 'I/O';

alter function pg_catalog.brin_bloom_summary_send(pg_brin_bloom_summary) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_opcinfo(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_opcinfo(internal) is 'BRIN multi minmax support';

alter function pg_catalog.brin_minmax_multi_opcinfo(internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal) is 'BRIN multi minmax support';

alter function pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer) is 'BRIN multi minmax support';

alter function pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_union(internal, internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_union(internal, internal, internal) is 'BRIN multi minmax support';

alter function pg_catalog.brin_minmax_multi_union(internal, internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_options(internal) returns void
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_options(internal) is 'BRIN multi minmax support';

alter function pg_catalog.brin_minmax_multi_options(internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_int2(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int2(internal, internal) is 'BRIN multi minmax int2 distance';

alter function pg_catalog.brin_minmax_multi_distance_int2(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_int4(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int4(internal, internal) is 'BRIN multi minmax int4 distance';

alter function pg_catalog.brin_minmax_multi_distance_int4(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_int8(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_int8(internal, internal) is 'BRIN multi minmax int8 distance';

alter function pg_catalog.brin_minmax_multi_distance_int8(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_float4(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_float4(internal, internal) is 'BRIN multi minmax float4 distance';

alter function pg_catalog.brin_minmax_multi_distance_float4(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_float8(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_float8(internal, internal) is 'BRIN multi minmax float8 distance';

alter function pg_catalog.brin_minmax_multi_distance_float8(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_numeric(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_numeric(internal, internal) is 'BRIN multi minmax numeric distance';

alter function pg_catalog.brin_minmax_multi_distance_numeric(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_tid(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_tid(internal, internal) is 'BRIN multi minmax tid distance';

alter function pg_catalog.brin_minmax_multi_distance_tid(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_uuid(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_uuid(internal, internal) is 'BRIN multi minmax uuid distance';

alter function pg_catalog.brin_minmax_multi_distance_uuid(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_date(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_date(internal, internal) is 'BRIN multi minmax date distance';

alter function pg_catalog.brin_minmax_multi_distance_date(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_time(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_time(internal, internal) is 'BRIN multi minmax time distance';

alter function pg_catalog.brin_minmax_multi_distance_time(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_interval(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_interval(internal, internal) is 'BRIN multi minmax interval distance';

alter function pg_catalog.brin_minmax_multi_distance_interval(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_timetz(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_timetz(internal, internal) is 'BRIN multi minmax timetz distance';

alter function pg_catalog.brin_minmax_multi_distance_timetz(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_pg_lsn(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_pg_lsn(internal, internal) is 'BRIN multi minmax pg_lsn distance';

alter function pg_catalog.brin_minmax_multi_distance_pg_lsn(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_macaddr(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_macaddr(internal, internal) is 'BRIN multi minmax macaddr distance';

alter function pg_catalog.brin_minmax_multi_distance_macaddr(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_macaddr8(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_macaddr8(internal, internal) is 'BRIN multi minmax macaddr8 distance';

alter function pg_catalog.brin_minmax_multi_distance_macaddr8(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_inet(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_inet(internal, internal) is 'BRIN multi minmax inet distance';

alter function pg_catalog.brin_minmax_multi_distance_inet(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_distance_timestamp(internal, internal) returns double precision
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_distance_timestamp(internal, internal) is 'BRIN multi minmax timestamp distance';

alter function pg_catalog.brin_minmax_multi_distance_timestamp(internal, internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_summary_in(cstring) returns pg_brin_minmax_multi_summary
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_in(cstring) is 'I/O';

alter function pg_catalog.brin_minmax_multi_summary_in(cstring) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_summary_out(pg_brin_minmax_multi_summary) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_out(pg_brin_minmax_multi_summary) is 'I/O';

alter function pg_catalog.brin_minmax_multi_summary_out(pg_brin_minmax_multi_summary) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_summary_recv(internal) returns pg_brin_minmax_multi_summary
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_recv(internal) is 'I/O';

alter function pg_catalog.brin_minmax_multi_summary_recv(internal) owner to "kim-uijin";

create function pg_catalog.brin_minmax_multi_summary_send(pg_brin_minmax_multi_summary) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.brin_minmax_multi_summary_send(pg_brin_minmax_multi_summary) is 'I/O';

alter function pg_catalog.brin_minmax_multi_summary_send(pg_brin_minmax_multi_summary) owner to "kim-uijin";

create function pg_catalog.phraseto_tsquery(text) returns tsquery
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(text) is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(text) owner to "kim-uijin";

create function pg_catalog.tsquery_phrase(tsquery, tsquery) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery) is 'implementation of <-> operator';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery) owner to "kim-uijin";

create function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) returns tsquery
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) is 'phrase-concatenate with distance';

alter function pg_catalog.tsquery_phrase(tsquery, tsquery, integer) owner to "kim-uijin";

create function pg_catalog.phraseto_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.phraseto_tsquery(regconfig, text) is 'transform to tsquery';

alter function pg_catalog.phraseto_tsquery(regconfig, text) owner to "kim-uijin";

create function pg_catalog.websearch_to_tsquery(regconfig, text) returns tsquery
    immutable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(regconfig, text) is 'transform to tsquery';

alter function pg_catalog.websearch_to_tsquery(regconfig, text) owner to "kim-uijin";

create function pg_catalog.websearch_to_tsquery(text) returns tsquery
    stable
    strict
    parallel safe
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.websearch_to_tsquery(text) is 'transform to tsquery';

alter function pg_catalog.websearch_to_tsquery(text) owner to "kim-uijin";

create function pg_catalog.spg_bbox_quad_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_bbox_quad_config(internal, internal) is 'SP-GiST support for quad tree over 2-D types represented by their bounding boxes';

alter function pg_catalog.spg_bbox_quad_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_poly_quad_compress(polygon) returns box
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_poly_quad_compress(polygon) is 'SP-GiST support for quad tree over polygons';

alter function pg_catalog.spg_poly_quad_compress(polygon) owner to "kim-uijin";

create function pg_catalog.spg_box_quad_config(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_config(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_config(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_box_quad_choose(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_choose(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_choose(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_box_quad_picksplit(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_picksplit(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_picksplit(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_box_quad_inner_consistent(internal, internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_inner_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_inner_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) is 'SP-GiST support for quad tree over box';

alter function pg_catalog.spg_box_quad_leaf_consistent(internal, internal) owner to "kim-uijin";

create function pg_catalog.pg_mcv_list_in(cstring) returns pg_mcv_list
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_in(cstring) is 'I/O';

alter function pg_catalog.pg_mcv_list_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_mcv_list_out(pg_mcv_list) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_out(pg_mcv_list) is 'I/O';

alter function pg_catalog.pg_mcv_list_out(pg_mcv_list) owner to "kim-uijin";

create function pg_catalog.pg_mcv_list_recv(internal) returns pg_mcv_list
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_recv(internal) is 'I/O';

alter function pg_catalog.pg_mcv_list_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_mcv_list_send(pg_mcv_list) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_mcv_list_send(pg_mcv_list) is 'I/O';

alter function pg_catalog.pg_mcv_list_send(pg_mcv_list) owner to "kim-uijin";

create function pg_catalog.pg_lsn_pli(pg_lsn, numeric) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_pli(pg_lsn, numeric) is 'implementation of + operator';

alter function pg_catalog.pg_lsn_pli(pg_lsn, numeric) owner to "kim-uijin";

create function pg_catalog.numeric_pl_pg_lsn(numeric, pg_lsn) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language sql
RETURN ($2 + $1);

comment on function pg_catalog.numeric_pl_pg_lsn(numeric, pg_lsn) is 'implementation of + operator';

alter function pg_catalog.numeric_pl_pg_lsn(numeric, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_lsn_mii(pg_lsn, numeric) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn_mii(pg_lsn, numeric) is 'implementation of - operator';

alter function pg_catalog.pg_lsn_mii(pg_lsn, numeric) owner to "kim-uijin";

create function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") returns boolean
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") is 'hash partition CHECK constraint';

alter function pg_catalog.satisfies_hash_partition(oid, integer, integer, "any") owner to "kim-uijin";

create function pg_catalog.pg_ls_tmpdir(out name text, out size bigint, out modification timestamp with time zone, out modification unknown) returns setof setof record
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_tmpdir(out text, out bigint, out timestamp with time zone, out unknown) is 'list files in the pgsql_tmp directory';

alter function pg_catalog.pg_ls_tmpdir(out text, out bigint, out timestamp with time zone, out unknown) owner to "kim-uijin";

grant execute on function pg_catalog.pg_ls_tmpdir(out text, out bigint, out timestamp with time zone, out unknown) to pg_monitor;

create function pg_catalog.pg_ls_tmpdir(tablespace oid, out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_tmpdir(oid, out text, out bigint, out timestamp with time zone) is 'list files in the pgsql_tmp directory';

alter function pg_catalog.pg_ls_tmpdir(oid, out text, out bigint, out timestamp with time zone) owner to "kim-uijin";

grant execute on function pg_catalog.pg_ls_tmpdir(oid, out text, out bigint, out timestamp with time zone) to pg_monitor;

create function pg_catalog.pg_ls_archive_statusdir(out name text, out size bigint, out modification timestamp with time zone) returns setof setof record
    strict
    parallel safe
    cost 10
    rows 20
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_ls_archive_statusdir(out text, out bigint, out timestamp with time zone) is 'list of files in the archive_status directory';

alter function pg_catalog.pg_ls_archive_statusdir(out text, out bigint, out timestamp with time zone) owner to "kim-uijin";

grant execute on function pg_catalog.pg_ls_archive_statusdir(out text, out bigint, out timestamp with time zone) to pg_monitor;

create function pg_catalog.network_sortsupport(internal) returns void
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.network_sortsupport(internal) is 'sort support';

alter function pg_catalog.network_sortsupport(internal) owner to "kim-uijin";

create function pg_catalog.xid8lt(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8lt(xid8, xid8) is 'implementation of < operator';

alter function pg_catalog.xid8lt(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.xid8gt(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8gt(xid8, xid8) is 'implementation of > operator';

alter function pg_catalog.xid8gt(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.xid8le(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8le(xid8, xid8) is 'implementation of <= operator';

alter function pg_catalog.xid8le(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.xid8ge(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ge(xid8, xid8) is 'implementation of >= operator';

alter function pg_catalog.xid8ge(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.matchingsel(internal, oid, internal, integer) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingsel(internal, oid, internal, integer) is 'restriction selectivity for generic matching operators';

alter function pg_catalog.matchingsel(internal, oid, internal, integer) owner to "kim-uijin";

create function pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) returns double precision
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) is 'join selectivity for generic matching operators';

alter function pg_catalog.matchingjoinsel(internal, oid, internal, smallint, internal) owner to "kim-uijin";

create function pg_catalog.min_scale(numeric) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.min_scale(numeric) is 'minimum scale needed to represent the value';

alter function pg_catalog.min_scale(numeric) owner to "kim-uijin";

create function pg_catalog.trim_scale(numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trim_scale(numeric) is 'numeric with minimum scale needed to represent the value';

alter function pg_catalog.trim_scale(numeric) owner to "kim-uijin";

create function pg_catalog.gcd(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(integer, integer) is 'greatest common divisor';

alter function pg_catalog.gcd(integer, integer) owner to "kim-uijin";

create function pg_catalog.gcd(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(bigint, bigint) is 'greatest common divisor';

alter function pg_catalog.gcd(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.lcm(integer, integer) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(integer, integer) is 'least common multiple';

alter function pg_catalog.lcm(integer, integer) owner to "kim-uijin";

create function pg_catalog.lcm(bigint, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(bigint, bigint) is 'least common multiple';

alter function pg_catalog.lcm(bigint, bigint) owner to "kim-uijin";

create function pg_catalog.gcd(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.gcd(numeric, numeric) is 'greatest common divisor';

alter function pg_catalog.gcd(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.lcm(numeric, numeric) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.lcm(numeric, numeric) is 'least common multiple';

alter function pg_catalog.lcm(numeric, numeric) owner to "kim-uijin";

create function pg_catalog.btvarstrequalimage(oid) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btvarstrequalimage(oid) is 'equal image';

alter function pg_catalog.btvarstrequalimage(oid) owner to "kim-uijin";

create function pg_catalog.btequalimage(oid) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.btequalimage(oid) is 'equal image';

alter function pg_catalog.btequalimage(oid) owner to "kim-uijin";

create function pg_catalog.pg_get_shmem_allocations(out name text, out "off" bigint, out size bigint, out allocated_size bigint) returns setof setof record
    strict
    parallel safe
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_shmem_allocations(out text, out bigint, out bigint, out bigint) is 'allocations from the main shared memory segment';

alter function pg_catalog.pg_get_shmem_allocations(out text, out bigint, out bigint, out bigint) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_ins_since_vacuum(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_ins_since_vacuum(oid) is 'statistics: number of tuples inserted since last vacuum';

alter function pg_catalog.pg_stat_get_ins_since_vacuum(oid) owner to "kim-uijin";

create function pg_catalog.jsonb_set_lax(jsonb_in jsonb, path text[], replacement jsonb, create_if_missing boolean default true, null_value_treatment text default 'use_json_null'::text) returns jsonb
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_set_lax(jsonb, text[], jsonb, boolean, text) is 'Set part of a jsonb, handle NULL value';

alter function pg_catalog.jsonb_set_lax(jsonb, text[], jsonb, boolean, text) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_in(cstring) returns pg_snapshot
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_in(cstring) is 'I/O';

alter function pg_catalog.pg_snapshot_in(cstring) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_out(pg_snapshot) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_out(pg_snapshot) is 'I/O';

alter function pg_catalog.pg_snapshot_out(pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_recv(internal) returns pg_snapshot
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_recv(internal) is 'I/O';

alter function pg_catalog.pg_snapshot_recv(internal) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_send(pg_snapshot) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_send(pg_snapshot) is 'I/O';

alter function pg_catalog.pg_snapshot_send(pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_current_xact_id() returns xid8
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id() is 'get current transaction ID';

alter function pg_catalog.pg_current_xact_id() owner to "kim-uijin";

create function pg_catalog.pg_current_xact_id_if_assigned() returns xid8
    stable
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_xact_id_if_assigned() is 'get current transaction ID';

alter function pg_catalog.pg_current_xact_id_if_assigned() owner to "kim-uijin";

create function pg_catalog.pg_current_snapshot() returns pg_snapshot
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_current_snapshot() is 'get current snapshot';

alter function pg_catalog.pg_current_snapshot() owner to "kim-uijin";

create function pg_catalog.pg_snapshot_xmin(pg_snapshot) returns xid8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmin(pg_snapshot) is 'get xmin of snapshot';

alter function pg_catalog.pg_snapshot_xmin(pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_xmax(pg_snapshot) returns xid8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_snapshot_xmax(pg_snapshot) is 'get xmax of snapshot';

alter function pg_catalog.pg_snapshot_xmax(pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_snapshot_xip(pg_snapshot) returns setof setof xid8
    immutable
    strict
    parallel safe
    cost 1
    rows 50
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_snapshot_xip(pg_snapshot) is 'get set of in-progress transactions in snapshot';

alter function pg_catalog.pg_snapshot_xip(pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) is 'is xid8 visible in snapshot?';

alter function pg_catalog.pg_visible_in_snapshot(xid8, pg_snapshot) owner to "kim-uijin";

create function pg_catalog.pg_xact_status(xid8) returns text
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_status(xid8) is 'commit status of transaction';

alter function pg_catalog.pg_xact_status(xid8) owner to "kim-uijin";

create function pg_catalog.xid8in(cstring) returns xid8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8in(cstring) is 'I/O';

alter function pg_catalog.xid8in(cstring) owner to "kim-uijin";

create function pg_catalog.xid(xid8) returns xid
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid(xid8) is 'convert xid8 to xid';

alter function pg_catalog.xid(xid8) owner to "kim-uijin";

create function pg_catalog.xid8out(xid8) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8out(xid8) is 'I/O';

alter function pg_catalog.xid8out(xid8) owner to "kim-uijin";

create function pg_catalog.xid8recv(internal) returns xid8
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8recv(internal) is 'I/O';

alter function pg_catalog.xid8recv(internal) owner to "kim-uijin";

create function pg_catalog.xid8send(xid8) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8send(xid8) is 'I/O';

alter function pg_catalog.xid8send(xid8) owner to "kim-uijin";

create function pg_catalog.xid8eq(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8eq(xid8, xid8) is 'implementation of = operator';

alter function pg_catalog.xid8eq(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.xid8ne(xid8, xid8) returns boolean
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8ne(xid8, xid8) is 'implementation of <> operator';

alter function pg_catalog.xid8ne(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.anycompatible_in(cstring) returns anycompatible
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_in(cstring) is 'I/O';

alter function pg_catalog.anycompatible_in(cstring) owner to "kim-uijin";

create function pg_catalog.anycompatible_out(anycompatible) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatible_out(anycompatible) is 'I/O';

alter function pg_catalog.anycompatible_out(anycompatible) owner to "kim-uijin";

create function pg_catalog.anycompatiblearray_in(cstring) returns anycompatiblearray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_in(cstring) is 'I/O';

alter function pg_catalog.anycompatiblearray_in(cstring) owner to "kim-uijin";

create function pg_catalog.anycompatiblearray_out(anycompatiblearray) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_out(anycompatiblearray) is 'I/O';

alter function pg_catalog.anycompatiblearray_out(anycompatiblearray) owner to "kim-uijin";

create function pg_catalog.anycompatiblearray_recv(internal) returns anycompatiblearray
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_recv(internal) is 'I/O';

alter function pg_catalog.anycompatiblearray_recv(internal) owner to "kim-uijin";

create function pg_catalog.anycompatiblearray_send(anycompatiblearray) returns bytea
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblearray_send(anycompatiblearray) is 'I/O';

alter function pg_catalog.anycompatiblearray_send(anycompatiblearray) owner to "kim-uijin";

create function pg_catalog.anycompatiblenonarray_in(cstring) returns anycompatiblenonarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_in(cstring) is 'I/O';

alter function pg_catalog.anycompatiblenonarray_in(cstring) owner to "kim-uijin";

create function pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) returns cstring
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) is 'I/O';

alter function pg_catalog.anycompatiblenonarray_out(anycompatiblenonarray) owner to "kim-uijin";

create function pg_catalog.anycompatiblerange_in(cstring, oid, integer) returns anycompatiblerange
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_in(cstring, oid, integer) is 'I/O';

alter function pg_catalog.anycompatiblerange_in(cstring, oid, integer) owner to "kim-uijin";

create function pg_catalog.anycompatiblerange_out(anycompatiblerange) returns cstring
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.anycompatiblerange_out(anycompatiblerange) is 'I/O';

alter function pg_catalog.anycompatiblerange_out(anycompatiblerange) owner to "kim-uijin";

create function pg_catalog.xid8cmp(xid8, xid8) returns integer
    immutable
    leakproof
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.xid8cmp(xid8, xid8) is 'less-equal-greater';

alter function pg_catalog.xid8cmp(xid8, xid8) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_create(text) returns oid
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_create(text) is 'create a replication origin';

alter function pg_catalog.pg_replication_origin_create(text) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_drop(text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_drop(text) is 'drop replication origin identified by its name';

alter function pg_catalog.pg_replication_origin_drop(text) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_oid(text) returns oid
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_oid(text) is 'translate the replication origin''s name to its id';

alter function pg_catalog.pg_replication_origin_oid(text) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_session_setup(text) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_setup(text) is 'configure session to maintain replication progress tracking for the passed in origin';

alter function pg_catalog.pg_replication_origin_session_setup(text) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_session_reset() returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_reset() is 'teardown configured replication progress tracking';

alter function pg_catalog.pg_replication_origin_session_reset() owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_session_is_setup() returns boolean
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_is_setup() is 'is a replication origin configured in this session';

alter function pg_catalog.pg_replication_origin_session_is_setup() owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_session_progress(boolean) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_session_progress(boolean) is 'get the replication progress of the current session';

alter function pg_catalog.pg_replication_origin_session_progress(boolean) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) is 'setup the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_setup(pg_lsn, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_xact_reset() returns void
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_xact_reset() is 'reset the transaction''s origin lsn and timestamp';

alter function pg_catalog.pg_replication_origin_xact_reset() owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_advance(text, pg_lsn) returns void
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_advance(text, pg_lsn) is 'advance replication origin to specific location';

alter function pg_catalog.pg_replication_origin_advance(text, pg_lsn) owner to "kim-uijin";

create function pg_catalog.pg_replication_origin_progress(text, boolean) returns pg_lsn
    strict
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_replication_origin_progress(text, boolean) is 'get an individual replication origin''s replication progress';

alter function pg_catalog.pg_replication_origin_progress(text, boolean) owner to "kim-uijin";

create function pg_catalog.pg_show_replication_origin_status(out local_id oid, out external_id text, out remote_lsn pg_lsn, out local_lsn pg_lsn) returns setof setof record
    parallel restricted
    cost 1
    rows 100
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn) is 'get progress for all replication origins';

alter function pg_catalog.pg_show_replication_origin_status(out oid, out text, out pg_lsn, out pg_lsn) owner to "kim-uijin";

create function pg_catalog.jsonb_subscript_handler(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.jsonb_subscript_handler(internal) is 'jsonb subscripting logic';

alter function pg_catalog.jsonb_subscript_handler(internal) owner to "kim-uijin";

create function pg_catalog.pg_lsn(numeric) returns pg_lsn
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_lsn(numeric) is 'convert numeric to pg_lsn';

alter function pg_catalog.pg_lsn(numeric) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_subscription(subid oid, out subid oid, out relid oid, out pid integer, out received_lsn pg_lsn, out last_msg_send_time timestamp with time zone, out last_msg_receipt_time timestamp with time zone, out latest_end_lsn pg_lsn, out latest_end_time timestamp with time zone) returns setof setof record
    stable
    parallel restricted
    cost 1
    rows 10
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone) is 'statistics: information about subscription';

alter function pg_catalog.pg_stat_get_subscription(oid, out oid, out oid, out integer, out pg_lsn, out timestamp with time zone, out timestamp with time zone, out pg_lsn, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_get_publication_tables(pubname text, out relid oid) returns setof setof oid
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_publication_tables(text, out oid) is 'get OIDs of tables in a publication';

alter function pg_catalog.pg_get_publication_tables(text, out oid) owner to "kim-uijin";

create function pg_catalog.pg_get_replica_identity_index(regclass) returns regclass
    stable
    strict
    parallel safe
    cost 10
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_replica_identity_index(regclass) is 'oid of replica identity index if any';

alter function pg_catalog.pg_get_replica_identity_index(regclass) owner to "kim-uijin";

create function pg_catalog.pg_relation_is_publishable(regclass) returns boolean
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_relation_is_publishable(regclass) is 'returns whether a relation can be part of a publication';

alter function pg_catalog.pg_relation_is_publishable(regclass) owner to "kim-uijin";

create function pg_catalog.multirange_gist_consistent(internal, anymultirange, smallint, oid, internal) returns boolean
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gist_consistent(internal, anymultirange, smallint, oid, internal) is 'GiST support';

alter function pg_catalog.multirange_gist_consistent(internal, anymultirange, smallint, oid, internal) owner to "kim-uijin";

create function pg_catalog.multirange_gist_compress(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.multirange_gist_compress(internal) is 'GiST support';

alter function pg_catalog.multirange_gist_compress(internal) owner to "kim-uijin";

create function pg_catalog.pg_get_catalog_foreign_keys(out fktable regclass, out fkcols text[], out pktable regclass, out pkcols text[], out is_array boolean, out is_opt boolean) returns setof setof record
    stable
    strict
    parallel safe
    cost 10
    rows 250
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_get_catalog_foreign_keys(out regclass, out text[], out regclass, out text[], out boolean, out boolean) is 'list of catalog foreign key relationships';

alter function pg_catalog.pg_get_catalog_foreign_keys(out regclass, out text[], out regclass, out text[], out boolean, out boolean) owner to "kim-uijin";

create function pg_catalog.string_to_table(text, text) returns setof setof text
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.string_to_table(text, text) is 'split delimited text';

alter function pg_catalog.string_to_table(text, text) owner to "kim-uijin";

create function pg_catalog.string_to_table(text, text, text) returns setof setof text
    immutable
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.string_to_table(text, text, text) is 'split delimited text, with null string';

alter function pg_catalog.string_to_table(text, text, text) owner to "kim-uijin";

create function pg_catalog.bit_count(bit) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_count(bit) is 'number of set bits';

alter function pg_catalog.bit_count(bit) owner to "kim-uijin";

create function pg_catalog.bit_count(bytea) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.bit_count(bytea) is 'number of set bits';

alter function pg_catalog.bit_count(bytea) owner to "kim-uijin";

create function pg_catalog.pg_xact_commit_timestamp_origin(xid xid, out timestamp timestamp with time zone, out roident oid) returns record
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_xact_commit_timestamp_origin(xid, out timestamp with time zone, out oid) is 'get commit timestamp and replication origin of a transaction';

alter function pg_catalog.pg_xact_commit_timestamp_origin(xid, out timestamp with time zone, out oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_replication_slot(slot_name text, out slot_name text, out spill_txns bigint, out spill_count bigint, out spill_bytes bigint, out stream_txns bigint, out stream_count bigint, out stream_bytes bigint, out total_txns bigint, out total_bytes bigint, out stats_reset timestamp with time zone) returns setof setof record
    stable
    parallel restricted
    cost 1
    rows 1
    language internal
as
$$
begin
-- missing source code
end;

$$;

comment on function pg_catalog.pg_stat_get_replication_slot(text, out text, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out timestamp with time zone) is 'statistics: information about replication slot';

alter function pg_catalog.pg_stat_get_replication_slot(text, out text, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out bigint, out timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.pg_stat_reset_replication_slot(text) returns void
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_reset_replication_slot(text) is 'statistics: reset collected statistics for a single replication slot';

alter function pg_catalog.pg_stat_reset_replication_slot(text) owner to "kim-uijin";

create function pg_catalog.trim_array(anyarray, integer) returns anyarray
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.trim_array(anyarray, integer) is 'remove last N elements of array';

alter function pg_catalog.trim_array(anyarray, integer) owner to "kim-uijin";

create function pg_catalog.pg_get_statisticsobjdef_expressions(oid) returns text[]
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef_expressions(oid) is 'extended statistics expressions';

alter function pg_catalog.pg_get_statisticsobjdef_expressions(oid) owner to "kim-uijin";

create function pg_catalog.pg_get_statisticsobjdef_columns(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_statisticsobjdef_columns(oid) is 'extended statistics columns';

alter function pg_catalog.pg_get_statisticsobjdef_columns(oid) owner to "kim-uijin";

create function pg_catalog.date_bin(interval, timestamp, timestamp) returns timestamp
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_bin(interval, timestamp, timestamp) is 'bin timestamp into specified interval';

alter function pg_catalog.date_bin(interval, timestamp, timestamp) owner to "kim-uijin";

create function pg_catalog.date_bin(interval, timestamp with time zone, timestamp with time zone) returns timestamp with time zone
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.date_bin(interval, timestamp with time zone, timestamp with time zone) is 'bin timestamp with time zone into specified interval';

alter function pg_catalog.date_bin(interval, timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.array_subscript_handler(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.array_subscript_handler(internal) is 'standard array subscripting support';

alter function pg_catalog.array_subscript_handler(internal) owner to "kim-uijin";

create function pg_catalog.raw_array_subscript_handler(internal) returns internal
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.raw_array_subscript_handler(internal) is 'raw array subscripting support';

alter function pg_catalog.raw_array_subscript_handler(internal) owner to "kim-uijin";

create function pg_catalog.ts_debug(config regconfig, document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT tt.alias,
       tt.description,
       parse.token,
       ARRAY( SELECT (m.mapdict)::regdictionary AS mapdict
              FROM pg_ts_config_map m
              WHERE ((m.mapcfg = (ts_debug.config)::oid) AND (m.maptokentype = parse.tokid))
              ORDER BY m.mapseqno) AS dictionaries,
       ( SELECT (m.mapdict)::regdictionary AS mapdict
         FROM pg_ts_config_map m
         WHERE ((m.mapcfg = (ts_debug.config)::oid) AND (m.maptokentype = parse.tokid))
         ORDER BY (ts_lexize((m.mapdict)::regdictionary, parse.token) IS NULL), m.mapseqno
         LIMIT 1) AS dictionary,
       ( SELECT ts_lexize((m.mapdict)::regdictionary, parse.token) AS ts_lexize
         FROM pg_ts_config_map m
         WHERE ((m.mapcfg = (ts_debug.config)::oid) AND (m.maptokentype = parse.tokid))
         ORDER BY (ts_lexize((m.mapdict)::regdictionary, parse.token) IS NULL), m.mapseqno
         LIMIT 1) AS lexemes
FROM ts_parse(( SELECT pg_ts_config.cfgparser
                FROM pg_ts_config
                WHERE (pg_ts_config.oid = (ts_debug.config)::oid)), ts_debug.document) parse(tokid, token),
     ts_token_type(( SELECT pg_ts_config.cfgparser
                     FROM pg_ts_config
                     WHERE (pg_ts_config.oid = (ts_debug.config)::oid))) tt(tokid, alias, description)
WHERE (tt.tokid = parse.tokid);
END;

comment on function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for text search configuration';

alter function pg_catalog.ts_debug(regconfig, text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to "kim-uijin";

create function pg_catalog.ts_debug(document text, OUT alias text, OUT description text, OUT token text, OUT dictionaries regdictionary[], OUT dictionary regdictionary, OUT lexemes text[]) returns SETOF record
    stable
    strict
    parallel safe
    language sql
BEGIN ATOMIC
SELECT ts_debug.alias,
       ts_debug.description,
       ts_debug.token,
       ts_debug.dictionaries,
       ts_debug.dictionary,
       ts_debug.lexemes
FROM ts_debug(get_current_ts_config(), ts_debug.document) ts_debug(alias, description, token, dictionaries, dictionary, lexemes);
END;

comment on function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) is 'debug function for current text search configuration';

alter function pg_catalog.ts_debug(text, out text, out text, out text, out regdictionary[], out regdictionary, out text[]) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_session_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_session_time(oid) is 'statistics: session time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_session_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_active_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_active_time(oid) is 'statistics: session active time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_active_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_idle_in_transaction_time(oid) returns double precision
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_idle_in_transaction_time(oid) is 'statistics: session idle in transaction time, in milliseconds';

alter function pg_catalog.pg_stat_get_db_idle_in_transaction_time(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_sessions(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions(oid) is 'statistics: total number of sessions';

alter function pg_catalog.pg_stat_get_db_sessions(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_sessions_abandoned(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_abandoned(oid) is 'statistics: number of sessions disconnected by the client closing the network connection';

alter function pg_catalog.pg_stat_get_db_sessions_abandoned(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_sessions_fatal(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_fatal(oid) is 'statistics: number of sessions disconnected by fatal errors';

alter function pg_catalog.pg_stat_get_db_sessions_fatal(oid) owner to "kim-uijin";

create function pg_catalog.pg_stat_get_db_sessions_killed(oid) returns bigint
    stable
    strict
    parallel restricted
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_stat_get_db_sessions_killed(oid) is 'statistics: number of sessions killed by administrative action';

alter function pg_catalog.pg_stat_get_db_sessions_killed(oid) owner to "kim-uijin";

create function pg_catalog.hash_record(record) returns integer
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_record(record) is 'hash';

alter function pg_catalog.hash_record(record) owner to "kim-uijin";

create function pg_catalog.hash_record_extended(record, bigint) returns bigint
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.hash_record_extended(record, bigint) is 'hash';

alter function pg_catalog.hash_record_extended(record, bigint) owner to "kim-uijin";

create function pg_catalog.ltrim(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.ltrim(bytea, bytea) is 'trim selected bytes from left end of string';

alter function pg_catalog.ltrim(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.rtrim(bytea, bytea) returns bytea
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.rtrim(bytea, bytea) is 'trim selected bytes from right end of string';

alter function pg_catalog.rtrim(bytea, bytea) owner to "kim-uijin";

create function pg_catalog.pg_get_function_sqlbody(oid) returns text
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.pg_get_function_sqlbody(oid) is 'function SQL body';

alter function pg_catalog.pg_get_function_sqlbody(oid) owner to "kim-uijin";

create function pg_catalog.unistr(text) returns text
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.unistr(text) is 'unescape Unicode characters';

alter function pg_catalog.unistr(text) owner to "kim-uijin";

create function pg_catalog.extract(text, date) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, date) is 'extract field from date';

alter function pg_catalog.extract(text, date) owner to "kim-uijin";

create function pg_catalog.extract(text, time) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, time) is 'extract field from time';

alter function pg_catalog.extract(text, time) owner to "kim-uijin";

create function pg_catalog.extract(text, time with time zone) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, time with time zone) is 'extract field from time with time zone';

alter function pg_catalog.extract(text, time with time zone) owner to "kim-uijin";

create function pg_catalog.extract(text, timestamp) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, timestamp) is 'extract field from timestamp';

alter function pg_catalog.extract(text, timestamp) owner to "kim-uijin";

create function pg_catalog.extract(text, timestamp with time zone) returns numeric
    stable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, timestamp with time zone) is 'extract field from timestamp with time zone';

alter function pg_catalog.extract(text, timestamp with time zone) owner to "kim-uijin";

create function pg_catalog.extract(text, interval) returns numeric
    immutable
    strict
    parallel safe
    cost 1
    language internal
as
$$
begin
-- missing source code
end;
$$;

comment on function pg_catalog.extract(text, interval) is 'extract field from interval';

alter function pg_catalog.extract(text, interval) owner to "kim-uijin";

create function pg_catalog.dsnowball_init(internal) returns internal
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.dsnowball_init(internal) owner to "kim-uijin";

create function pg_catalog.dsnowball_lexize(internal, internal, internal, internal) returns internal
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.dsnowball_lexize(internal, internal, internal, internal) owner to "kim-uijin";

create function information_schema._pg_expandarray(anyarray, OUT x anyelement, OUT n integer) returns SETOF record
    immutable
    strict
    parallel safe
    language sql
as
$$select $1[s],
         s operator(pg_catalog.-) pg_catalog.array_lower($1,1) operator(pg_catalog.+) 1
  from pg_catalog.generate_series(pg_catalog.array_lower($1,1),
                                  pg_catalog.array_upper($1,1),
                                  1) as g(s)$$;

alter function information_schema._pg_expandarray(anyarray, out anyelement, out integer) owner to "kim-uijin";

create function information_schema._pg_index_position(oid, smallint) returns integer
    stable
    strict
    language sql
BEGIN ATOMIC
SELECT (ss.a).n AS n
FROM ( SELECT information_schema._pg_expandarray(pg_index.indkey) AS a
       FROM pg_index
       WHERE (pg_index.indexrelid = $1)) ss
WHERE ((ss.a).x = $2);
END;

alter function information_schema._pg_index_position(oid, smallint) owner to "kim-uijin";

create function information_schema._pg_truetypid(pg_attribute, pg_type) returns oid
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (($2).typtype = 'd'::"char") THEN ($2).typbasetype ELSE ($1).atttypid END;

alter function information_schema._pg_truetypid(pg_attribute, pg_type) owner to "kim-uijin";

create function information_schema._pg_truetypmod(pg_attribute, pg_type) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (($2).typtype = 'd'::"char") THEN ($2).typtypmod ELSE ($1).atttypmod END;

alter function information_schema._pg_truetypmod(pg_attribute, pg_type) owner to "kim-uijin";

create function information_schema._pg_char_max_length(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer WHEN (typid = ANY (ARRAY[(1042)::oid, (1043)::oid])) THEN (typmod - 4) WHEN (typid = ANY (ARRAY[(1560)::oid, (1562)::oid])) THEN typmod ELSE NULL::integer END;

alter function information_schema._pg_char_max_length(oid, integer) owner to "kim-uijin";

create function information_schema._pg_char_octet_length(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typid = ANY (ARRAY[(25)::oid, (1042)::oid, (1043)::oid])) THEN CASE WHEN (typmod = '-1'::integer) THEN (((2)::double precision ^ (30)::double precision))::integer ELSE (information_schema._pg_char_max_length(typid, typmod) * pg_encoding_max_length((SELECT pg_database.encoding FROM pg_database WHERE (pg_database.datname = current_database())))) END ELSE NULL::integer END;

alter function information_schema._pg_char_octet_length(oid, integer) owner to "kim-uijin";

create function information_schema._pg_numeric_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE typid WHEN 21 THEN 16 WHEN 23 THEN 32 WHEN 20 THEN 64 WHEN 1700 THEN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer ELSE (((typmod - 4) >> 16) & 65535) END WHEN 700 THEN 24 WHEN 701 THEN 53 ELSE NULL::integer END;

alter function information_schema._pg_numeric_precision(oid, integer) owner to "kim-uijin";

create function information_schema._pg_numeric_precision_radix(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typid = ANY (ARRAY[(21)::oid, (23)::oid, (20)::oid, (700)::oid, (701)::oid])) THEN 2 WHEN (typid = (1700)::oid) THEN 10 ELSE NULL::integer END;

alter function information_schema._pg_numeric_precision_radix(oid, integer) owner to "kim-uijin";

create function information_schema._pg_numeric_scale(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typid = ANY (ARRAY[(21)::oid, (23)::oid, (20)::oid])) THEN 0 WHEN (typid = (1700)::oid) THEN CASE WHEN (typmod = '-1'::integer) THEN NULL::integer ELSE ((typmod - 4) & 65535) END ELSE NULL::integer END;

alter function information_schema._pg_numeric_scale(oid, integer) owner to "kim-uijin";

create function information_schema._pg_datetime_precision(typid oid, typmod integer) returns integer
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typid = (1082)::oid) THEN 0 WHEN (typid = ANY (ARRAY[(1083)::oid, (1114)::oid, (1184)::oid, (1266)::oid])) THEN CASE WHEN (typmod < 0) THEN 6 ELSE typmod END WHEN (typid = (1186)::oid) THEN CASE WHEN ((typmod < 0) OR ((typmod & 65535) = 65535)) THEN 6 ELSE (typmod & 65535) END ELSE NULL::integer END;

alter function information_schema._pg_datetime_precision(oid, integer) owner to "kim-uijin";

create function information_schema._pg_interval_type(typid oid, mod integer) returns text
    immutable
    strict
    parallel safe
    language sql
RETURN CASE WHEN (typid = (1186)::oid) THEN upper(SUBSTRING(format_type(typid, mod) SIMILAR 'interval[()0-9]* #"%#"'::text ESCAPE '#'::text)) ELSE NULL::text END;

alter function information_schema._pg_interval_type(oid, integer) owner to "kim-uijin";

create function pg_catalog.plpgsql_call_handler() returns language_handler
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_call_handler() owner to "kim-uijin";

create function pg_catalog.plpgsql_inline_handler(internal) returns void
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_inline_handler(internal) owner to "kim-uijin";

create function pg_catalog.plpgsql_validator(oid) returns void
    strict
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function pg_catalog.plpgsql_validator(oid) owner to "kim-uijin";

create function public.uuid_nil() returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_nil() owner to "kim-uijin";

create function public.uuid_ns_dns() returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_ns_dns() owner to "kim-uijin";

create function public.uuid_ns_url() returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_ns_url() owner to "kim-uijin";

create function public.uuid_ns_oid() returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_ns_oid() owner to "kim-uijin";

create function public.uuid_ns_x500() returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_ns_x500() owner to "kim-uijin";

create function public.uuid_generate_v1() returns uuid
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_generate_v1() owner to "kim-uijin";

create function public.uuid_generate_v1mc() returns uuid
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_generate_v1mc() owner to "kim-uijin";

create function public.uuid_generate_v3(namespace uuid, name text) returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_generate_v3(uuid, text) owner to "kim-uijin";

create function public.uuid_generate_v4() returns uuid
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_generate_v4() owner to "kim-uijin";

create function public.uuid_generate_v5(namespace uuid, name text) returns uuid
    immutable
    strict
    parallel safe
    language c
as
$$
begin
-- missing source code
end;
$$;

alter function public.uuid_generate_v5(uuid, text) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.array_append, leftarg = anycompatiblearray, rightarg = anycompatible);

comment on operator pg_catalog.||(anycompatiblearray, anycompatible) is 'append element onto end of array';

alter operator pg_catalog.||(anycompatiblearray, anycompatible) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.array_prepend, leftarg = anycompatible, rightarg = anycompatiblearray);

comment on operator pg_catalog.||(anycompatible, anycompatiblearray) is 'prepend element onto front of array';

alter operator pg_catalog.||(anycompatible, anycompatiblearray) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.array_cat, leftarg = anycompatiblearray, rightarg = anycompatiblearray);

comment on operator pg_catalog.||(anycompatiblearray, anycompatiblearray) is 'concatenate';

alter operator pg_catalog.||(anycompatiblearray, anycompatiblearray) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.cideq, leftarg = cid, rightarg = cid, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(cid, cid) is 'equal';

alter operator pg_catalog.=(cid, cid) owner to "kim-uijin";

create operator pg_catalog.% (procedure = pg_catalog.int8mod, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.%(bigint, bigint) is 'modulus';

alter operator pg_catalog.%(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.int8abs, rightarg = bigint);

comment on operator pg_catalog.@(none, bigint) is 'absolute value';

alter operator pg_catalog.@(none, bigint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int8um, rightarg = bigint);

comment on operator pg_catalog.-(none, bigint) is 'negate';

alter operator pg_catalog.-(none, bigint) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.poly_left, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(polygon, polygon) is 'is left of';

alter operator pg_catalog.<<(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.poly_overleft, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(polygon, polygon) is 'overlaps or is left of';

alter operator pg_catalog.&<(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.poly_overright, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(polygon, polygon) is 'overlaps or is right of';

alter operator pg_catalog.&>(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.poly_right, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(polygon, polygon) is 'is right of';

alter operator pg_catalog.>>(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.~= (procedure = pg_catalog.poly_same, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(polygon, polygon) is 'same as';

alter operator pg_catalog.~=(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.poly_overlap, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(polygon, polygon) is 'overlaps';

alter operator pg_catalog.&&(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.box_left, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(box, box) is 'is left of';

alter operator pg_catalog.<<(box, box) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.box_overleft, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(box, box) is 'overlaps or is left of';

alter operator pg_catalog.&<(box, box) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.box_overright, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(box, box) is 'overlaps or is right of';

alter operator pg_catalog.&>(box, box) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.box_right, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(box, box) is 'is right of';

alter operator pg_catalog.>>(box, box) owner to "kim-uijin";

create operator pg_catalog.~= (procedure = pg_catalog.box_same, leftarg = box, rightarg = box, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(box, box) is 'same as';

alter operator pg_catalog.~=(box, box) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(box, box) is 'overlaps';

alter operator pg_catalog.&&(box, box) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.box_eq, leftarg = box, rightarg = box, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(box, box) is 'equal by area';

alter operator pg_catalog.=(box, box) owner to "kim-uijin";

create operator pg_catalog.>^ (procedure = pg_catalog.point_above, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(point, point) is 'deprecated, use |>> instead';

alter operator pg_catalog.>^(point, point) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.point_left, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(point, point) is 'is left of';

alter operator pg_catalog.<<(point, point) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.point_right, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(point, point) is 'is right of';

alter operator pg_catalog.>>(point, point) owner to "kim-uijin";

create operator pg_catalog.<^ (procedure = pg_catalog.point_below, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(point, point) is 'deprecated, use <<| instead';

alter operator pg_catalog.<^(point, point) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.box_center, rightarg = box);

comment on operator pg_catalog.@@(none, box) is 'center of';

alter operator pg_catalog.@@(none, box) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int4mul, leftarg = integer, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, integer) is 'multiply';

alter operator pg_catalog.*(integer, integer) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.point_distance, leftarg = point, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, point) is 'distance between';

alter operator pg_catalog.<->(point, point) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int2mul, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, smallint) is 'multiply';

alter operator pg_catalog.*(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int2div, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog./(smallint, smallint) is 'divide';

alter operator pg_catalog./(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int4div, leftarg = integer, rightarg = integer);

comment on operator pg_catalog./(integer, integer) is 'divide';

alter operator pg_catalog./(integer, integer) owner to "kim-uijin";

create operator pg_catalog.% (procedure = pg_catalog.int2mod, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.%(smallint, smallint) is 'modulus';

alter operator pg_catalog.%(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.% (procedure = pg_catalog.int4mod, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.%(integer, integer) is 'modulus';

alter operator pg_catalog.%(integer, integer) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int24div, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog./(smallint, integer) is 'divide';

alter operator pg_catalog./(smallint, integer) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int42div, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog./(integer, smallint) is 'divide';

alter operator pg_catalog./(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int2pl, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, smallint) is 'add';

alter operator pg_catalog.+(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int4pl, leftarg = integer, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, integer) is 'add';

alter operator pg_catalog.+(integer, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int2mi, leftarg = smallint, rightarg = smallint);

comment on operator pg_catalog.-(smallint, smallint) is 'subtract';

alter operator pg_catalog.-(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int4mi, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.-(integer, integer) is 'subtract';

alter operator pg_catalog.-(integer, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int24mi, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.-(smallint, integer) is 'subtract';

alter operator pg_catalog.-(smallint, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int42mi, leftarg = integer, rightarg = smallint);

comment on operator pg_catalog.-(integer, smallint) is 'subtract';

alter operator pg_catalog.-(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int4um, rightarg = integer);

comment on operator pg_catalog.-(none, integer) is 'negate';

alter operator pg_catalog.-(none, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int2um, rightarg = smallint);

comment on operator pg_catalog.-(none, smallint) is 'negate';

alter operator pg_catalog.-(none, smallint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float4um, rightarg = real);

comment on operator pg_catalog.-(none, real) is 'negate';

alter operator pg_catalog.-(none, real) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float8um, rightarg = double precision);

comment on operator pg_catalog.-(none, double precision) is 'negate';

alter operator pg_catalog.-(none, double precision) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.float4pl, leftarg = real, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, real) is 'add';

alter operator pg_catalog.+(real, real) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float4mi, leftarg = real, rightarg = real);

comment on operator pg_catalog.-(real, real) is 'subtract';

alter operator pg_catalog.-(real, real) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.float4div, leftarg = real, rightarg = real);

comment on operator pg_catalog./(real, real) is 'divide';

alter operator pg_catalog./(real, real) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.float4mul, leftarg = real, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, real) is 'multiply';

alter operator pg_catalog.*(real, real) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.float4abs, rightarg = real);

comment on operator pg_catalog.@(none, real) is 'absolute value';

alter operator pg_catalog.@(none, real) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.float8pl, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, double precision) is 'add';

alter operator pg_catalog.+(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float8mi, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.-(double precision, double precision) is 'subtract';

alter operator pg_catalog.-(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.float8div, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog./(double precision, double precision) is 'divide';

alter operator pg_catalog./(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.float8mul, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, double precision) is 'multiply';

alter operator pg_catalog.*(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.float8abs, rightarg = double precision);

comment on operator pg_catalog.@(none, double precision) is 'absolute value';

alter operator pg_catalog.@(none, double precision) owner to "kim-uijin";

create operator pg_catalog.|/ (procedure = pg_catalog.dsqrt, rightarg = double precision);

comment on operator pg_catalog.|/(none, double precision) is 'square root';

alter operator pg_catalog.|/(none, double precision) owner to "kim-uijin";

create operator pg_catalog.||/ (procedure = pg_catalog.dcbrt, rightarg = double precision);

comment on operator pg_catalog.||/(none, double precision) is 'cube root';

alter operator pg_catalog.||/(none, double precision) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.textcat, leftarg = text, rightarg = text);

comment on operator pg_catalog.||(text, text) is 'concatenate';

alter operator pg_catalog.||(text, text) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.int2abs, rightarg = smallint);

comment on operator pg_catalog.@(none, smallint) is 'absolute value';

alter operator pg_catalog.@(none, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int8pl, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, bigint) is 'add';

alter operator pg_catalog.+(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int8mi, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog.-(bigint, bigint) is 'subtract';

alter operator pg_catalog.-(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int8mul, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, bigint) is 'multiply';

alter operator pg_catalog.*(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int8div, leftarg = bigint, rightarg = bigint);

comment on operator pg_catalog./(bigint, bigint) is 'divide';

alter operator pg_catalog./(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int84mi, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.-(bigint, integer) is 'subtract';

alter operator pg_catalog.-(bigint, integer) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int84div, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog./(bigint, integer) is 'divide';

alter operator pg_catalog./(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int48mi, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog.-(integer, bigint) is 'subtract';

alter operator pg_catalog.-(integer, bigint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int48div, leftarg = integer, rightarg = bigint);

comment on operator pg_catalog./(integer, bigint) is 'divide';

alter operator pg_catalog./(integer, bigint) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.box_distance, leftarg = box, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, box) is 'distance between';

alter operator pg_catalog.<->(box, box) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.path_distance, leftarg = path, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, path) is 'distance between';

alter operator pg_catalog.<->(path, path) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.line_distance, leftarg = line, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, line) is 'distance between';

alter operator pg_catalog.<->(line, line) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.lseg_distance, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, lseg) is 'distance between';

alter operator pg_catalog.<->(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.poly_distance, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, polygon) is 'distance between';

alter operator pg_catalog.<->(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.point_add, leftarg = point, rightarg = point, commutator = pg_catalog.+);

comment on operator pg_catalog.+(point, point) is 'add points (translate)';

alter operator pg_catalog.+(point, point) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.point_sub, leftarg = point, rightarg = point);

comment on operator pg_catalog.-(point, point) is 'subtract points (translate)';

alter operator pg_catalog.-(point, point) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.point_mul, leftarg = point, rightarg = point, commutator = pg_catalog.*);

comment on operator pg_catalog.*(point, point) is 'multiply points (scale/rotate)';

alter operator pg_catalog.*(point, point) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.point_div, leftarg = point, rightarg = point);

comment on operator pg_catalog./(point, point) is 'divide points (scale/rotate)';

alter operator pg_catalog./(point, point) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.path_add, leftarg = path, rightarg = path, commutator = pg_catalog.+);

comment on operator pg_catalog.+(path, path) is 'concatenate';

alter operator pg_catalog.+(path, path) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.path_add_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.+(path, point) is 'add (translate path)';

alter operator pg_catalog.+(path, point) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.path_sub_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.-(path, point) is 'subtract (translate path)';

alter operator pg_catalog.-(path, point) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.path_mul_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog.*(path, point) is 'multiply (rotate/scale path)';

alter operator pg_catalog.*(path, point) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.path_div_pt, leftarg = path, rightarg = point);

comment on operator pg_catalog./(path, point) is 'divide (rotate/scale path)';

alter operator pg_catalog./(path, point) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.int4abs, rightarg = integer);

comment on operator pg_catalog.@(none, integer) is 'absolute value';

alter operator pg_catalog.@(none, integer) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.path_n_eq, leftarg = path, rightarg = path, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(path, path) is 'equal';

alter operator pg_catalog.=(path, path) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.path_npoints, rightarg = path);

comment on operator pg_catalog.#(none, path) is 'number of points';

alter operator pg_catalog.#(none, path) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.path_inter, leftarg = path, rightarg = path);

comment on operator pg_catalog.?#(path, path) is 'intersect';

alter operator pg_catalog.?#(path, path) owner to "kim-uijin";

create operator pg_catalog.@-@ (procedure = pg_catalog.path_length, rightarg = path);

comment on operator pg_catalog.@-@(none, path) is 'sum of path segment lengths';

alter operator pg_catalog.@-@(none, path) owner to "kim-uijin";

create operator pg_catalog.>^ (procedure = pg_catalog.box_above_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>^(box, box) is 'is above (allows touching)';

alter operator pg_catalog.>^(box, box) owner to "kim-uijin";

create operator pg_catalog.<^ (procedure = pg_catalog.box_below_eq, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<^(box, box) is 'is below (allows touching)';

alter operator pg_catalog.<^(box, box) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.box_overlap, leftarg = box, rightarg = box, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.?#(box, box) is 'deprecated, use && instead';

alter operator pg_catalog.?#(box, box) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.box_intersect, leftarg = box, rightarg = box);

comment on operator pg_catalog.#(box, box) is 'box intersection';

alter operator pg_catalog.#(box, box) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.box_add, leftarg = box, rightarg = point);

comment on operator pg_catalog.+(box, point) is 'add point to box (translate)';

alter operator pg_catalog.+(box, point) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.box_sub, leftarg = box, rightarg = point);

comment on operator pg_catalog.-(box, point) is 'subtract point from box (translate)';

alter operator pg_catalog.-(box, point) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.box_mul, leftarg = box, rightarg = point);

comment on operator pg_catalog.*(box, point) is 'multiply box by point (scale)';

alter operator pg_catalog.*(box, point) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.box_div, leftarg = box, rightarg = point);

comment on operator pg_catalog./(box, point) is 'divide box by point (scale)';

alter operator pg_catalog./(box, point) owner to "kim-uijin";

create operator pg_catalog.?- (procedure = pg_catalog.point_horiz, leftarg = point, rightarg = point, commutator = pg_catalog.?-);

comment on operator pg_catalog.?-(point, point) is 'horizontally aligned';

alter operator pg_catalog.?-(point, point) owner to "kim-uijin";

create operator pg_catalog.?| (procedure = pg_catalog.point_vert, leftarg = point, rightarg = point, commutator = pg_catalog.?|);

comment on operator pg_catalog.?|(point, point) is 'vertically aligned';

alter operator pg_catalog.?|(point, point) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int82mi, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog.-(bigint, smallint) is 'subtract';

alter operator pg_catalog.-(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int82div, leftarg = bigint, rightarg = smallint);

comment on operator pg_catalog./(bigint, smallint) is 'divide';

alter operator pg_catalog./(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.int28mi, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog.-(smallint, bigint) is 'subtract';

alter operator pg_catalog.-(smallint, bigint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.int28div, leftarg = smallint, rightarg = bigint);

comment on operator pg_catalog./(smallint, bigint) is 'divide';

alter operator pg_catalog./(smallint, bigint) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt4, leftarg = money, rightarg = real);

comment on operator pg_catalog./(money, real) is 'divide';

alter operator pg_catalog./(money, real) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.cash_pl, leftarg = money, rightarg = money, commutator = pg_catalog.+);

comment on operator pg_catalog.+(money, money) is 'add';

alter operator pg_catalog.+(money, money) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.cash_mi, leftarg = money, rightarg = money);

comment on operator pg_catalog.-(money, money) is 'subtract';

alter operator pg_catalog.-(money, money) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_flt8, leftarg = money, rightarg = double precision);

comment on operator pg_catalog./(money, double precision) is 'divide';

alter operator pg_catalog./(money, double precision) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int4, leftarg = money, rightarg = integer);

comment on operator pg_catalog./(money, integer) is 'divide';

alter operator pg_catalog./(money, integer) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int2, leftarg = money, rightarg = smallint);

comment on operator pg_catalog./(money, smallint) is 'divide';

alter operator pg_catalog./(money, smallint) owner to "kim-uijin";

create operator pg_catalog.^ (procedure = pg_catalog.dpow, leftarg = double precision, rightarg = double precision);

comment on operator pg_catalog.^(double precision, double precision) is 'exponentiation';

alter operator pg_catalog.^(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.aclinsert, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.+(aclitem[], aclitem) is 'add/update ACL item';

alter operator pg_catalog.+(aclitem[], aclitem) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.aclremove, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.-(aclitem[], aclitem) is 'remove ACL item';

alter operator pg_catalog.-(aclitem[], aclitem) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.aclcontains, leftarg = aclitem[], rightarg = aclitem);

comment on operator pg_catalog.@>(aclitem[], aclitem) is 'contains';

alter operator pg_catalog.@>(aclitem[], aclitem) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.lseg_center, rightarg = lseg);

comment on operator pg_catalog.@@(none, lseg) is 'center of';

alter operator pg_catalog.@@(none, lseg) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.path_center, rightarg = path);

comment on operator pg_catalog.@@(none, path) is 'center of';

alter operator pg_catalog.@@(none, path) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.poly_center, rightarg = polygon);

comment on operator pg_catalog.@@(none, polygon) is 'center of';

alter operator pg_catalog.@@(none, polygon) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.aclitemeq, leftarg = aclitem, rightarg = aclitem, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(aclitem, aclitem) is 'equal';

alter operator pg_catalog.=(aclitem, aclitem) owner to "kim-uijin";

create operator pg_catalog.^ (procedure = pg_catalog.numeric_power, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.^(numeric, numeric) is 'exponentiation';

alter operator pg_catalog.^(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.date_mi_interval, leftarg = date, rightarg = interval);

comment on operator pg_catalog.-(date, interval) is 'subtract';

alter operator pg_catalog.-(date, interval) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.date_mi, leftarg = date, rightarg = date);

comment on operator pg_catalog.-(date, date) is 'subtract';

alter operator pg_catalog.-(date, date) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.date_mii, leftarg = date, rightarg = integer);

comment on operator pg_catalog.-(date, integer) is 'subtract';

alter operator pg_catalog.-(date, integer) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float48mi, leftarg = real, rightarg = double precision);

comment on operator pg_catalog.-(real, double precision) is 'subtract';

alter operator pg_catalog.-(real, double precision) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.float48div, leftarg = real, rightarg = double precision);

comment on operator pg_catalog./(real, double precision) is 'divide';

alter operator pg_catalog./(real, double precision) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.float84mi, leftarg = double precision, rightarg = real);

comment on operator pg_catalog.-(double precision, real) is 'subtract';

alter operator pg_catalog.-(double precision, real) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.float84div, leftarg = double precision, rightarg = real);

comment on operator pg_catalog./(double precision, real) is 'divide';

alter operator pg_catalog./(double precision, real) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi, leftarg = timestamp with time zone, rightarg = timestamp with time zone);

comment on operator pg_catalog.-(timestamp with time zone, timestamp with time zone) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.timestamptz_mi_interval, leftarg = timestamp with time zone, rightarg = interval);

comment on operator pg_catalog.-(timestamp with time zone, interval) is 'subtract';

alter operator pg_catalog.-(timestamp with time zone, interval) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.interval_um, rightarg = interval);

comment on operator pg_catalog.-(none, interval) is 'negate';

alter operator pg_catalog.-(none, interval) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl, leftarg = interval, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, interval) is 'add';

alter operator pg_catalog.+(interval, interval) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.interval_mi, leftarg = interval, rightarg = interval);

comment on operator pg_catalog.-(interval, interval) is 'subtract';

alter operator pg_catalog.-(interval, interval) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.time_mi_time, leftarg = time, rightarg = time);

comment on operator pg_catalog.-(time, time) is 'subtract';

alter operator pg_catalog.-(time, time) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.circle_center, rightarg = circle);

comment on operator pg_catalog.@@(none, circle) is 'center of';

alter operator pg_catalog.@@(none, circle) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.circle_left, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<(circle, circle) is 'is left of';

alter operator pg_catalog.<<(circle, circle) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.circle_overleft, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<(circle, circle) is 'overlaps or is left of';

alter operator pg_catalog.&<(circle, circle) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.circle_overright, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&>(circle, circle) is 'overlaps or is right of';

alter operator pg_catalog.&>(circle, circle) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.circle_right, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.>>(circle, circle) is 'is right of';

alter operator pg_catalog.>>(circle, circle) owner to "kim-uijin";

create operator pg_catalog.~= (procedure = pg_catalog.circle_same, leftarg = circle, rightarg = circle, commutator = pg_catalog.~=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(circle, circle) is 'same as';

alter operator pg_catalog.~=(circle, circle) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.circle_overlap, leftarg = circle, rightarg = circle, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.&&(circle, circle) is 'overlaps';

alter operator pg_catalog.&&(circle, circle) owner to "kim-uijin";

create operator pg_catalog.|>> (procedure = pg_catalog.circle_above, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(circle, circle) is 'is above';

alter operator pg_catalog.|>>(circle, circle) owner to "kim-uijin";

create operator pg_catalog.<<| (procedure = pg_catalog.circle_below, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(circle, circle) is 'is below';

alter operator pg_catalog.<<|(circle, circle) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.circle_add_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.+(circle, point) is 'add';

alter operator pg_catalog.+(circle, point) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.circle_sub_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.-(circle, point) is 'subtract';

alter operator pg_catalog.-(circle, point) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.circle_mul_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog.*(circle, point) is 'multiply';

alter operator pg_catalog.*(circle, point) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.circle_div_pt, leftarg = circle, rightarg = point);

comment on operator pg_catalog./(circle, point) is 'divide';

alter operator pg_catalog./(circle, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.circle_distance, leftarg = circle, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, circle) is 'distance between';

alter operator pg_catalog.<->(circle, circle) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.poly_npoints, rightarg = polygon);

comment on operator pg_catalog.#(none, polygon) is 'number of points';

alter operator pg_catalog.#(none, polygon) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.lseg_intersect, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(lseg, lseg) is 'intersect';

alter operator pg_catalog.?#(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.?|| (procedure = pg_catalog.lseg_parallel, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(lseg, lseg) is 'parallel';

alter operator pg_catalog.?||(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.?-| (procedure = pg_catalog.lseg_perp, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(lseg, lseg) is 'perpendicular';

alter operator pg_catalog.?-|(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.?- (procedure = pg_catalog.lseg_horizontal, rightarg = lseg);

comment on operator pg_catalog.?-(none, lseg) is 'horizontal';

alter operator pg_catalog.?-(none, lseg) owner to "kim-uijin";

create operator pg_catalog.?| (procedure = pg_catalog.lseg_vertical, rightarg = lseg);

comment on operator pg_catalog.?|(none, lseg) is 'vertical';

alter operator pg_catalog.?|(none, lseg) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.lseg_interpt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.#);

comment on operator pg_catalog.#(lseg, lseg) is 'intersection point';

alter operator pg_catalog.#(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.inter_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.?#(lseg, line) is 'intersect';

alter operator pg_catalog.?#(lseg, line) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.inter_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.?#(lseg, box) is 'intersect';

alter operator pg_catalog.?#(lseg, box) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.inter_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.?#(line, box) is 'intersect';

alter operator pg_catalog.?#(line, box) owner to "kim-uijin";

create operator pg_catalog.<@ (procedure = pg_catalog.on_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.<@(point, line) is 'point on line';

alter operator pg_catalog.<@(point, line) owner to "kim-uijin";

create operator pg_catalog.<@ (procedure = pg_catalog.on_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.<@(point, lseg) is 'is contained by';

alter operator pg_catalog.<@(point, lseg) owner to "kim-uijin";

create operator pg_catalog.<@ (procedure = pg_catalog.on_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.<@(lseg, line) is 'lseg on line';

alter operator pg_catalog.<@(lseg, line) owner to "kim-uijin";

create operator pg_catalog.<@ (procedure = pg_catalog.on_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.<@(lseg, box) is 'is contained by';

alter operator pg_catalog.<@(lseg, box) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_pl, leftarg = point, rightarg = line);

comment on operator pg_catalog.##(point, line) is 'closest point to A on B';

alter operator pg_catalog.##(point, line) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_ps, leftarg = point, rightarg = lseg);

comment on operator pg_catalog.##(point, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(point, lseg) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_pb, leftarg = point, rightarg = box);

comment on operator pg_catalog.##(point, box) is 'closest point to A on B';

alter operator pg_catalog.##(point, box) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_sl, leftarg = lseg, rightarg = line);

comment on operator pg_catalog.##(lseg, line) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, line) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_sb, leftarg = lseg, rightarg = box);

comment on operator pg_catalog.##(lseg, box) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, box) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_lb, leftarg = line, rightarg = box);

comment on operator pg_catalog.##(line, box) is 'closest point to A on B';

alter operator pg_catalog.##(line, box) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_ls, leftarg = line, rightarg = lseg);

comment on operator pg_catalog.##(line, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(line, lseg) owner to "kim-uijin";

create operator pg_catalog.## (procedure = pg_catalog.close_lseg, leftarg = lseg, rightarg = lseg);

comment on operator pg_catalog.##(lseg, lseg) is 'closest point to A on B';

alter operator pg_catalog.##(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.interval_div, leftarg = interval, rightarg = double precision);

comment on operator pg_catalog./(interval, double precision) is 'divide';

alter operator pg_catalog./(interval, double precision) owner to "kim-uijin";

create operator pg_catalog.@-@ (procedure = pg_catalog.lseg_length, rightarg = lseg);

comment on operator pg_catalog.@-@(none, lseg) is 'distance between endpoints';

alter operator pg_catalog.@-@(none, lseg) owner to "kim-uijin";

create operator pg_catalog.?# (procedure = pg_catalog.line_intersect, leftarg = line, rightarg = line, commutator = pg_catalog.?#);

comment on operator pg_catalog.?#(line, line) is 'intersect';

alter operator pg_catalog.?#(line, line) owner to "kim-uijin";

create operator pg_catalog.?|| (procedure = pg_catalog.line_parallel, leftarg = line, rightarg = line, commutator = pg_catalog.?||);

comment on operator pg_catalog.?||(line, line) is 'parallel';

alter operator pg_catalog.?||(line, line) owner to "kim-uijin";

create operator pg_catalog.?-| (procedure = pg_catalog.line_perp, leftarg = line, rightarg = line, commutator = pg_catalog.?-|);

comment on operator pg_catalog.?-|(line, line) is 'perpendicular';

alter operator pg_catalog.?-|(line, line) owner to "kim-uijin";

create operator pg_catalog.?- (procedure = pg_catalog.line_horizontal, rightarg = line);

comment on operator pg_catalog.?-(none, line) is 'horizontal';

alter operator pg_catalog.?-(none, line) owner to "kim-uijin";

create operator pg_catalog.?| (procedure = pg_catalog.line_vertical, rightarg = line);

comment on operator pg_catalog.?|(none, line) is 'vertical';

alter operator pg_catalog.?|(none, line) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.line_eq, leftarg = line, rightarg = line, commutator = pg_catalog.=, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(line, line) is 'equal';

alter operator pg_catalog.=(line, line) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.line_interpt, leftarg = line, rightarg = line, commutator = pg_catalog.#);

comment on operator pg_catalog.#(line, line) is 'intersection point';

alter operator pg_catalog.#(line, line) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.numeric_uminus, rightarg = numeric);

comment on operator pg_catalog.-(none, numeric) is 'negate';

alter operator pg_catalog.-(none, numeric) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.numeric_add, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, numeric) is 'add';

alter operator pg_catalog.+(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.numeric_sub, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.-(numeric, numeric) is 'subtract';

alter operator pg_catalog.-(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.numeric_mul, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.*);

comment on operator pg_catalog.*(numeric, numeric) is 'multiply';

alter operator pg_catalog.*(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.numeric_div, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog./(numeric, numeric) is 'divide';

alter operator pg_catalog./(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.% (procedure = pg_catalog.numeric_mod, leftarg = numeric, rightarg = numeric);

comment on operator pg_catalog.%(numeric, numeric) is 'modulus';

alter operator pg_catalog.%(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.@ (procedure = pg_catalog.numeric_abs, rightarg = numeric);

comment on operator pg_catalog.@(none, numeric) is 'absolute value';

alter operator pg_catalog.@(none, numeric) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.bitand, leftarg = bit, rightarg = bit, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bit, bit) is 'bitwise and';

alter operator pg_catalog.&(bit, bit) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.bitor, leftarg = bit, rightarg = bit, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bit, bit) is 'bitwise or';

alter operator pg_catalog.|(bit, bit) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.bitxor, leftarg = bit, rightarg = bit, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bit, bit) is 'bitwise exclusive or';

alter operator pg_catalog.#(bit, bit) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.bitnot, rightarg = bit);

comment on operator pg_catalog.~(none, bit) is 'bitwise not';

alter operator pg_catalog.~(none, bit) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.bitshiftleft, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.<<(bit, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bit, integer) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.bitshiftright, leftarg = bit, rightarg = integer);

comment on operator pg_catalog.>>(bit, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bit, integer) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.bitcat, leftarg = bit varying, rightarg = bit varying);

comment on operator pg_catalog.||(bit varying, bit varying) is 'concatenate';

alter operator pg_catalog.||(bit varying, bit varying) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.time_mi_interval, leftarg = time, rightarg = interval);

comment on operator pg_catalog.-(time, interval) is 'subtract';

alter operator pg_catalog.-(time, interval) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.timetz_mi_interval, leftarg = time with time zone, rightarg = interval);

comment on operator pg_catalog.-(time with time zone, interval) is 'subtract';

alter operator pg_catalog.-(time with time zone, interval) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.int2and, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(smallint, smallint) is 'bitwise and';

alter operator pg_catalog.&(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.int2or, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(smallint, smallint) is 'bitwise or';

alter operator pg_catalog.|(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.int2xor, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(smallint, smallint) is 'bitwise exclusive or';

alter operator pg_catalog.#(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.int2not, rightarg = smallint);

comment on operator pg_catalog.~(none, smallint) is 'bitwise not';

alter operator pg_catalog.~(none, smallint) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.int2shl, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.<<(smallint, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(smallint, integer) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.int2shr, leftarg = smallint, rightarg = integer);

comment on operator pg_catalog.>>(smallint, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(smallint, integer) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.int4and, leftarg = integer, rightarg = integer, commutator = pg_catalog.&);

comment on operator pg_catalog.&(integer, integer) is 'bitwise and';

alter operator pg_catalog.&(integer, integer) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.int4or, leftarg = integer, rightarg = integer, commutator = pg_catalog.|);

comment on operator pg_catalog.|(integer, integer) is 'bitwise or';

alter operator pg_catalog.|(integer, integer) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.int4xor, leftarg = integer, rightarg = integer, commutator = pg_catalog.#);

comment on operator pg_catalog.#(integer, integer) is 'bitwise exclusive or';

alter operator pg_catalog.#(integer, integer) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.int4not, rightarg = integer);

comment on operator pg_catalog.~(none, integer) is 'bitwise not';

alter operator pg_catalog.~(none, integer) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.int4shl, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.<<(integer, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(integer, integer) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.int4shr, leftarg = integer, rightarg = integer);

comment on operator pg_catalog.>>(integer, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(integer, integer) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.int8and, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.&);

comment on operator pg_catalog.&(bigint, bigint) is 'bitwise and';

alter operator pg_catalog.&(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.int8or, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.|);

comment on operator pg_catalog.|(bigint, bigint) is 'bitwise or';

alter operator pg_catalog.|(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.# (procedure = pg_catalog.int8xor, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.#);

comment on operator pg_catalog.#(bigint, bigint) is 'bitwise exclusive or';

alter operator pg_catalog.#(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.int8not, rightarg = bigint);

comment on operator pg_catalog.~(none, bigint) is 'bitwise not';

alter operator pg_catalog.~(none, bigint) owner to "kim-uijin";

create operator pg_catalog.<< (procedure = pg_catalog.int8shl, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.<<(bigint, integer) is 'bitwise shift left';

alter operator pg_catalog.<<(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.int8shr, leftarg = bigint, rightarg = integer);

comment on operator pg_catalog.>>(bigint, integer) is 'bitwise shift right';

alter operator pg_catalog.>>(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int8up, rightarg = bigint);

comment on operator pg_catalog.+(none, bigint) is 'unary plus';

alter operator pg_catalog.+(none, bigint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int2up, rightarg = smallint);

comment on operator pg_catalog.+(none, smallint) is 'unary plus';

alter operator pg_catalog.+(none, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int4up, rightarg = integer);

comment on operator pg_catalog.+(none, integer) is 'unary plus';

alter operator pg_catalog.+(none, integer) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.float4up, rightarg = real);

comment on operator pg_catalog.+(none, real) is 'unary plus';

alter operator pg_catalog.+(none, real) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.float8up, rightarg = double precision);

comment on operator pg_catalog.+(none, double precision) is 'unary plus';

alter operator pg_catalog.+(none, double precision) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.numeric_uplus, rightarg = numeric);

comment on operator pg_catalog.+(none, numeric) is 'unary plus';

alter operator pg_catalog.+(none, numeric) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.byteacat, leftarg = bytea, rightarg = bytea);

comment on operator pg_catalog.||(bytea, bytea) is 'concatenate';

alter operator pg_catalog.||(bytea, bytea) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi, leftarg = timestamp, rightarg = timestamp);

comment on operator pg_catalog.-(timestamp, timestamp) is 'subtract';

alter operator pg_catalog.-(timestamp, timestamp) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.timestamp_mi_interval, leftarg = timestamp, rightarg = interval);

comment on operator pg_catalog.-(timestamp, interval) is 'subtract';

alter operator pg_catalog.-(timestamp, interval) owner to "kim-uijin";

create operator pg_catalog.<<| (procedure = pg_catalog.box_below, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(box, box) is 'is below';

alter operator pg_catalog.<<|(box, box) owner to "kim-uijin";

create operator pg_catalog.&<| (procedure = pg_catalog.box_overbelow, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(box, box) is 'overlaps or is below';

alter operator pg_catalog.&<|(box, box) owner to "kim-uijin";

create operator pg_catalog.|&> (procedure = pg_catalog.box_overabove, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(box, box) is 'overlaps or is above';

alter operator pg_catalog.|&>(box, box) owner to "kim-uijin";

create operator pg_catalog.|>> (procedure = pg_catalog.box_above, leftarg = box, rightarg = box, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(box, box) is 'is above';

alter operator pg_catalog.|>>(box, box) owner to "kim-uijin";

create operator pg_catalog.<<| (procedure = pg_catalog.poly_below, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(polygon, polygon) is 'is below';

alter operator pg_catalog.<<|(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.&<| (procedure = pg_catalog.poly_overbelow, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(polygon, polygon) is 'overlaps or is below';

alter operator pg_catalog.&<|(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.|&> (procedure = pg_catalog.poly_overabove, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(polygon, polygon) is 'overlaps or is above';

alter operator pg_catalog.|&>(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.|>> (procedure = pg_catalog.poly_above, leftarg = polygon, rightarg = polygon, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(polygon, polygon) is 'is above';

alter operator pg_catalog.|>>(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.&<| (procedure = pg_catalog.circle_overbelow, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.&<|(circle, circle) is 'overlaps or is below';

alter operator pg_catalog.&<|(circle, circle) owner to "kim-uijin";

create operator pg_catalog.|&> (procedure = pg_catalog.circle_overabove, leftarg = circle, rightarg = circle, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|&>(circle, circle) is 'overlaps or is above';

alter operator pg_catalog.|&>(circle, circle) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.inetnot, rightarg = inet);

comment on operator pg_catalog.~(none, inet) is 'bitwise not';

alter operator pg_catalog.~(none, inet) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.inetand, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.&(inet, inet) is 'bitwise and';

alter operator pg_catalog.&(inet, inet) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.inetor, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.|(inet, inet) is 'bitwise or';

alter operator pg_catalog.|(inet, inet) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.inetmi_int8, leftarg = inet, rightarg = bigint);

comment on operator pg_catalog.-(inet, bigint) is 'subtract';

alter operator pg_catalog.-(inet, bigint) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.inetmi, leftarg = inet, rightarg = inet);

comment on operator pg_catalog.-(inet, inet) is 'subtract';

alter operator pg_catalog.-(inet, inet) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.arrayoverlap, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.&&, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.&&(anyarray, anyarray) is 'overlaps';

alter operator pg_catalog.&&(anyarray, anyarray) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.textanycat, leftarg = text, rightarg = anynonarray);

comment on operator pg_catalog.||(text, anynonarray) is 'concatenate';

alter operator pg_catalog.||(text, anynonarray) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.anytextcat, leftarg = anynonarray, rightarg = text);

comment on operator pg_catalog.||(anynonarray, text) is 'concatenate';

alter operator pg_catalog.||(anynonarray, text) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.multirange_overlaps_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&&(anymultirange, anymultirange) is 'overlaps';

alter operator pg_catalog.&&(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.range_overleft_multirange, leftarg = anyrange, rightarg = anymultirange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&<(anyrange, anymultirange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anyrange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.multirange_overleft_range, leftarg = anymultirange, rightarg = anyrange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&<(anymultirange, anyrange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.multirange_overleft_multirange, leftarg = anymultirange, rightarg = anymultirange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&<(anymultirange, anymultirange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.macaddr_not, rightarg = macaddr);

comment on operator pg_catalog.~(none, macaddr) is 'bitwise not';

alter operator pg_catalog.~(none, macaddr) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.macaddr_and, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.&(macaddr, macaddr) is 'bitwise and';

alter operator pg_catalog.&(macaddr, macaddr) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.macaddr_or, leftarg = macaddr, rightarg = macaddr);

comment on operator pg_catalog.|(macaddr, macaddr) is 'bitwise or';

alter operator pg_catalog.|(macaddr, macaddr) owner to "kim-uijin";

create operator pg_catalog.#>> (procedure = pg_catalog.jsonb_extract_path_text, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>>(jsonb, text[]) is 'get value from jsonb as text with path elements';

alter operator pg_catalog.#>>(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_object_field, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->(jsonb, text) is 'get jsonb object field';

alter operator pg_catalog.->(jsonb, text) owner to "kim-uijin";

create operator pg_catalog.-> (procedure = pg_catalog.jsonb_array_element, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->(jsonb, integer) is 'get jsonb array element';

alter operator pg_catalog.->(jsonb, integer) owner to "kim-uijin";

create operator pg_catalog.#> (procedure = pg_catalog.jsonb_extract_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#>(jsonb, text[]) is 'get value from jsonb with path elements';

alter operator pg_catalog.#>(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.pg_lsn_mi, leftarg = pg_lsn, rightarg = pg_lsn);

comment on operator pg_catalog.-(pg_lsn, pg_lsn) is 'minus';

alter operator pg_catalog.-(pg_lsn, pg_lsn) owner to "kim-uijin";

create operator pg_catalog.? (procedure = pg_catalog.jsonb_exists, leftarg = jsonb, rightarg = text, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?(jsonb, text) is 'key exists';

alter operator pg_catalog.?(jsonb, text) owner to "kim-uijin";

create operator pg_catalog.?| (procedure = pg_catalog.jsonb_exists_any, leftarg = jsonb, rightarg = text[], join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?|(jsonb, text[]) is 'any key exists';

alter operator pg_catalog.?|(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog.?& (procedure = pg_catalog.jsonb_exists_all, leftarg = jsonb, rightarg = text[], join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.?&(jsonb, text[]) is 'all keys exist';

alter operator pg_catalog.?&(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.jsonb_concat, leftarg = jsonb, rightarg = jsonb);

comment on operator pg_catalog.||(jsonb, jsonb) is 'concatenate';

alter operator pg_catalog.||(jsonb, jsonb) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.-(jsonb, text) is 'delete object field';

alter operator pg_catalog.-(jsonb, text) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.-(jsonb, integer) is 'delete array element';

alter operator pg_catalog.-(jsonb, integer) owner to "kim-uijin";

create operator pg_catalog.#- (procedure = pg_catalog.jsonb_delete_path, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.#-(jsonb, text[]) is 'delete path';

alter operator pg_catalog.#-(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_int8, leftarg = money, rightarg = bigint);

comment on operator pg_catalog./(money, bigint) is 'divide';

alter operator pg_catalog./(money, bigint) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.macaddr8_not, rightarg = macaddr8);

comment on operator pg_catalog.~(none, macaddr8) is 'bitwise not';

alter operator pg_catalog.~(none, macaddr8) owner to "kim-uijin";

create operator pg_catalog.& (procedure = pg_catalog.macaddr8_and, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.&(macaddr8, macaddr8) is 'bitwise and';

alter operator pg_catalog.&(macaddr8, macaddr8) owner to "kim-uijin";

create operator pg_catalog.| (procedure = pg_catalog.macaddr8_or, leftarg = macaddr8, rightarg = macaddr8);

comment on operator pg_catalog.|(macaddr8, macaddr8) is 'bitwise or';

alter operator pg_catalog.|(macaddr8, macaddr8) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.jsonb_delete, leftarg = jsonb, rightarg = text[]);

comment on operator pg_catalog.-(jsonb, text[]) is 'delete object fields';

alter operator pg_catalog.-(jsonb, text[]) owner to "kim-uijin";

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_object_field_text, leftarg = jsonb, rightarg = text);

comment on operator pg_catalog.->>(jsonb, text) is 'get jsonb object field as text';

alter operator pg_catalog.->>(jsonb, text) owner to "kim-uijin";

create operator pg_catalog.->> (procedure = pg_catalog.jsonb_array_element_text, leftarg = jsonb, rightarg = integer);

comment on operator pg_catalog.->>(jsonb, integer) is 'get jsonb array element as text';

alter operator pg_catalog.->>(jsonb, integer) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.network_overlap, leftarg = inet, rightarg = inet, commutator = pg_catalog.&&, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.&&(inet, inet) is 'overlaps (is subnet or supernet)';

alter operator pg_catalog.&&(inet, inet) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.range_overright_multirange, leftarg = anyrange, rightarg = anymultirange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&>(anyrange, anymultirange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anyrange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.tsvector_concat, leftarg = tsvector, rightarg = tsvector);

comment on operator pg_catalog.||(tsvector, tsvector) is 'concatenate';

alter operator pg_catalog.||(tsvector, tsvector) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.tsquery_and, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.&&(tsquery, tsquery) is 'AND-concatenate';

alter operator pg_catalog.&&(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.|| (procedure = pg_catalog.tsquery_or, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.||(tsquery, tsquery) is 'OR-concatenate';

alter operator pg_catalog.||(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.!! (procedure = pg_catalog.tsquery_not, rightarg = tsquery);

comment on operator pg_catalog.!!(none, tsquery) is 'NOT tsquery';

alter operator pg_catalog.!!(none, tsquery) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tt, leftarg = text, rightarg = text, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(text, text) is 'text search match';

alter operator pg_catalog.@@(text, text) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_tq, leftarg = text, rightarg = tsquery, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(text, tsquery) is 'text search match';

alter operator pg_catalog.@@(text, tsquery) owner to "kim-uijin";

create operator pg_catalog./ (procedure = pg_catalog.cash_div_cash, leftarg = money, rightarg = money);

comment on operator pg_catalog./(money, money) is 'divide';

alter operator pg_catalog./(money, money) owner to "kim-uijin";

create operator pg_catalog.^@ (procedure = pg_catalog.starts_with, leftarg = text, rightarg = text, join = pg_catalog.prefixjoinsel, restrict = pg_catalog.prefixsel);

comment on operator pg_catalog.^@(text, text) is 'starts with';

alter operator pg_catalog.^@(text, text) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.range_overlaps, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&&(anyrange, anyrange) is 'overlaps';

alter operator pg_catalog.&&(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.&< (procedure = pg_catalog.range_overleft, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&<(anyrange, anyrange) is 'overlaps or is left of';

alter operator pg_catalog.&<(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.range_overright, leftarg = anyrange, rightarg = anyrange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.&>(anyrange, anyrange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.-|- (procedure = pg_catalog.range_adjacent, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.-|-, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.-|-(anyrange, anyrange) is 'is adjacent to';

alter operator pg_catalog.-|-(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.range_union, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anyrange, anyrange) is 'range union';

alter operator pg_catalog.+(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.range_minus, leftarg = anyrange, rightarg = anyrange);

comment on operator pg_catalog.-(anyrange, anyrange) is 'range difference';

alter operator pg_catalog.-(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.range_intersect, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anyrange, anyrange) is 'range intersection';

alter operator pg_catalog.*(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.-> (procedure = pg_catalog.json_object_field, leftarg = json, rightarg = text);

comment on operator pg_catalog.->(json, text) is 'get json object field';

alter operator pg_catalog.->(json, text) owner to "kim-uijin";

create operator pg_catalog.->> (procedure = pg_catalog.json_object_field_text, leftarg = json, rightarg = text);

comment on operator pg_catalog.->>(json, text) is 'get json object field as text';

alter operator pg_catalog.->>(json, text) owner to "kim-uijin";

create operator pg_catalog.-> (procedure = pg_catalog.json_array_element, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->(json, integer) is 'get json array element';

alter operator pg_catalog.->(json, integer) owner to "kim-uijin";

create operator pg_catalog.->> (procedure = pg_catalog.json_array_element_text, leftarg = json, rightarg = integer);

comment on operator pg_catalog.->>(json, integer) is 'get json array element as text';

alter operator pg_catalog.->>(json, integer) owner to "kim-uijin";

create operator pg_catalog.#> (procedure = pg_catalog.json_extract_path, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>(json, text[]) is 'get value from json with path elements';

alter operator pg_catalog.#>(json, text[]) owner to "kim-uijin";

create operator pg_catalog.#>> (procedure = pg_catalog.json_extract_path_text, leftarg = json, rightarg = text[]);

comment on operator pg_catalog.#>>(json, text[]) is 'get value from json as text with path elements';

alter operator pg_catalog.#>>(json, text[]) owner to "kim-uijin";

create operator pg_catalog.@? (procedure = pg_catalog.jsonb_path_exists_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@?(jsonb, jsonpath) is 'jsonpath exists';

alter operator pg_catalog.@?(jsonb, jsonpath) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.jsonb_path_match_opr, leftarg = jsonb, rightarg = jsonpath, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@@(jsonb, jsonpath) is 'jsonpath match';

alter operator pg_catalog.@@(jsonb, jsonpath) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.multirange_overright_range, leftarg = anymultirange, rightarg = anyrange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&>(anymultirange, anyrange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.&> (procedure = pg_catalog.multirange_overright_multirange, leftarg = anymultirange, rightarg = anymultirange, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&>(anymultirange, anymultirange) is 'overlaps or is right of';

alter operator pg_catalog.&>(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.|>> (procedure = pg_catalog.point_above, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.|>>(point, point) is 'is above';

alter operator pg_catalog.|>>(point, point) owner to "kim-uijin";

create operator pg_catalog.<<| (procedure = pg_catalog.point_below, leftarg = point, rightarg = point, join = pg_catalog.positionjoinsel, restrict = pg_catalog.positionsel);

comment on operator pg_catalog.<<|(point, point) is 'is below';

alter operator pg_catalog.<<|(point, point) owner to "kim-uijin";

create operator pg_catalog.-|- (procedure = pg_catalog.multirange_adjacent_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.-|-, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.-|-(anymultirange, anymultirange) is 'is adjacent to';

alter operator pg_catalog.-|-(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.multirange_union, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.+);

comment on operator pg_catalog.+(anymultirange, anymultirange) is 'multirange union';

alter operator pg_catalog.+(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.multirange_minus, leftarg = anymultirange, rightarg = anymultirange);

comment on operator pg_catalog.-(anymultirange, anymultirange) is 'multirange minus';

alter operator pg_catalog.-(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.multirange_intersect, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.*);

comment on operator pg_catalog.*(anymultirange, anymultirange) is 'multirange intersect';

alter operator pg_catalog.*(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.tsquery_phrase, leftarg = tsquery, rightarg = tsquery);

comment on operator pg_catalog.<->(tsquery, tsquery) is 'phrase-concatenate';

alter operator pg_catalog.<->(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.- (procedure = pg_catalog.pg_lsn_mii, leftarg = pg_lsn, rightarg = numeric);

comment on operator pg_catalog.-(pg_lsn, numeric) is 'subtract';

alter operator pg_catalog.-(pg_lsn, numeric) owner to "kim-uijin";

create collation pg_catalog."default" (
    locale = ???
    );

comment on collation pg_catalog."default" is 'database''s default collation';

alter collation pg_catalog."default" owner to "kim-uijin";

create collation pg_catalog."C" (
    locale = 'C'
    );

comment on collation pg_catalog."C" is 'standard C collation';

alter collation pg_catalog."C" owner to "kim-uijin";

create collation pg_catalog."POSIX" (
    locale = 'POSIX'
    );

comment on collation pg_catalog."POSIX" is 'standard POSIX collation';

alter collation pg_catalog."POSIX" owner to "kim-uijin";

create collation pg_catalog.ucs_basic (
    locale = 'C'
    );

alter collation pg_catalog.ucs_basic owner to "kim-uijin";

create collation pg_catalog."en_NZ" (
    locale = 'en_NZ'
    );

alter collation pg_catalog."en_NZ" owner to "kim-uijin";

create collation pg_catalog."nl_NL.UTF-8" (
    locale = 'nl_NL.UTF-8'
    );

alter collation pg_catalog."nl_NL.UTF-8" owner to "kim-uijin";

create collation pg_catalog."pt_BR.UTF-8" (
    locale = 'pt_BR.UTF-8'
    );

alter collation pg_catalog."pt_BR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."fr_CH.ISO8859-15" (
    locale = 'fr_CH.ISO8859-15'
    );

alter collation pg_catalog."fr_CH.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."eu_ES.ISO8859-15" (
    locale = 'eu_ES.ISO8859-15'
    );

alter collation pg_catalog."eu_ES.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."af_ZA" (
    locale = 'af_ZA'
    );

alter collation pg_catalog."af_ZA" owner to "kim-uijin";

create collation pg_catalog."bg_BG" (
    locale = 'bg_BG'
    );

alter collation pg_catalog."bg_BG" owner to "kim-uijin";

create collation pg_catalog."cs_CZ.UTF-8" (
    locale = 'cs_CZ.UTF-8'
    );

alter collation pg_catalog."cs_CZ.UTF-8" owner to "kim-uijin";

create collation pg_catalog."fi_FI" (
    locale = 'fi_FI'
    );

alter collation pg_catalog."fi_FI" owner to "kim-uijin";

create collation pg_catalog."zh_CN.UTF-8" (
    locale = 'zh_CN.UTF-8'
    );

alter collation pg_catalog."zh_CN.UTF-8" owner to "kim-uijin";

create collation pg_catalog."eu_ES" (
    locale = 'eu_ES'
    );

alter collation pg_catalog."eu_ES" owner to "kim-uijin";

create collation pg_catalog."sk_SK.ISO8859-2" (
    locale = 'sk_SK.ISO8859-2'
    );

alter collation pg_catalog."sk_SK.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."nl_BE" (
    locale = 'nl_BE'
    );

alter collation pg_catalog."nl_BE" owner to "kim-uijin";

create collation pg_catalog."fr_BE" (
    locale = 'fr_BE'
    );

alter collation pg_catalog."fr_BE" owner to "kim-uijin";

create collation pg_catalog."sk_SK" (
    locale = 'sk_SK'
    );

alter collation pg_catalog."sk_SK" owner to "kim-uijin";

create collation pg_catalog."en_US.UTF-8" (
    locale = 'en_US.UTF-8'
    );

alter collation pg_catalog."en_US.UTF-8" owner to "kim-uijin";

create collation pg_catalog."en_NZ.ISO8859-1" (
    locale = 'en_NZ.ISO8859-1'
    );

alter collation pg_catalog."en_NZ.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."de_CH" (
    locale = 'de_CH'
    );

alter collation pg_catalog."de_CH" owner to "kim-uijin";

create collation pg_catalog."sk_SK.UTF-8" (
    locale = 'sk_SK.UTF-8'
    );

alter collation pg_catalog."sk_SK.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_DE.UTF-8" (
    locale = 'de_DE.UTF-8'
    );

alter collation pg_catalog."de_DE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."am_ET.UTF-8" (
    locale = 'am_ET.UTF-8'
    );

alter collation pg_catalog."am_ET.UTF-8" owner to "kim-uijin";

create collation pg_catalog."zh_HK" (
    locale = 'zh_HK'
    );

alter collation pg_catalog."zh_HK" owner to "kim-uijin";

create collation pg_catalog."be_BY.UTF-8" (
    locale = 'be_BY.UTF-8'
    );

alter collation pg_catalog."be_BY.UTF-8" owner to "kim-uijin";

create collation pg_catalog."uk_UA" (
    locale = 'uk_UA'
    );

alter collation pg_catalog."uk_UA" owner to "kim-uijin";

create collation pg_catalog."pt_PT.ISO8859-1" (
    locale = 'pt_PT.ISO8859-1'
    );

alter collation pg_catalog."pt_PT.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_US" (
    locale = 'en_US'
    );

alter collation pg_catalog."en_US" owner to "kim-uijin";

create collation pg_catalog."nl_BE.ISO8859-15" (
    locale = 'nl_BE.ISO8859-15'
    );

alter collation pg_catalog."nl_BE.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."de_AT.ISO8859-1" (
    locale = 'de_AT.ISO8859-1'
    );

alter collation pg_catalog."de_AT.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."hr_HR.ISO8859-2" (
    locale = 'hr_HR.ISO8859-2'
    );

alter collation pg_catalog."hr_HR.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."fr_FR.ISO8859-1" (
    locale = 'fr_FR.ISO8859-1'
    );

alter collation pg_catalog."fr_FR.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."af_ZA.UTF-8" (
    locale = 'af_ZA.UTF-8'
    );

alter collation pg_catalog."af_ZA.UTF-8" owner to "kim-uijin";

create collation pg_catalog."am_ET" (
    locale = 'am_ET'
    );

alter collation pg_catalog."am_ET" owner to "kim-uijin";

create collation pg_catalog."fi_FI.ISO8859-1" (
    locale = 'fi_FI.ISO8859-1'
    );

alter collation pg_catalog."fi_FI.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."ro_RO.UTF-8" (
    locale = 'ro_RO.UTF-8'
    );

alter collation pg_catalog."ro_RO.UTF-8" owner to "kim-uijin";

create collation pg_catalog."af_ZA.ISO8859-15" (
    locale = 'af_ZA.ISO8859-15'
    );

alter collation pg_catalog."af_ZA.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_NZ.UTF-8" (
    locale = 'en_NZ.UTF-8'
    );

alter collation pg_catalog."en_NZ.UTF-8" owner to "kim-uijin";

create collation pg_catalog."fi_FI.UTF-8" (
    locale = 'fi_FI.UTF-8'
    );

alter collation pg_catalog."fi_FI.UTF-8" owner to "kim-uijin";

create collation pg_catalog."hr_HR.UTF-8" (
    locale = 'hr_HR.UTF-8'
    );

alter collation pg_catalog."hr_HR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."da_DK.UTF-8" (
    locale = 'da_DK.UTF-8'
    );

alter collation pg_catalog."da_DK.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ca_ES.ISO8859-1" (
    locale = 'ca_ES.ISO8859-1'
    );

alter collation pg_catalog."ca_ES.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_AU.ISO8859-15" (
    locale = 'en_AU.ISO8859-15'
    );

alter collation pg_catalog."en_AU.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."ro_RO.ISO8859-2" (
    locale = 'ro_RO.ISO8859-2'
    );

alter collation pg_catalog."ro_RO.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."de_AT.UTF-8" (
    locale = 'de_AT.UTF-8'
    );

alter collation pg_catalog."de_AT.UTF-8" owner to "kim-uijin";

create collation pg_catalog."pt_PT.ISO8859-15" (
    locale = 'pt_PT.ISO8859-15'
    );

alter collation pg_catalog."pt_PT.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE'
    );

alter collation pg_catalog."sv_SE" owner to "kim-uijin";

create collation pg_catalog."fr_CA.ISO8859-1" (
    locale = 'fr_CA.ISO8859-1'
    );

alter collation pg_catalog."fr_CA.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."fr_BE.ISO8859-1" (
    locale = 'fr_BE.ISO8859-1'
    );

alter collation pg_catalog."fr_BE.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_US.ISO8859-15" (
    locale = 'en_US.ISO8859-15'
    );

alter collation pg_catalog."en_US.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."it_CH.ISO8859-1" (
    locale = 'it_CH.ISO8859-1'
    );

alter collation pg_catalog."it_CH.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_NZ.ISO8859-15" (
    locale = 'en_NZ.ISO8859-15'
    );

alter collation pg_catalog."en_NZ.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_AU.UTF-8" (
    locale = 'en_AU.UTF-8'
    );

alter collation pg_catalog."en_AU.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_AT.ISO8859-15" (
    locale = 'de_AT.ISO8859-15'
    );

alter collation pg_catalog."de_AT.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."af_ZA.ISO8859-1" (
    locale = 'af_ZA.ISO8859-1'
    );

alter collation pg_catalog."af_ZA.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."hu_HU.UTF-8" (
    locale = 'hu_HU.UTF-8'
    );

alter collation pg_catalog."hu_HU.UTF-8" owner to "kim-uijin";

create collation pg_catalog."et_EE.UTF-8" (
    locale = 'et_EE.UTF-8'
    );

alter collation pg_catalog."et_EE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."he_IL.UTF-8" (
    locale = 'he_IL.UTF-8'
    );

alter collation pg_catalog."he_IL.UTF-8" owner to "kim-uijin";

create collation pg_catalog."uk_UA.KOI8-U" (
    locale = 'uk_UA.KOI8-U'
    );

alter collation pg_catalog."uk_UA.KOI8-U" owner to "kim-uijin";

create collation pg_catalog."be_BY" (
    locale = 'be_BY'
    );

alter collation pg_catalog."be_BY" owner to "kim-uijin";

create collation pg_catalog."kk_KZ" (
    locale = 'kk_KZ'
    );

alter collation pg_catalog."kk_KZ" owner to "kim-uijin";

create collation pg_catalog."hu_HU.ISO8859-2" (
    locale = 'hu_HU.ISO8859-2'
    );

alter collation pg_catalog."hu_HU.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."it_CH" (
    locale = 'it_CH'
    );

alter collation pg_catalog."it_CH" owner to "kim-uijin";

create collation pg_catalog."pt_BR" (
    locale = 'pt_BR'
    );

alter collation pg_catalog."pt_BR" owner to "kim-uijin";

create collation pg_catalog."ko_KR" (
    locale = 'ko_KR'
    );

alter collation pg_catalog."ko_KR" owner to "kim-uijin";

create collation pg_catalog."it_IT" (
    locale = 'it_IT'
    );

alter collation pg_catalog."it_IT" owner to "kim-uijin";

create collation pg_catalog."fr_BE.UTF-8" (
    locale = 'fr_BE.UTF-8'
    );

alter collation pg_catalog."fr_BE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ru_RU.ISO8859-5" (
    locale = 'ru_RU.ISO8859-5'
    );

alter collation pg_catalog."ru_RU.ISO8859-5" owner to "kim-uijin";

create collation pg_catalog."zh_TW" (
    locale = 'zh_TW'
    );

alter collation pg_catalog."zh_TW" owner to "kim-uijin";

create collation pg_catalog."zh_CN.GB2312" (
    locale = 'zh_CN.GB2312'
    );

alter collation pg_catalog."zh_CN.GB2312" owner to "kim-uijin";

create collation pg_catalog."no_NO.ISO8859-15" (
    locale = 'no_NO.ISO8859-15'
    );

alter collation pg_catalog."no_NO.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."de_DE.ISO8859-15" (
    locale = 'de_DE.ISO8859-15'
    );

alter collation pg_catalog."de_DE.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_CA" (
    locale = 'en_CA'
    );

alter collation pg_catalog."en_CA" owner to "kim-uijin";

create collation pg_catalog."fr_CH.UTF-8" (
    locale = 'fr_CH.UTF-8'
    );

alter collation pg_catalog."fr_CH.UTF-8" owner to "kim-uijin";

create collation pg_catalog."sl_SI.UTF-8" (
    locale = 'sl_SI.UTF-8'
    );

alter collation pg_catalog."sl_SI.UTF-8" owner to "kim-uijin";

create collation pg_catalog."uk_UA.ISO8859-5" (
    locale = 'uk_UA.ISO8859-5'
    );

alter collation pg_catalog."uk_UA.ISO8859-5" owner to "kim-uijin";

create collation pg_catalog."pt_PT" (
    locale = 'pt_PT'
    );

alter collation pg_catalog."pt_PT" owner to "kim-uijin";

create collation pg_catalog."hr_HR" (
    locale = 'hr_HR'
    );

alter collation pg_catalog."hr_HR" owner to "kim-uijin";

create collation pg_catalog."cs_CZ" (
    locale = 'cs_CZ'
    );

alter collation pg_catalog."cs_CZ" owner to "kim-uijin";

create collation pg_catalog."fr_CH" (
    locale = 'fr_CH'
    );

alter collation pg_catalog."fr_CH" owner to "kim-uijin";

create collation pg_catalog."he_IL" (
    locale = 'he_IL'
    );

alter collation pg_catalog."he_IL" owner to "kim-uijin";

create collation pg_catalog."fr_CA" (
    locale = 'fr_CA'
    );

alter collation pg_catalog."fr_CA" owner to "kim-uijin";

create collation pg_catalog."pl_PL.UTF-8" (
    locale = 'pl_PL.UTF-8'
    );

alter collation pg_catalog."pl_PL.UTF-8" owner to "kim-uijin";

create collation pg_catalog."sr_YU.ISO8859-5" (
    locale = 'sr_YU.ISO8859-5'
    );

alter collation pg_catalog."sr_YU.ISO8859-5" owner to "kim-uijin";

create collation pg_catalog."be_BY.CP1251" (
    locale = 'be_BY.CP1251'
    );

alter collation pg_catalog."be_BY.CP1251" owner to "kim-uijin";

create collation pg_catalog."sr_YU.ISO8859-2" (
    locale = 'sr_YU.ISO8859-2'
    );

alter collation pg_catalog."sr_YU.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."sv_SE.UTF-8" (
    locale = 'sv_SE.UTF-8'
    );

alter collation pg_catalog."sv_SE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."sr_YU.UTF-8" (
    locale = 'sr_YU.UTF-8'
    );

alter collation pg_catalog."sr_YU.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_CH.UTF-8" (
    locale = 'de_CH.UTF-8'
    );

alter collation pg_catalog."de_CH.UTF-8" owner to "kim-uijin";

create collation pg_catalog."sl_SI" (
    locale = 'sl_SI'
    );

alter collation pg_catalog."sl_SI" owner to "kim-uijin";

create collation pg_catalog."pt_PT.UTF-8" (
    locale = 'pt_PT.UTF-8'
    );

alter collation pg_catalog."pt_PT.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ro_RO" (
    locale = 'ro_RO'
    );

alter collation pg_catalog."ro_RO" owner to "kim-uijin";

create collation pg_catalog."ja_JP" (
    locale = 'ja_JP'
    );

alter collation pg_catalog."ja_JP" owner to "kim-uijin";

create collation pg_catalog."zh_CN" (
    locale = 'zh_CN'
    );

alter collation pg_catalog."zh_CN" owner to "kim-uijin";

create collation pg_catalog."fr_CH.ISO8859-1" (
    locale = 'fr_CH.ISO8859-1'
    );

alter collation pg_catalog."fr_CH.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."ko_KR.eucKR" (
    locale = 'ko_KR.eucKR'
    );

alter collation pg_catalog."ko_KR.eucKR" owner to "kim-uijin";

create collation pg_catalog."be_BY.ISO8859-5" (
    locale = 'be_BY.ISO8859-5'
    );

alter collation pg_catalog."be_BY.ISO8859-5" owner to "kim-uijin";

create collation pg_catalog."nl_NL.ISO8859-15" (
    locale = 'nl_NL.ISO8859-15'
    );

alter collation pg_catalog."nl_NL.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_GB.ISO8859-1" (
    locale = 'en_GB.ISO8859-1'
    );

alter collation pg_catalog."en_GB.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."is_IS.ISO8859-1" (
    locale = 'is_IS.ISO8859-1'
    );

alter collation pg_catalog."is_IS.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."ru_RU.CP866" (
    locale = 'ru_RU.CP866'
    );

alter collation pg_catalog."ru_RU.CP866" owner to "kim-uijin";

create collation pg_catalog."nl_NL" (
    locale = 'nl_NL'
    );

alter collation pg_catalog."nl_NL" owner to "kim-uijin";

create collation pg_catalog."fr_CA.ISO8859-15" (
    locale = 'fr_CA.ISO8859-15'
    );

alter collation pg_catalog."fr_CA.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."sv_SE.ISO8859-15" (
    locale = 'sv_SE.ISO8859-15'
    );

alter collation pg_catalog."sv_SE.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."hy_AM" (
    locale = 'hy_AM'
    );

alter collation pg_catalog."hy_AM" owner to "kim-uijin";

create collation pg_catalog."en_CA.ISO8859-15" (
    locale = 'en_CA.ISO8859-15'
    );

alter collation pg_catalog."en_CA.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_US.ISO8859-1" (
    locale = 'en_US.ISO8859-1'
    );

alter collation pg_catalog."en_US.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."ca_ES.UTF-8" (
    locale = 'ca_ES.UTF-8'
    );

alter collation pg_catalog."ca_ES.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ru_RU.CP1251" (
    locale = 'ru_RU.CP1251'
    );

alter collation pg_catalog."ru_RU.CP1251" owner to "kim-uijin";

create collation pg_catalog."en_GB.UTF-8" (
    locale = 'en_GB.UTF-8'
    );

alter collation pg_catalog."en_GB.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ru_RU.UTF-8" (
    locale = 'ru_RU.UTF-8'
    );

alter collation pg_catalog."ru_RU.UTF-8" owner to "kim-uijin";

create collation pg_catalog."eu_ES.UTF-8" (
    locale = 'eu_ES.UTF-8'
    );

alter collation pg_catalog."eu_ES.UTF-8" owner to "kim-uijin";

create collation pg_catalog."es_ES.ISO8859-1" (
    locale = 'es_ES.ISO8859-1'
    );

alter collation pg_catalog."es_ES.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."hu_HU" (
    locale = 'hu_HU'
    );

alter collation pg_catalog."hu_HU" owner to "kim-uijin";

create collation pg_catalog."el_GR.ISO8859-7" (
    locale = 'el_GR.ISO8859-7'
    );

alter collation pg_catalog."el_GR.ISO8859-7" owner to "kim-uijin";

create collation pg_catalog."en_AU" (
    locale = 'en_AU'
    );

alter collation pg_catalog."en_AU" owner to "kim-uijin";

create collation pg_catalog."it_CH.UTF-8" (
    locale = 'it_CH.UTF-8'
    );

alter collation pg_catalog."it_CH.UTF-8" owner to "kim-uijin";

create collation pg_catalog."en_GB" (
    locale = 'en_GB'
    );

alter collation pg_catalog."en_GB" owner to "kim-uijin";

create collation pg_catalog."sl_SI.ISO8859-2" (
    locale = 'sl_SI.ISO8859-2'
    );

alter collation pg_catalog."sl_SI.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."ru_RU.KOI8-R" (
    locale = 'ru_RU.KOI8-R'
    );

alter collation pg_catalog."ru_RU.KOI8-R" owner to "kim-uijin";

create collation pg_catalog."nl_BE.UTF-8" (
    locale = 'nl_BE.UTF-8'
    );

alter collation pg_catalog."nl_BE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."et_EE" (
    locale = 'et_EE'
    );

alter collation pg_catalog."et_EE" owner to "kim-uijin";

create collation pg_catalog."fr_FR.ISO8859-15" (
    locale = 'fr_FR.ISO8859-15'
    );

alter collation pg_catalog."fr_FR.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."cs_CZ.ISO8859-2" (
    locale = 'cs_CZ.ISO8859-2'
    );

alter collation pg_catalog."cs_CZ.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."lt_LT.UTF-8" (
    locale = 'lt_LT.UTF-8'
    );

alter collation pg_catalog."lt_LT.UTF-8" owner to "kim-uijin";

create collation pg_catalog."pl_PL.ISO8859-2" (
    locale = 'pl_PL.ISO8859-2'
    );

alter collation pg_catalog."pl_PL.ISO8859-2" owner to "kim-uijin";

create collation pg_catalog."fr_BE.ISO8859-15" (
    locale = 'fr_BE.ISO8859-15'
    );

alter collation pg_catalog."fr_BE.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."is_IS.UTF-8" (
    locale = 'is_IS.UTF-8'
    );

alter collation pg_catalog."is_IS.UTF-8" owner to "kim-uijin";

create collation pg_catalog."tr_TR.ISO8859-9" (
    locale = 'tr_TR.ISO8859-9'
    );

alter collation pg_catalog."tr_TR.ISO8859-9" owner to "kim-uijin";

create collation pg_catalog."da_DK.ISO8859-1" (
    locale = 'da_DK.ISO8859-1'
    );

alter collation pg_catalog."da_DK.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."lt_LT.ISO8859-4" (
    locale = 'lt_LT.ISO8859-4'
    );

alter collation pg_catalog."lt_LT.ISO8859-4" owner to "kim-uijin";

create collation pg_catalog."lt_LT.ISO8859-13" (
    locale = 'lt_LT.ISO8859-13'
    );

alter collation pg_catalog."lt_LT.ISO8859-13" owner to "kim-uijin";

create collation pg_catalog."zh_TW.UTF-8" (
    locale = 'zh_TW.UTF-8'
    );

alter collation pg_catalog."zh_TW.UTF-8" owner to "kim-uijin";

create collation pg_catalog."bg_BG.CP1251" (
    locale = 'bg_BG.CP1251'
    );

alter collation pg_catalog."bg_BG.CP1251" owner to "kim-uijin";

create collation pg_catalog."el_GR.UTF-8" (
    locale = 'el_GR.UTF-8'
    );

alter collation pg_catalog."el_GR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."da_DK.ISO8859-15" (
    locale = 'da_DK.ISO8859-15'
    );

alter collation pg_catalog."da_DK.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."is_IS.ISO8859-15" (
    locale = 'is_IS.ISO8859-15'
    );

alter collation pg_catalog."is_IS.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."no_NO.ISO8859-1" (
    locale = 'no_NO.ISO8859-1'
    );

alter collation pg_catalog."no_NO.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."nl_NL.ISO8859-1" (
    locale = 'nl_NL.ISO8859-1'
    );

alter collation pg_catalog."nl_NL.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."nl_BE.ISO8859-1" (
    locale = 'nl_BE.ISO8859-1'
    );

alter collation pg_catalog."nl_BE.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."sv_SE.ISO8859-1" (
    locale = 'sv_SE.ISO8859-1'
    );

alter collation pg_catalog."sv_SE.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."pt_BR.ISO8859-1" (
    locale = 'pt_BR.ISO8859-1'
    );

alter collation pg_catalog."pt_BR.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."zh_CN.eucCN" (
    locale = 'zh_CN.eucCN'
    );

alter collation pg_catalog."zh_CN.eucCN" owner to "kim-uijin";

create collation pg_catalog."it_IT.UTF-8" (
    locale = 'it_IT.UTF-8'
    );

alter collation pg_catalog."it_IT.UTF-8" owner to "kim-uijin";

create collation pg_catalog."en_CA.UTF-8" (
    locale = 'en_CA.UTF-8'
    );

alter collation pg_catalog."en_CA.UTF-8" owner to "kim-uijin";

create collation pg_catalog."uk_UA.UTF-8" (
    locale = 'uk_UA.UTF-8'
    );

alter collation pg_catalog."uk_UA.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_CH.ISO8859-15" (
    locale = 'de_CH.ISO8859-15'
    );

alter collation pg_catalog."de_CH.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."de_DE.ISO8859-1" (
    locale = 'de_DE.ISO8859-1'
    );

alter collation pg_catalog."de_DE.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."ca_ES" (
    locale = 'ca_ES'
    );

alter collation pg_catalog."ca_ES" owner to "kim-uijin";

create collation pg_catalog."sr_YU" (
    locale = 'sr_YU'
    );

alter collation pg_catalog."sr_YU" owner to "kim-uijin";

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU'
    );

alter collation pg_catalog."ru_RU" owner to "kim-uijin";

create collation pg_catalog."zh_HK.UTF-8" (
    locale = 'zh_HK.UTF-8'
    );

alter collation pg_catalog."zh_HK.UTF-8" owner to "kim-uijin";

create collation pg_catalog."eu_ES.ISO8859-1" (
    locale = 'eu_ES.ISO8859-1'
    );

alter collation pg_catalog."eu_ES.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."is_IS" (
    locale = 'is_IS'
    );

alter collation pg_catalog."is_IS" owner to "kim-uijin";

create collation pg_catalog."bg_BG.UTF-8" (
    locale = 'bg_BG.UTF-8'
    );

alter collation pg_catalog."bg_BG.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ja_JP.UTF-8" (
    locale = 'ja_JP.UTF-8'
    );

alter collation pg_catalog."ja_JP.UTF-8" owner to "kim-uijin";

create collation pg_catalog."it_CH.ISO8859-15" (
    locale = 'it_CH.ISO8859-15'
    );

alter collation pg_catalog."it_CH.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."fr_FR.UTF-8" (
    locale = 'fr_FR.UTF-8'
    );

alter collation pg_catalog."fr_FR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ko_KR.UTF-8" (
    locale = 'ko_KR.UTF-8'
    );

alter collation pg_catalog."ko_KR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."et_EE.ISO8859-15" (
    locale = 'et_EE.ISO8859-15'
    );

alter collation pg_catalog."et_EE.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."kk_KZ.UTF-8" (
    locale = 'kk_KZ.UTF-8'
    );

alter collation pg_catalog."kk_KZ.UTF-8" owner to "kim-uijin";

create collation pg_catalog."ca_ES.ISO8859-15" (
    locale = 'ca_ES.ISO8859-15'
    );

alter collation pg_catalog."ca_ES.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_IE.UTF-8" (
    locale = 'en_IE.UTF-8'
    );

alter collation pg_catalog."en_IE.UTF-8" owner to "kim-uijin";

create collation pg_catalog."es_ES" (
    locale = 'es_ES'
    );

alter collation pg_catalog."es_ES" owner to "kim-uijin";

create collation pg_catalog."de_CH.ISO8859-1" (
    locale = 'de_CH.ISO8859-1'
    );

alter collation pg_catalog."de_CH.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_CA.ISO8859-1" (
    locale = 'en_CA.ISO8859-1'
    );

alter collation pg_catalog."en_CA.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."es_ES.ISO8859-15" (
    locale = 'es_ES.ISO8859-15'
    );

alter collation pg_catalog."es_ES.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_AU.ISO8859-1" (
    locale = 'en_AU.ISO8859-1'
    );

alter collation pg_catalog."en_AU.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."el_GR" (
    locale = 'el_GR'
    );

alter collation pg_catalog."el_GR" owner to "kim-uijin";

create collation pg_catalog."da_DK" (
    locale = 'da_DK'
    );

alter collation pg_catalog."da_DK" owner to "kim-uijin";

create collation pg_catalog."no_NO" (
    locale = 'no_NO'
    );

alter collation pg_catalog."no_NO" owner to "kim-uijin";

create collation pg_catalog."it_IT.ISO8859-1" (
    locale = 'it_IT.ISO8859-1'
    );

alter collation pg_catalog."it_IT.ISO8859-1" owner to "kim-uijin";

create collation pg_catalog."en_IE" (
    locale = 'en_IE'
    );

alter collation pg_catalog."en_IE" owner to "kim-uijin";

create collation pg_catalog."ja_JP.eucJP" (
    locale = 'ja_JP.eucJP'
    );

alter collation pg_catalog."ja_JP.eucJP" owner to "kim-uijin";

create collation pg_catalog."it_IT.ISO8859-15" (
    locale = 'it_IT.ISO8859-15'
    );

alter collation pg_catalog."it_IT.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."pl_PL" (
    locale = 'pl_PL'
    );

alter collation pg_catalog."pl_PL" owner to "kim-uijin";

create collation pg_catalog."fr_CA.UTF-8" (
    locale = 'fr_CA.UTF-8'
    );

alter collation pg_catalog."fr_CA.UTF-8" owner to "kim-uijin";

create collation pg_catalog."fi_FI.ISO8859-15" (
    locale = 'fi_FI.ISO8859-15'
    );

alter collation pg_catalog."fi_FI.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."en_GB.ISO8859-15" (
    locale = 'en_GB.ISO8859-15'
    );

alter collation pg_catalog."en_GB.ISO8859-15" owner to "kim-uijin";

create collation pg_catalog."fr_FR" (
    locale = 'fr_FR'
    );

alter collation pg_catalog."fr_FR" owner to "kim-uijin";

create collation pg_catalog."hy_AM.UTF-8" (
    locale = 'hy_AM.UTF-8'
    );

alter collation pg_catalog."hy_AM.UTF-8" owner to "kim-uijin";

create collation pg_catalog."no_NO.UTF-8" (
    locale = 'no_NO.UTF-8'
    );

alter collation pg_catalog."no_NO.UTF-8" owner to "kim-uijin";

create collation pg_catalog."es_ES.UTF-8" (
    locale = 'es_ES.UTF-8'
    );

alter collation pg_catalog."es_ES.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_AT" (
    locale = 'de_AT'
    );

alter collation pg_catalog."de_AT" owner to "kim-uijin";

create collation pg_catalog."tr_TR.UTF-8" (
    locale = 'tr_TR.UTF-8'
    );

alter collation pg_catalog."tr_TR.UTF-8" owner to "kim-uijin";

create collation pg_catalog."de_DE" (
    locale = 'de_DE'
    );

alter collation pg_catalog."de_DE" owner to "kim-uijin";

create collation pg_catalog."lt_LT" (
    locale = 'lt_LT'
    );

alter collation pg_catalog."lt_LT" owner to "kim-uijin";

create collation pg_catalog."tr_TR" (
    locale = 'tr_TR'
    );

alter collation pg_catalog."tr_TR" owner to "kim-uijin";

create collation pg_catalog."af_ZA" (
    locale = 'af_ZA.ISO8859-1'
    );

alter collation pg_catalog."af_ZA" owner to "kim-uijin";

create collation pg_catalog."af_ZA" (
    locale = 'af_ZA.ISO8859-15'
    );

alter collation pg_catalog."af_ZA" owner to "kim-uijin";

create collation pg_catalog."be_BY" (
    locale = 'be_BY.CP1251'
    );

alter collation pg_catalog."be_BY" owner to "kim-uijin";

create collation pg_catalog."be_BY" (
    locale = 'be_BY.ISO8859-5'
    );

alter collation pg_catalog."be_BY" owner to "kim-uijin";

create collation pg_catalog."bg_BG" (
    locale = 'bg_BG.CP1251'
    );

alter collation pg_catalog."bg_BG" owner to "kim-uijin";

create collation pg_catalog."ca_ES" (
    locale = 'ca_ES.ISO8859-1'
    );

alter collation pg_catalog."ca_ES" owner to "kim-uijin";

create collation pg_catalog."ca_ES" (
    locale = 'ca_ES.ISO8859-15'
    );

alter collation pg_catalog."ca_ES" owner to "kim-uijin";

create collation pg_catalog."cs_CZ" (
    locale = 'cs_CZ.ISO8859-2'
    );

alter collation pg_catalog."cs_CZ" owner to "kim-uijin";

create collation pg_catalog."da_DK" (
    locale = 'da_DK.ISO8859-1'
    );

alter collation pg_catalog."da_DK" owner to "kim-uijin";

create collation pg_catalog."da_DK" (
    locale = 'da_DK.ISO8859-15'
    );

alter collation pg_catalog."da_DK" owner to "kim-uijin";

create collation pg_catalog."de_AT" (
    locale = 'de_AT.ISO8859-1'
    );

alter collation pg_catalog."de_AT" owner to "kim-uijin";

create collation pg_catalog."de_AT" (
    locale = 'de_AT.ISO8859-15'
    );

alter collation pg_catalog."de_AT" owner to "kim-uijin";

create collation pg_catalog."de_CH" (
    locale = 'de_CH.ISO8859-1'
    );

alter collation pg_catalog."de_CH" owner to "kim-uijin";

create collation pg_catalog."de_CH" (
    locale = 'de_CH.ISO8859-15'
    );

alter collation pg_catalog."de_CH" owner to "kim-uijin";

create collation pg_catalog."de_DE" (
    locale = 'de_DE.ISO8859-1'
    );

alter collation pg_catalog."de_DE" owner to "kim-uijin";

create collation pg_catalog."de_DE" (
    locale = 'de_DE.ISO8859-15'
    );

alter collation pg_catalog."de_DE" owner to "kim-uijin";

create collation pg_catalog."el_GR" (
    locale = 'el_GR.ISO8859-7'
    );

alter collation pg_catalog."el_GR" owner to "kim-uijin";

create collation pg_catalog."en_AU" (
    locale = 'en_AU.ISO8859-1'
    );

alter collation pg_catalog."en_AU" owner to "kim-uijin";

create collation pg_catalog."en_AU" (
    locale = 'en_AU.ISO8859-15'
    );

alter collation pg_catalog."en_AU" owner to "kim-uijin";

create collation pg_catalog."en_CA" (
    locale = 'en_CA.ISO8859-1'
    );

alter collation pg_catalog."en_CA" owner to "kim-uijin";

create collation pg_catalog."en_CA" (
    locale = 'en_CA.ISO8859-15'
    );

alter collation pg_catalog."en_CA" owner to "kim-uijin";

create collation pg_catalog."en_GB" (
    locale = 'en_GB.ISO8859-1'
    );

alter collation pg_catalog."en_GB" owner to "kim-uijin";

create collation pg_catalog."en_GB" (
    locale = 'en_GB.ISO8859-15'
    );

alter collation pg_catalog."en_GB" owner to "kim-uijin";

create collation pg_catalog."en_NZ" (
    locale = 'en_NZ.ISO8859-1'
    );

alter collation pg_catalog."en_NZ" owner to "kim-uijin";

create collation pg_catalog."en_NZ" (
    locale = 'en_NZ.ISO8859-15'
    );

alter collation pg_catalog."en_NZ" owner to "kim-uijin";

create collation pg_catalog."en_US" (
    locale = 'en_US.ISO8859-1'
    );

alter collation pg_catalog."en_US" owner to "kim-uijin";

create collation pg_catalog."en_US" (
    locale = 'en_US.ISO8859-15'
    );

alter collation pg_catalog."en_US" owner to "kim-uijin";

create collation pg_catalog."es_ES" (
    locale = 'es_ES.ISO8859-1'
    );

alter collation pg_catalog."es_ES" owner to "kim-uijin";

create collation pg_catalog."es_ES" (
    locale = 'es_ES.ISO8859-15'
    );

alter collation pg_catalog."es_ES" owner to "kim-uijin";

create collation pg_catalog."et_EE" (
    locale = 'et_EE.ISO8859-15'
    );

alter collation pg_catalog."et_EE" owner to "kim-uijin";

create collation pg_catalog."eu_ES" (
    locale = 'eu_ES.ISO8859-1'
    );

alter collation pg_catalog."eu_ES" owner to "kim-uijin";

create collation pg_catalog."eu_ES" (
    locale = 'eu_ES.ISO8859-15'
    );

alter collation pg_catalog."eu_ES" owner to "kim-uijin";

create collation pg_catalog."fi_FI" (
    locale = 'fi_FI.ISO8859-1'
    );

alter collation pg_catalog."fi_FI" owner to "kim-uijin";

create collation pg_catalog."fi_FI" (
    locale = 'fi_FI.ISO8859-15'
    );

alter collation pg_catalog."fi_FI" owner to "kim-uijin";

create collation pg_catalog."fr_BE" (
    locale = 'fr_BE.ISO8859-1'
    );

alter collation pg_catalog."fr_BE" owner to "kim-uijin";

create collation pg_catalog."fr_BE" (
    locale = 'fr_BE.ISO8859-15'
    );

alter collation pg_catalog."fr_BE" owner to "kim-uijin";

create collation pg_catalog."fr_CA" (
    locale = 'fr_CA.ISO8859-1'
    );

alter collation pg_catalog."fr_CA" owner to "kim-uijin";

create collation pg_catalog."fr_CA" (
    locale = 'fr_CA.ISO8859-15'
    );

alter collation pg_catalog."fr_CA" owner to "kim-uijin";

create collation pg_catalog."fr_CH" (
    locale = 'fr_CH.ISO8859-1'
    );

alter collation pg_catalog."fr_CH" owner to "kim-uijin";

create collation pg_catalog."fr_CH" (
    locale = 'fr_CH.ISO8859-15'
    );

alter collation pg_catalog."fr_CH" owner to "kim-uijin";

create collation pg_catalog."fr_FR" (
    locale = 'fr_FR.ISO8859-1'
    );

alter collation pg_catalog."fr_FR" owner to "kim-uijin";

create collation pg_catalog."fr_FR" (
    locale = 'fr_FR.ISO8859-15'
    );

alter collation pg_catalog."fr_FR" owner to "kim-uijin";

create collation pg_catalog."hr_HR" (
    locale = 'hr_HR.ISO8859-2'
    );

alter collation pg_catalog."hr_HR" owner to "kim-uijin";

create collation pg_catalog."hu_HU" (
    locale = 'hu_HU.ISO8859-2'
    );

alter collation pg_catalog."hu_HU" owner to "kim-uijin";

create collation pg_catalog."is_IS" (
    locale = 'is_IS.ISO8859-1'
    );

alter collation pg_catalog."is_IS" owner to "kim-uijin";

create collation pg_catalog."is_IS" (
    locale = 'is_IS.ISO8859-15'
    );

alter collation pg_catalog."is_IS" owner to "kim-uijin";

create collation pg_catalog."it_CH" (
    locale = 'it_CH.ISO8859-1'
    );

alter collation pg_catalog."it_CH" owner to "kim-uijin";

create collation pg_catalog."it_CH" (
    locale = 'it_CH.ISO8859-15'
    );

alter collation pg_catalog."it_CH" owner to "kim-uijin";

create collation pg_catalog."it_IT" (
    locale = 'it_IT.ISO8859-1'
    );

alter collation pg_catalog."it_IT" owner to "kim-uijin";

create collation pg_catalog."it_IT" (
    locale = 'it_IT.ISO8859-15'
    );

alter collation pg_catalog."it_IT" owner to "kim-uijin";

create collation pg_catalog."ja_JP" (
    locale = 'ja_JP.eucJP'
    );

alter collation pg_catalog."ja_JP" owner to "kim-uijin";

create collation pg_catalog."ko_KR" (
    locale = 'ko_KR.eucKR'
    );

alter collation pg_catalog."ko_KR" owner to "kim-uijin";

create collation pg_catalog."lt_LT" (
    locale = 'lt_LT.ISO8859-13'
    );

alter collation pg_catalog."lt_LT" owner to "kim-uijin";

create collation pg_catalog."lt_LT" (
    locale = 'lt_LT.ISO8859-4'
    );

alter collation pg_catalog."lt_LT" owner to "kim-uijin";

create collation pg_catalog."nl_BE" (
    locale = 'nl_BE.ISO8859-1'
    );

alter collation pg_catalog."nl_BE" owner to "kim-uijin";

create collation pg_catalog."nl_BE" (
    locale = 'nl_BE.ISO8859-15'
    );

alter collation pg_catalog."nl_BE" owner to "kim-uijin";

create collation pg_catalog."nl_NL" (
    locale = 'nl_NL.ISO8859-1'
    );

alter collation pg_catalog."nl_NL" owner to "kim-uijin";

create collation pg_catalog."nl_NL" (
    locale = 'nl_NL.ISO8859-15'
    );

alter collation pg_catalog."nl_NL" owner to "kim-uijin";

create collation pg_catalog."no_NO" (
    locale = 'no_NO.ISO8859-1'
    );

alter collation pg_catalog."no_NO" owner to "kim-uijin";

create collation pg_catalog."no_NO" (
    locale = 'no_NO.ISO8859-15'
    );

alter collation pg_catalog."no_NO" owner to "kim-uijin";

create collation pg_catalog."pl_PL" (
    locale = 'pl_PL.ISO8859-2'
    );

alter collation pg_catalog."pl_PL" owner to "kim-uijin";

create collation pg_catalog."pt_BR" (
    locale = 'pt_BR.ISO8859-1'
    );

alter collation pg_catalog."pt_BR" owner to "kim-uijin";

create collation pg_catalog."pt_PT" (
    locale = 'pt_PT.ISO8859-1'
    );

alter collation pg_catalog."pt_PT" owner to "kim-uijin";

create collation pg_catalog."pt_PT" (
    locale = 'pt_PT.ISO8859-15'
    );

alter collation pg_catalog."pt_PT" owner to "kim-uijin";

create collation pg_catalog."ro_RO" (
    locale = 'ro_RO.ISO8859-2'
    );

alter collation pg_catalog."ro_RO" owner to "kim-uijin";

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.CP1251'
    );

alter collation pg_catalog."ru_RU" owner to "kim-uijin";

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.CP866'
    );

alter collation pg_catalog."ru_RU" owner to "kim-uijin";

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.ISO8859-5'
    );

alter collation pg_catalog."ru_RU" owner to "kim-uijin";

create collation pg_catalog."ru_RU" (
    locale = 'ru_RU.KOI8-R'
    );

alter collation pg_catalog."ru_RU" owner to "kim-uijin";

create collation pg_catalog."sk_SK" (
    locale = 'sk_SK.ISO8859-2'
    );

alter collation pg_catalog."sk_SK" owner to "kim-uijin";

create collation pg_catalog."sl_SI" (
    locale = 'sl_SI.ISO8859-2'
    );

alter collation pg_catalog."sl_SI" owner to "kim-uijin";

create collation pg_catalog."sr_YU" (
    locale = 'sr_YU.ISO8859-2'
    );

alter collation pg_catalog."sr_YU" owner to "kim-uijin";

create collation pg_catalog."sr_YU" (
    locale = 'sr_YU.ISO8859-5'
    );

alter collation pg_catalog."sr_YU" owner to "kim-uijin";

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE.ISO8859-1'
    );

alter collation pg_catalog."sv_SE" owner to "kim-uijin";

create collation pg_catalog."sv_SE" (
    locale = 'sv_SE.ISO8859-15'
    );

alter collation pg_catalog."sv_SE" owner to "kim-uijin";

create collation pg_catalog."tr_TR" (
    locale = 'tr_TR.ISO8859-9'
    );

alter collation pg_catalog."tr_TR" owner to "kim-uijin";

create collation pg_catalog."uk_UA" (
    locale = 'uk_UA.ISO8859-5'
    );

alter collation pg_catalog."uk_UA" owner to "kim-uijin";

create collation pg_catalog."uk_UA" (
    locale = 'uk_UA.KOI8-U'
    );

alter collation pg_catalog."uk_UA" owner to "kim-uijin";

create collation pg_catalog."zh_CN" (
    locale = 'zh_CN.GB2312'
    );

alter collation pg_catalog."zh_CN" owner to "kim-uijin";

create collation pg_catalog."und-x-icu" (
    locale = 'und'
    );

comment on collation pg_catalog."und-x-icu" is 'Unknown language';

alter collation pg_catalog."und-x-icu" owner to "kim-uijin";

create collation pg_catalog."af-x-icu" (
    locale = 'af'
    );

comment on collation pg_catalog."af-x-icu" is 'Afrikaans';

alter collation pg_catalog."af-x-icu" owner to "kim-uijin";

create collation pg_catalog."af-NA-x-icu" (
    locale = 'af-NA'
    );

comment on collation pg_catalog."af-NA-x-icu" is 'Afrikaans (Namibia)';

alter collation pg_catalog."af-NA-x-icu" owner to "kim-uijin";

create collation pg_catalog."af-ZA-x-icu" (
    locale = 'af-ZA'
    );

comment on collation pg_catalog."af-ZA-x-icu" is 'Afrikaans (South Africa)';

alter collation pg_catalog."af-ZA-x-icu" owner to "kim-uijin";

create collation pg_catalog."agq-x-icu" (
    locale = 'agq'
    );

comment on collation pg_catalog."agq-x-icu" is 'Aghem';

alter collation pg_catalog."agq-x-icu" owner to "kim-uijin";

create collation pg_catalog."agq-CM-x-icu" (
    locale = 'agq-CM'
    );

comment on collation pg_catalog."agq-CM-x-icu" is 'Aghem (Cameroon)';

alter collation pg_catalog."agq-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ak-x-icu" (
    locale = 'ak'
    );

comment on collation pg_catalog."ak-x-icu" is 'Akan';

alter collation pg_catalog."ak-x-icu" owner to "kim-uijin";

create collation pg_catalog."ak-GH-x-icu" (
    locale = 'ak-GH'
    );

comment on collation pg_catalog."ak-GH-x-icu" is 'Akan (Ghana)';

alter collation pg_catalog."ak-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."am-x-icu" (
    locale = 'am'
    );

comment on collation pg_catalog."am-x-icu" is 'Amharic';

alter collation pg_catalog."am-x-icu" owner to "kim-uijin";

create collation pg_catalog."am-ET-x-icu" (
    locale = 'am-ET'
    );

comment on collation pg_catalog."am-ET-x-icu" is 'Amharic (Ethiopia)';

alter collation pg_catalog."am-ET-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-x-icu" (
    locale = 'ar'
    );

comment on collation pg_catalog."ar-x-icu" is 'Arabic';

alter collation pg_catalog."ar-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-001-x-icu" (
    locale = 'ar-001'
    );

comment on collation pg_catalog."ar-001-x-icu" is 'Arabic (world)';

alter collation pg_catalog."ar-001-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-AE-x-icu" (
    locale = 'ar-AE'
    );

comment on collation pg_catalog."ar-AE-x-icu" is 'Arabic (United Arab Emirates)';

alter collation pg_catalog."ar-AE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-BH-x-icu" (
    locale = 'ar-BH'
    );

comment on collation pg_catalog."ar-BH-x-icu" is 'Arabic (Bahrain)';

alter collation pg_catalog."ar-BH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-DJ-x-icu" (
    locale = 'ar-DJ'
    );

comment on collation pg_catalog."ar-DJ-x-icu" is 'Arabic (Djibouti)';

alter collation pg_catalog."ar-DJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-DZ-x-icu" (
    locale = 'ar-DZ'
    );

comment on collation pg_catalog."ar-DZ-x-icu" is 'Arabic (Algeria)';

alter collation pg_catalog."ar-DZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-EG-x-icu" (
    locale = 'ar-EG'
    );

comment on collation pg_catalog."ar-EG-x-icu" is 'Arabic (Egypt)';

alter collation pg_catalog."ar-EG-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-EH-x-icu" (
    locale = 'ar-EH'
    );

comment on collation pg_catalog."ar-EH-x-icu" is 'Arabic (Western Sahara)';

alter collation pg_catalog."ar-EH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-ER-x-icu" (
    locale = 'ar-ER'
    );

comment on collation pg_catalog."ar-ER-x-icu" is 'Arabic (Eritrea)';

alter collation pg_catalog."ar-ER-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-IL-x-icu" (
    locale = 'ar-IL'
    );

comment on collation pg_catalog."ar-IL-x-icu" is 'Arabic (Israel)';

alter collation pg_catalog."ar-IL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-IQ-x-icu" (
    locale = 'ar-IQ'
    );

comment on collation pg_catalog."ar-IQ-x-icu" is 'Arabic (Iraq)';

alter collation pg_catalog."ar-IQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-JO-x-icu" (
    locale = 'ar-JO'
    );

comment on collation pg_catalog."ar-JO-x-icu" is 'Arabic (Jordan)';

alter collation pg_catalog."ar-JO-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-KM-x-icu" (
    locale = 'ar-KM'
    );

comment on collation pg_catalog."ar-KM-x-icu" is 'Arabic (Comoros)';

alter collation pg_catalog."ar-KM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-KW-x-icu" (
    locale = 'ar-KW'
    );

comment on collation pg_catalog."ar-KW-x-icu" is 'Arabic (Kuwait)';

alter collation pg_catalog."ar-KW-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-LB-x-icu" (
    locale = 'ar-LB'
    );

comment on collation pg_catalog."ar-LB-x-icu" is 'Arabic (Lebanon)';

alter collation pg_catalog."ar-LB-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-LY-x-icu" (
    locale = 'ar-LY'
    );

comment on collation pg_catalog."ar-LY-x-icu" is 'Arabic (Libya)';

alter collation pg_catalog."ar-LY-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-MA-x-icu" (
    locale = 'ar-MA'
    );

comment on collation pg_catalog."ar-MA-x-icu" is 'Arabic (Morocco)';

alter collation pg_catalog."ar-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-MR-x-icu" (
    locale = 'ar-MR'
    );

comment on collation pg_catalog."ar-MR-x-icu" is 'Arabic (Mauritania)';

alter collation pg_catalog."ar-MR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-OM-x-icu" (
    locale = 'ar-OM'
    );

comment on collation pg_catalog."ar-OM-x-icu" is 'Arabic (Oman)';

alter collation pg_catalog."ar-OM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-PS-x-icu" (
    locale = 'ar-PS'
    );

comment on collation pg_catalog."ar-PS-x-icu" is 'Arabic (Palestinian Territories)';

alter collation pg_catalog."ar-PS-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-QA-x-icu" (
    locale = 'ar-QA'
    );

comment on collation pg_catalog."ar-QA-x-icu" is 'Arabic (Qatar)';

alter collation pg_catalog."ar-QA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-SA-x-icu" (
    locale = 'ar-SA'
    );

comment on collation pg_catalog."ar-SA-x-icu" is 'Arabic (Saudi Arabia)';

alter collation pg_catalog."ar-SA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-SD-x-icu" (
    locale = 'ar-SD'
    );

comment on collation pg_catalog."ar-SD-x-icu" is 'Arabic (Sudan)';

alter collation pg_catalog."ar-SD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-SO-x-icu" (
    locale = 'ar-SO'
    );

comment on collation pg_catalog."ar-SO-x-icu" is 'Arabic (Somalia)';

alter collation pg_catalog."ar-SO-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-SS-x-icu" (
    locale = 'ar-SS'
    );

comment on collation pg_catalog."ar-SS-x-icu" is 'Arabic (South Sudan)';

alter collation pg_catalog."ar-SS-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-SY-x-icu" (
    locale = 'ar-SY'
    );

comment on collation pg_catalog."ar-SY-x-icu" is 'Arabic (Syria)';

alter collation pg_catalog."ar-SY-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-TD-x-icu" (
    locale = 'ar-TD'
    );

comment on collation pg_catalog."ar-TD-x-icu" is 'Arabic (Chad)';

alter collation pg_catalog."ar-TD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-TN-x-icu" (
    locale = 'ar-TN'
    );

comment on collation pg_catalog."ar-TN-x-icu" is 'Arabic (Tunisia)';

alter collation pg_catalog."ar-TN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ar-YE-x-icu" (
    locale = 'ar-YE'
    );

comment on collation pg_catalog."ar-YE-x-icu" is 'Arabic (Yemen)';

alter collation pg_catalog."ar-YE-x-icu" owner to "kim-uijin";

create collation pg_catalog."as-x-icu" (
    locale = 'as'
    );

comment on collation pg_catalog."as-x-icu" is 'Assamese';

alter collation pg_catalog."as-x-icu" owner to "kim-uijin";

create collation pg_catalog."as-IN-x-icu" (
    locale = 'as-IN'
    );

comment on collation pg_catalog."as-IN-x-icu" is 'Assamese (India)';

alter collation pg_catalog."as-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."asa-x-icu" (
    locale = 'asa'
    );

comment on collation pg_catalog."asa-x-icu" is 'Asu';

alter collation pg_catalog."asa-x-icu" owner to "kim-uijin";

create collation pg_catalog."asa-TZ-x-icu" (
    locale = 'asa-TZ'
    );

comment on collation pg_catalog."asa-TZ-x-icu" is 'Asu (Tanzania)';

alter collation pg_catalog."asa-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ast-x-icu" (
    locale = 'ast'
    );

comment on collation pg_catalog."ast-x-icu" is 'Asturian';

alter collation pg_catalog."ast-x-icu" owner to "kim-uijin";

create collation pg_catalog."ast-ES-x-icu" (
    locale = 'ast-ES'
    );

comment on collation pg_catalog."ast-ES-x-icu" is 'Asturian (Spain)';

alter collation pg_catalog."ast-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."az-x-icu" (
    locale = 'az'
    );

comment on collation pg_catalog."az-x-icu" is 'Azerbaijani';

alter collation pg_catalog."az-x-icu" owner to "kim-uijin";

create collation pg_catalog."az-Cyrl-x-icu" (
    locale = 'az-Cyrl'
    );

comment on collation pg_catalog."az-Cyrl-x-icu" is 'Azerbaijani (Cyrillic)';

alter collation pg_catalog."az-Cyrl-x-icu" owner to "kim-uijin";

create collation pg_catalog."az-Cyrl-AZ-x-icu" (
    locale = 'az-Cyrl-AZ'
    );

comment on collation pg_catalog."az-Cyrl-AZ-x-icu" is 'Azerbaijani (Cyrillic, Azerbaijan)';

alter collation pg_catalog."az-Cyrl-AZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."az-Latn-x-icu" (
    locale = 'az-Latn'
    );

comment on collation pg_catalog."az-Latn-x-icu" is 'Azerbaijani (Latin)';

alter collation pg_catalog."az-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."az-Latn-AZ-x-icu" (
    locale = 'az-Latn-AZ'
    );

comment on collation pg_catalog."az-Latn-AZ-x-icu" is 'Azerbaijani (Latin, Azerbaijan)';

alter collation pg_catalog."az-Latn-AZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."bas-x-icu" (
    locale = 'bas'
    );

comment on collation pg_catalog."bas-x-icu" is 'Basaa';

alter collation pg_catalog."bas-x-icu" owner to "kim-uijin";

create collation pg_catalog."bas-CM-x-icu" (
    locale = 'bas-CM'
    );

comment on collation pg_catalog."bas-CM-x-icu" is 'Basaa (Cameroon)';

alter collation pg_catalog."bas-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."be-x-icu" (
    locale = 'be'
    );

comment on collation pg_catalog."be-x-icu" is 'Belarusian';

alter collation pg_catalog."be-x-icu" owner to "kim-uijin";

create collation pg_catalog."be-BY-x-icu" (
    locale = 'be-BY'
    );

comment on collation pg_catalog."be-BY-x-icu" is 'Belarusian (Belarus)';

alter collation pg_catalog."be-BY-x-icu" owner to "kim-uijin";

create collation pg_catalog."bem-x-icu" (
    locale = 'bem'
    );

comment on collation pg_catalog."bem-x-icu" is 'Bemba';

alter collation pg_catalog."bem-x-icu" owner to "kim-uijin";

create collation pg_catalog."bem-ZM-x-icu" (
    locale = 'bem-ZM'
    );

comment on collation pg_catalog."bem-ZM-x-icu" is 'Bemba (Zambia)';

alter collation pg_catalog."bem-ZM-x-icu" owner to "kim-uijin";

create collation pg_catalog."bez-x-icu" (
    locale = 'bez'
    );

comment on collation pg_catalog."bez-x-icu" is 'Bena';

alter collation pg_catalog."bez-x-icu" owner to "kim-uijin";

create collation pg_catalog."bez-TZ-x-icu" (
    locale = 'bez-TZ'
    );

comment on collation pg_catalog."bez-TZ-x-icu" is 'Bena (Tanzania)';

alter collation pg_catalog."bez-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."bg-x-icu" (
    locale = 'bg'
    );

comment on collation pg_catalog."bg-x-icu" is 'Bulgarian';

alter collation pg_catalog."bg-x-icu" owner to "kim-uijin";

create collation pg_catalog."bg-BG-x-icu" (
    locale = 'bg-BG'
    );

comment on collation pg_catalog."bg-BG-x-icu" is 'Bulgarian (Bulgaria)';

alter collation pg_catalog."bg-BG-x-icu" owner to "kim-uijin";

create collation pg_catalog."bgc-x-icu" (
    locale = 'bgc'
    );

comment on collation pg_catalog."bgc-x-icu" is 'Haryanvi';

alter collation pg_catalog."bgc-x-icu" owner to "kim-uijin";

create collation pg_catalog."bgc-IN-x-icu" (
    locale = 'bgc-IN'
    );

comment on collation pg_catalog."bgc-IN-x-icu" is 'Haryanvi (India)';

alter collation pg_catalog."bgc-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."bho-x-icu" (
    locale = 'bho'
    );

comment on collation pg_catalog."bho-x-icu" is 'Bhojpuri';

alter collation pg_catalog."bho-x-icu" owner to "kim-uijin";

create collation pg_catalog."bho-IN-x-icu" (
    locale = 'bho-IN'
    );

comment on collation pg_catalog."bho-IN-x-icu" is 'Bhojpuri (India)';

alter collation pg_catalog."bho-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."blo-x-icu" (
    locale = 'blo'
    );

comment on collation pg_catalog."blo-x-icu" is 'Anii';

alter collation pg_catalog."blo-x-icu" owner to "kim-uijin";

create collation pg_catalog."blo-BJ-x-icu" (
    locale = 'blo-BJ'
    );

comment on collation pg_catalog."blo-BJ-x-icu" is 'Anii (Benin)';

alter collation pg_catalog."blo-BJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."bm-x-icu" (
    locale = 'bm'
    );

comment on collation pg_catalog."bm-x-icu" is 'Bambara';

alter collation pg_catalog."bm-x-icu" owner to "kim-uijin";

create collation pg_catalog."bm-ML-x-icu" (
    locale = 'bm-ML'
    );

comment on collation pg_catalog."bm-ML-x-icu" is 'Bambara (Mali)';

alter collation pg_catalog."bm-ML-x-icu" owner to "kim-uijin";

create collation pg_catalog."bn-x-icu" (
    locale = 'bn'
    );

comment on collation pg_catalog."bn-x-icu" is 'Bangla';

alter collation pg_catalog."bn-x-icu" owner to "kim-uijin";

create collation pg_catalog."bn-BD-x-icu" (
    locale = 'bn-BD'
    );

comment on collation pg_catalog."bn-BD-x-icu" is 'Bangla (Bangladesh)';

alter collation pg_catalog."bn-BD-x-icu" owner to "kim-uijin";

create collation pg_catalog."bn-IN-x-icu" (
    locale = 'bn-IN'
    );

comment on collation pg_catalog."bn-IN-x-icu" is 'Bangla (India)';

alter collation pg_catalog."bn-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."bo-x-icu" (
    locale = 'bo'
    );

comment on collation pg_catalog."bo-x-icu" is 'Tibetan';

alter collation pg_catalog."bo-x-icu" owner to "kim-uijin";

create collation pg_catalog."bo-CN-x-icu" (
    locale = 'bo-CN'
    );

comment on collation pg_catalog."bo-CN-x-icu" is 'Tibetan (China)';

alter collation pg_catalog."bo-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."bo-IN-x-icu" (
    locale = 'bo-IN'
    );

comment on collation pg_catalog."bo-IN-x-icu" is 'Tibetan (India)';

alter collation pg_catalog."bo-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."br-x-icu" (
    locale = 'br'
    );

comment on collation pg_catalog."br-x-icu" is 'Breton';

alter collation pg_catalog."br-x-icu" owner to "kim-uijin";

create collation pg_catalog."br-FR-x-icu" (
    locale = 'br-FR'
    );

comment on collation pg_catalog."br-FR-x-icu" is 'Breton (France)';

alter collation pg_catalog."br-FR-x-icu" owner to "kim-uijin";

create collation pg_catalog."brx-x-icu" (
    locale = 'brx'
    );

comment on collation pg_catalog."brx-x-icu" is 'Bodo';

alter collation pg_catalog."brx-x-icu" owner to "kim-uijin";

create collation pg_catalog."brx-IN-x-icu" (
    locale = 'brx-IN'
    );

comment on collation pg_catalog."brx-IN-x-icu" is 'Bodo (India)';

alter collation pg_catalog."brx-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."bs-x-icu" (
    locale = 'bs'
    );

comment on collation pg_catalog."bs-x-icu" is 'Bosnian';

alter collation pg_catalog."bs-x-icu" owner to "kim-uijin";

create collation pg_catalog."bs-Cyrl-x-icu" (
    locale = 'bs-Cyrl'
    );

comment on collation pg_catalog."bs-Cyrl-x-icu" is 'Bosnian (Cyrillic)';

alter collation pg_catalog."bs-Cyrl-x-icu" owner to "kim-uijin";

create collation pg_catalog."bs-Cyrl-BA-x-icu" (
    locale = 'bs-Cyrl-BA'
    );

comment on collation pg_catalog."bs-Cyrl-BA-x-icu" is 'Bosnian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Cyrl-BA-x-icu" owner to "kim-uijin";

create collation pg_catalog."bs-Latn-x-icu" (
    locale = 'bs-Latn'
    );

comment on collation pg_catalog."bs-Latn-x-icu" is 'Bosnian (Latin)';

alter collation pg_catalog."bs-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."bs-Latn-BA-x-icu" (
    locale = 'bs-Latn-BA'
    );

comment on collation pg_catalog."bs-Latn-BA-x-icu" is 'Bosnian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."bs-Latn-BA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ca-x-icu" (
    locale = 'ca'
    );

comment on collation pg_catalog."ca-x-icu" is 'Catalan';

alter collation pg_catalog."ca-x-icu" owner to "kim-uijin";

create collation pg_catalog."ca-AD-x-icu" (
    locale = 'ca-AD'
    );

comment on collation pg_catalog."ca-AD-x-icu" is 'Catalan (Andorra)';

alter collation pg_catalog."ca-AD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ca-ES-x-icu" (
    locale = 'ca-ES'
    );

comment on collation pg_catalog."ca-ES-x-icu" is 'Catalan (Spain)';

alter collation pg_catalog."ca-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."ca-FR-x-icu" (
    locale = 'ca-FR'
    );

comment on collation pg_catalog."ca-FR-x-icu" is 'Catalan (France)';

alter collation pg_catalog."ca-FR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ca-IT-x-icu" (
    locale = 'ca-IT'
    );

comment on collation pg_catalog."ca-IT-x-icu" is 'Catalan (Italy)';

alter collation pg_catalog."ca-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."ccp-x-icu" (
    locale = 'ccp'
    );

comment on collation pg_catalog."ccp-x-icu" is 'Chakma';

alter collation pg_catalog."ccp-x-icu" owner to "kim-uijin";

create collation pg_catalog."ccp-BD-x-icu" (
    locale = 'ccp-BD'
    );

comment on collation pg_catalog."ccp-BD-x-icu" is 'Chakma (Bangladesh)';

alter collation pg_catalog."ccp-BD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ccp-IN-x-icu" (
    locale = 'ccp-IN'
    );

comment on collation pg_catalog."ccp-IN-x-icu" is 'Chakma (India)';

alter collation pg_catalog."ccp-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ce-x-icu" (
    locale = 'ce'
    );

comment on collation pg_catalog."ce-x-icu" is 'Chechen';

alter collation pg_catalog."ce-x-icu" owner to "kim-uijin";

create collation pg_catalog."ce-RU-x-icu" (
    locale = 'ce-RU'
    );

comment on collation pg_catalog."ce-RU-x-icu" is 'Chechen (Russia)';

alter collation pg_catalog."ce-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."ceb-x-icu" (
    locale = 'ceb'
    );

comment on collation pg_catalog."ceb-x-icu" is 'Cebuano';

alter collation pg_catalog."ceb-x-icu" owner to "kim-uijin";

create collation pg_catalog."ceb-PH-x-icu" (
    locale = 'ceb-PH'
    );

comment on collation pg_catalog."ceb-PH-x-icu" is 'Cebuano (Philippines)';

alter collation pg_catalog."ceb-PH-x-icu" owner to "kim-uijin";

create collation pg_catalog."cgg-x-icu" (
    locale = 'cgg'
    );

comment on collation pg_catalog."cgg-x-icu" is 'Chiga';

alter collation pg_catalog."cgg-x-icu" owner to "kim-uijin";

create collation pg_catalog."cgg-UG-x-icu" (
    locale = 'cgg-UG'
    );

comment on collation pg_catalog."cgg-UG-x-icu" is 'Chiga (Uganda)';

alter collation pg_catalog."cgg-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."chr-x-icu" (
    locale = 'chr'
    );

comment on collation pg_catalog."chr-x-icu" is 'Cherokee';

alter collation pg_catalog."chr-x-icu" owner to "kim-uijin";

create collation pg_catalog."chr-US-x-icu" (
    locale = 'chr-US'
    );

comment on collation pg_catalog."chr-US-x-icu" is 'Cherokee (United States)';

alter collation pg_catalog."chr-US-x-icu" owner to "kim-uijin";

create collation pg_catalog."ckb-x-icu" (
    locale = 'ckb'
    );

comment on collation pg_catalog."ckb-x-icu" is 'Central Kurdish';

alter collation pg_catalog."ckb-x-icu" owner to "kim-uijin";

create collation pg_catalog."ckb-IQ-x-icu" (
    locale = 'ckb-IQ'
    );

comment on collation pg_catalog."ckb-IQ-x-icu" is 'Central Kurdish (Iraq)';

alter collation pg_catalog."ckb-IQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ckb-IR-x-icu" (
    locale = 'ckb-IR'
    );

comment on collation pg_catalog."ckb-IR-x-icu" is 'Central Kurdish (Iran)';

alter collation pg_catalog."ckb-IR-x-icu" owner to "kim-uijin";

create collation pg_catalog."cs-x-icu" (
    locale = 'cs'
    );

comment on collation pg_catalog."cs-x-icu" is 'Czech';

alter collation pg_catalog."cs-x-icu" owner to "kim-uijin";

create collation pg_catalog."cs-CZ-x-icu" (
    locale = 'cs-CZ'
    );

comment on collation pg_catalog."cs-CZ-x-icu" is 'Czech (Czechia)';

alter collation pg_catalog."cs-CZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."csw-x-icu" (
    locale = 'csw'
    );

comment on collation pg_catalog."csw-x-icu" is 'Swampy Cree';

alter collation pg_catalog."csw-x-icu" owner to "kim-uijin";

create collation pg_catalog."csw-CA-x-icu" (
    locale = 'csw-CA'
    );

comment on collation pg_catalog."csw-CA-x-icu" is 'Swampy Cree (Canada)';

alter collation pg_catalog."csw-CA-x-icu" owner to "kim-uijin";

create collation pg_catalog."cv-x-icu" (
    locale = 'cv'
    );

comment on collation pg_catalog."cv-x-icu" is 'Chuvash';

alter collation pg_catalog."cv-x-icu" owner to "kim-uijin";

create collation pg_catalog."cv-RU-x-icu" (
    locale = 'cv-RU'
    );

comment on collation pg_catalog."cv-RU-x-icu" is 'Chuvash (Russia)';

alter collation pg_catalog."cv-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."cy-x-icu" (
    locale = 'cy'
    );

comment on collation pg_catalog."cy-x-icu" is 'Welsh';

alter collation pg_catalog."cy-x-icu" owner to "kim-uijin";

create collation pg_catalog."cy-GB-x-icu" (
    locale = 'cy-GB'
    );

comment on collation pg_catalog."cy-GB-x-icu" is 'Welsh (United Kingdom)';

alter collation pg_catalog."cy-GB-x-icu" owner to "kim-uijin";

create collation pg_catalog."da-x-icu" (
    locale = 'da'
    );

comment on collation pg_catalog."da-x-icu" is 'Danish';

alter collation pg_catalog."da-x-icu" owner to "kim-uijin";

create collation pg_catalog."da-DK-x-icu" (
    locale = 'da-DK'
    );

comment on collation pg_catalog."da-DK-x-icu" is 'Danish (Denmark)';

alter collation pg_catalog."da-DK-x-icu" owner to "kim-uijin";

create collation pg_catalog."da-GL-x-icu" (
    locale = 'da-GL'
    );

comment on collation pg_catalog."da-GL-x-icu" is 'Danish (Greenland)';

alter collation pg_catalog."da-GL-x-icu" owner to "kim-uijin";

create collation pg_catalog."dav-x-icu" (
    locale = 'dav'
    );

comment on collation pg_catalog."dav-x-icu" is 'Taita';

alter collation pg_catalog."dav-x-icu" owner to "kim-uijin";

create collation pg_catalog."dav-KE-x-icu" (
    locale = 'dav-KE'
    );

comment on collation pg_catalog."dav-KE-x-icu" is 'Taita (Kenya)';

alter collation pg_catalog."dav-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-x-icu" (
    locale = 'de'
    );

comment on collation pg_catalog."de-x-icu" is 'German';

alter collation pg_catalog."de-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-AT-x-icu" (
    locale = 'de-AT'
    );

comment on collation pg_catalog."de-AT-x-icu" is 'German (Austria)';

alter collation pg_catalog."de-AT-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-BE-x-icu" (
    locale = 'de-BE'
    );

comment on collation pg_catalog."de-BE-x-icu" is 'German (Belgium)';

alter collation pg_catalog."de-BE-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-CH-x-icu" (
    locale = 'de-CH'
    );

comment on collation pg_catalog."de-CH-x-icu" is 'German (Switzerland)';

alter collation pg_catalog."de-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-DE-x-icu" (
    locale = 'de-DE'
    );

comment on collation pg_catalog."de-DE-x-icu" is 'German (Germany)';

alter collation pg_catalog."de-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-IT-x-icu" (
    locale = 'de-IT'
    );

comment on collation pg_catalog."de-IT-x-icu" is 'German (Italy)';

alter collation pg_catalog."de-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-LI-x-icu" (
    locale = 'de-LI'
    );

comment on collation pg_catalog."de-LI-x-icu" is 'German (Liechtenstein)';

alter collation pg_catalog."de-LI-x-icu" owner to "kim-uijin";

create collation pg_catalog."de-LU-x-icu" (
    locale = 'de-LU'
    );

comment on collation pg_catalog."de-LU-x-icu" is 'German (Luxembourg)';

alter collation pg_catalog."de-LU-x-icu" owner to "kim-uijin";

create collation pg_catalog."dje-x-icu" (
    locale = 'dje'
    );

comment on collation pg_catalog."dje-x-icu" is 'Zarma';

alter collation pg_catalog."dje-x-icu" owner to "kim-uijin";

create collation pg_catalog."dje-NE-x-icu" (
    locale = 'dje-NE'
    );

comment on collation pg_catalog."dje-NE-x-icu" is 'Zarma (Niger)';

alter collation pg_catalog."dje-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."doi-x-icu" (
    locale = 'doi'
    );

comment on collation pg_catalog."doi-x-icu" is 'Dogri';

alter collation pg_catalog."doi-x-icu" owner to "kim-uijin";

create collation pg_catalog."doi-IN-x-icu" (
    locale = 'doi-IN'
    );

comment on collation pg_catalog."doi-IN-x-icu" is 'Dogri (India)';

alter collation pg_catalog."doi-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."dsb-x-icu" (
    locale = 'dsb'
    );

comment on collation pg_catalog."dsb-x-icu" is 'Lower Sorbian';

alter collation pg_catalog."dsb-x-icu" owner to "kim-uijin";

create collation pg_catalog."dsb-DE-x-icu" (
    locale = 'dsb-DE'
    );

comment on collation pg_catalog."dsb-DE-x-icu" is 'Lower Sorbian (Germany)';

alter collation pg_catalog."dsb-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."dua-x-icu" (
    locale = 'dua'
    );

comment on collation pg_catalog."dua-x-icu" is 'Duala';

alter collation pg_catalog."dua-x-icu" owner to "kim-uijin";

create collation pg_catalog."dua-CM-x-icu" (
    locale = 'dua-CM'
    );

comment on collation pg_catalog."dua-CM-x-icu" is 'Duala (Cameroon)';

alter collation pg_catalog."dua-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."dyo-x-icu" (
    locale = 'dyo'
    );

comment on collation pg_catalog."dyo-x-icu" is 'Jola-Fonyi';

alter collation pg_catalog."dyo-x-icu" owner to "kim-uijin";

create collation pg_catalog."dyo-SN-x-icu" (
    locale = 'dyo-SN'
    );

comment on collation pg_catalog."dyo-SN-x-icu" is 'Jola-Fonyi (Senegal)';

alter collation pg_catalog."dyo-SN-x-icu" owner to "kim-uijin";

create collation pg_catalog."dz-x-icu" (
    locale = 'dz'
    );

comment on collation pg_catalog."dz-x-icu" is 'Dzongkha';

alter collation pg_catalog."dz-x-icu" owner to "kim-uijin";

create collation pg_catalog."dz-BT-x-icu" (
    locale = 'dz-BT'
    );

comment on collation pg_catalog."dz-BT-x-icu" is 'Dzongkha (Bhutan)';

alter collation pg_catalog."dz-BT-x-icu" owner to "kim-uijin";

create collation pg_catalog."ebu-x-icu" (
    locale = 'ebu'
    );

comment on collation pg_catalog."ebu-x-icu" is 'Embu';

alter collation pg_catalog."ebu-x-icu" owner to "kim-uijin";

create collation pg_catalog."ebu-KE-x-icu" (
    locale = 'ebu-KE'
    );

comment on collation pg_catalog."ebu-KE-x-icu" is 'Embu (Kenya)';

alter collation pg_catalog."ebu-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ee-x-icu" (
    locale = 'ee'
    );

comment on collation pg_catalog."ee-x-icu" is 'Ewe';

alter collation pg_catalog."ee-x-icu" owner to "kim-uijin";

create collation pg_catalog."ee-GH-x-icu" (
    locale = 'ee-GH'
    );

comment on collation pg_catalog."ee-GH-x-icu" is 'Ewe (Ghana)';

alter collation pg_catalog."ee-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ee-TG-x-icu" (
    locale = 'ee-TG'
    );

comment on collation pg_catalog."ee-TG-x-icu" is 'Ewe (Togo)';

alter collation pg_catalog."ee-TG-x-icu" owner to "kim-uijin";

create collation pg_catalog."el-x-icu" (
    locale = 'el'
    );

comment on collation pg_catalog."el-x-icu" is 'Greek';

alter collation pg_catalog."el-x-icu" owner to "kim-uijin";

create collation pg_catalog."el-CY-x-icu" (
    locale = 'el-CY'
    );

comment on collation pg_catalog."el-CY-x-icu" is 'Greek (Cyprus)';

alter collation pg_catalog."el-CY-x-icu" owner to "kim-uijin";

create collation pg_catalog."el-GR-x-icu" (
    locale = 'el-GR'
    );

comment on collation pg_catalog."el-GR-x-icu" is 'Greek (Greece)';

alter collation pg_catalog."el-GR-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-x-icu" (
    locale = 'en'
    );

comment on collation pg_catalog."en-x-icu" is 'English';

alter collation pg_catalog."en-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-001-x-icu" (
    locale = 'en-001'
    );

comment on collation pg_catalog."en-001-x-icu" is 'English (world)';

alter collation pg_catalog."en-001-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-150-x-icu" (
    locale = 'en-150'
    );

comment on collation pg_catalog."en-150-x-icu" is 'English (Europe)';

alter collation pg_catalog."en-150-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AE-x-icu" (
    locale = 'en-AE'
    );

comment on collation pg_catalog."en-AE-x-icu" is 'English (United Arab Emirates)';

alter collation pg_catalog."en-AE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AG-x-icu" (
    locale = 'en-AG'
    );

comment on collation pg_catalog."en-AG-x-icu" is 'English (Antigua & Barbuda)';

alter collation pg_catalog."en-AG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AI-x-icu" (
    locale = 'en-AI'
    );

comment on collation pg_catalog."en-AI-x-icu" is 'English (Anguilla)';

alter collation pg_catalog."en-AI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AS-x-icu" (
    locale = 'en-AS'
    );

comment on collation pg_catalog."en-AS-x-icu" is 'English (American Samoa)';

alter collation pg_catalog."en-AS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AT-x-icu" (
    locale = 'en-AT'
    );

comment on collation pg_catalog."en-AT-x-icu" is 'English (Austria)';

alter collation pg_catalog."en-AT-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-AU-x-icu" (
    locale = 'en-AU'
    );

comment on collation pg_catalog."en-AU-x-icu" is 'English (Australia)';

alter collation pg_catalog."en-AU-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BB-x-icu" (
    locale = 'en-BB'
    );

comment on collation pg_catalog."en-BB-x-icu" is 'English (Barbados)';

alter collation pg_catalog."en-BB-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BE-x-icu" (
    locale = 'en-BE'
    );

comment on collation pg_catalog."en-BE-x-icu" is 'English (Belgium)';

alter collation pg_catalog."en-BE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BI-x-icu" (
    locale = 'en-BI'
    );

comment on collation pg_catalog."en-BI-x-icu" is 'English (Burundi)';

alter collation pg_catalog."en-BI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BM-x-icu" (
    locale = 'en-BM'
    );

comment on collation pg_catalog."en-BM-x-icu" is 'English (Bermuda)';

alter collation pg_catalog."en-BM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BS-x-icu" (
    locale = 'en-BS'
    );

comment on collation pg_catalog."en-BS-x-icu" is 'English (Bahamas)';

alter collation pg_catalog."en-BS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BW-x-icu" (
    locale = 'en-BW'
    );

comment on collation pg_catalog."en-BW-x-icu" is 'English (Botswana)';

alter collation pg_catalog."en-BW-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-BZ-x-icu" (
    locale = 'en-BZ'
    );

comment on collation pg_catalog."en-BZ-x-icu" is 'English (Belize)';

alter collation pg_catalog."en-BZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CA-x-icu" (
    locale = 'en-CA'
    );

comment on collation pg_catalog."en-CA-x-icu" is 'English (Canada)';

alter collation pg_catalog."en-CA-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CC-x-icu" (
    locale = 'en-CC'
    );

comment on collation pg_catalog."en-CC-x-icu" is 'English (Cocos [Keeling] Islands)';

alter collation pg_catalog."en-CC-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CH-x-icu" (
    locale = 'en-CH'
    );

comment on collation pg_catalog."en-CH-x-icu" is 'English (Switzerland)';

alter collation pg_catalog."en-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CK-x-icu" (
    locale = 'en-CK'
    );

comment on collation pg_catalog."en-CK-x-icu" is 'English (Cook Islands)';

alter collation pg_catalog."en-CK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CM-x-icu" (
    locale = 'en-CM'
    );

comment on collation pg_catalog."en-CM-x-icu" is 'English (Cameroon)';

alter collation pg_catalog."en-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CX-x-icu" (
    locale = 'en-CX'
    );

comment on collation pg_catalog."en-CX-x-icu" is 'English (Christmas Island)';

alter collation pg_catalog."en-CX-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-CY-x-icu" (
    locale = 'en-CY'
    );

comment on collation pg_catalog."en-CY-x-icu" is 'English (Cyprus)';

alter collation pg_catalog."en-CY-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-DE-x-icu" (
    locale = 'en-DE'
    );

comment on collation pg_catalog."en-DE-x-icu" is 'English (Germany)';

alter collation pg_catalog."en-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-DG-x-icu" (
    locale = 'en-DG'
    );

comment on collation pg_catalog."en-DG-x-icu" is 'English (Diego Garcia)';

alter collation pg_catalog."en-DG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-DK-x-icu" (
    locale = 'en-DK'
    );

comment on collation pg_catalog."en-DK-x-icu" is 'English (Denmark)';

alter collation pg_catalog."en-DK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-DM-x-icu" (
    locale = 'en-DM'
    );

comment on collation pg_catalog."en-DM-x-icu" is 'English (Dominica)';

alter collation pg_catalog."en-DM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-ER-x-icu" (
    locale = 'en-ER'
    );

comment on collation pg_catalog."en-ER-x-icu" is 'English (Eritrea)';

alter collation pg_catalog."en-ER-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-FI-x-icu" (
    locale = 'en-FI'
    );

comment on collation pg_catalog."en-FI-x-icu" is 'English (Finland)';

alter collation pg_catalog."en-FI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-FJ-x-icu" (
    locale = 'en-FJ'
    );

comment on collation pg_catalog."en-FJ-x-icu" is 'English (Fiji)';

alter collation pg_catalog."en-FJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-FK-x-icu" (
    locale = 'en-FK'
    );

comment on collation pg_catalog."en-FK-x-icu" is 'English (Falkland Islands)';

alter collation pg_catalog."en-FK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-FM-x-icu" (
    locale = 'en-FM'
    );

comment on collation pg_catalog."en-FM-x-icu" is 'English (Micronesia)';

alter collation pg_catalog."en-FM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GB-x-icu" (
    locale = 'en-GB'
    );

comment on collation pg_catalog."en-GB-x-icu" is 'English (United Kingdom)';

alter collation pg_catalog."en-GB-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GD-x-icu" (
    locale = 'en-GD'
    );

comment on collation pg_catalog."en-GD-x-icu" is 'English (Grenada)';

alter collation pg_catalog."en-GD-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GG-x-icu" (
    locale = 'en-GG'
    );

comment on collation pg_catalog."en-GG-x-icu" is 'English (Guernsey)';

alter collation pg_catalog."en-GG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GH-x-icu" (
    locale = 'en-GH'
    );

comment on collation pg_catalog."en-GH-x-icu" is 'English (Ghana)';

alter collation pg_catalog."en-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GI-x-icu" (
    locale = 'en-GI'
    );

comment on collation pg_catalog."en-GI-x-icu" is 'English (Gibraltar)';

alter collation pg_catalog."en-GI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GM-x-icu" (
    locale = 'en-GM'
    );

comment on collation pg_catalog."en-GM-x-icu" is 'English (Gambia)';

alter collation pg_catalog."en-GM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GU-x-icu" (
    locale = 'en-GU'
    );

comment on collation pg_catalog."en-GU-x-icu" is 'English (Guam)';

alter collation pg_catalog."en-GU-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-GY-x-icu" (
    locale = 'en-GY'
    );

comment on collation pg_catalog."en-GY-x-icu" is 'English (Guyana)';

alter collation pg_catalog."en-GY-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-HK-x-icu" (
    locale = 'en-HK'
    );

comment on collation pg_catalog."en-HK-x-icu" is 'English (Hong Kong SAR China)';

alter collation pg_catalog."en-HK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-ID-x-icu" (
    locale = 'en-ID'
    );

comment on collation pg_catalog."en-ID-x-icu" is 'English (Indonesia)';

alter collation pg_catalog."en-ID-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-IE-x-icu" (
    locale = 'en-IE'
    );

comment on collation pg_catalog."en-IE-x-icu" is 'English (Ireland)';

alter collation pg_catalog."en-IE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-IL-x-icu" (
    locale = 'en-IL'
    );

comment on collation pg_catalog."en-IL-x-icu" is 'English (Israel)';

alter collation pg_catalog."en-IL-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-IM-x-icu" (
    locale = 'en-IM'
    );

comment on collation pg_catalog."en-IM-x-icu" is 'English (Isle of Man)';

alter collation pg_catalog."en-IM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-IN-x-icu" (
    locale = 'en-IN'
    );

comment on collation pg_catalog."en-IN-x-icu" is 'English (India)';

alter collation pg_catalog."en-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-IO-x-icu" (
    locale = 'en-IO'
    );

comment on collation pg_catalog."en-IO-x-icu" is 'English (British Indian Ocean Territory)';

alter collation pg_catalog."en-IO-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-JE-x-icu" (
    locale = 'en-JE'
    );

comment on collation pg_catalog."en-JE-x-icu" is 'English (Jersey)';

alter collation pg_catalog."en-JE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-JM-x-icu" (
    locale = 'en-JM'
    );

comment on collation pg_catalog."en-JM-x-icu" is 'English (Jamaica)';

alter collation pg_catalog."en-JM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-KE-x-icu" (
    locale = 'en-KE'
    );

comment on collation pg_catalog."en-KE-x-icu" is 'English (Kenya)';

alter collation pg_catalog."en-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-KI-x-icu" (
    locale = 'en-KI'
    );

comment on collation pg_catalog."en-KI-x-icu" is 'English (Kiribati)';

alter collation pg_catalog."en-KI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-KN-x-icu" (
    locale = 'en-KN'
    );

comment on collation pg_catalog."en-KN-x-icu" is 'English (St. Kitts & Nevis)';

alter collation pg_catalog."en-KN-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-KY-x-icu" (
    locale = 'en-KY'
    );

comment on collation pg_catalog."en-KY-x-icu" is 'English (Cayman Islands)';

alter collation pg_catalog."en-KY-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-LC-x-icu" (
    locale = 'en-LC'
    );

comment on collation pg_catalog."en-LC-x-icu" is 'English (St. Lucia)';

alter collation pg_catalog."en-LC-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-LR-x-icu" (
    locale = 'en-LR'
    );

comment on collation pg_catalog."en-LR-x-icu" is 'English (Liberia)';

alter collation pg_catalog."en-LR-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-LS-x-icu" (
    locale = 'en-LS'
    );

comment on collation pg_catalog."en-LS-x-icu" is 'English (Lesotho)';

alter collation pg_catalog."en-LS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MG-x-icu" (
    locale = 'en-MG'
    );

comment on collation pg_catalog."en-MG-x-icu" is 'English (Madagascar)';

alter collation pg_catalog."en-MG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MH-x-icu" (
    locale = 'en-MH'
    );

comment on collation pg_catalog."en-MH-x-icu" is 'English (Marshall Islands)';

alter collation pg_catalog."en-MH-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MO-x-icu" (
    locale = 'en-MO'
    );

comment on collation pg_catalog."en-MO-x-icu" is 'English (Macao SAR China)';

alter collation pg_catalog."en-MO-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MP-x-icu" (
    locale = 'en-MP'
    );

comment on collation pg_catalog."en-MP-x-icu" is 'English (Northern Mariana Islands)';

alter collation pg_catalog."en-MP-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MS-x-icu" (
    locale = 'en-MS'
    );

comment on collation pg_catalog."en-MS-x-icu" is 'English (Montserrat)';

alter collation pg_catalog."en-MS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MT-x-icu" (
    locale = 'en-MT'
    );

comment on collation pg_catalog."en-MT-x-icu" is 'English (Malta)';

alter collation pg_catalog."en-MT-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MU-x-icu" (
    locale = 'en-MU'
    );

comment on collation pg_catalog."en-MU-x-icu" is 'English (Mauritius)';

alter collation pg_catalog."en-MU-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MV-x-icu" (
    locale = 'en-MV'
    );

comment on collation pg_catalog."en-MV-x-icu" is 'English (Maldives)';

alter collation pg_catalog."en-MV-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MW-x-icu" (
    locale = 'en-MW'
    );

comment on collation pg_catalog."en-MW-x-icu" is 'English (Malawi)';

alter collation pg_catalog."en-MW-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-MY-x-icu" (
    locale = 'en-MY'
    );

comment on collation pg_catalog."en-MY-x-icu" is 'English (Malaysia)';

alter collation pg_catalog."en-MY-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NA-x-icu" (
    locale = 'en-NA'
    );

comment on collation pg_catalog."en-NA-x-icu" is 'English (Namibia)';

alter collation pg_catalog."en-NA-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NF-x-icu" (
    locale = 'en-NF'
    );

comment on collation pg_catalog."en-NF-x-icu" is 'English (Norfolk Island)';

alter collation pg_catalog."en-NF-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NG-x-icu" (
    locale = 'en-NG'
    );

comment on collation pg_catalog."en-NG-x-icu" is 'English (Nigeria)';

alter collation pg_catalog."en-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NL-x-icu" (
    locale = 'en-NL'
    );

comment on collation pg_catalog."en-NL-x-icu" is 'English (Netherlands)';

alter collation pg_catalog."en-NL-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NR-x-icu" (
    locale = 'en-NR'
    );

comment on collation pg_catalog."en-NR-x-icu" is 'English (Nauru)';

alter collation pg_catalog."en-NR-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NU-x-icu" (
    locale = 'en-NU'
    );

comment on collation pg_catalog."en-NU-x-icu" is 'English (Niue)';

alter collation pg_catalog."en-NU-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-NZ-x-icu" (
    locale = 'en-NZ'
    );

comment on collation pg_catalog."en-NZ-x-icu" is 'English (New Zealand)';

alter collation pg_catalog."en-NZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PG-x-icu" (
    locale = 'en-PG'
    );

comment on collation pg_catalog."en-PG-x-icu" is 'English (Papua New Guinea)';

alter collation pg_catalog."en-PG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PH-x-icu" (
    locale = 'en-PH'
    );

comment on collation pg_catalog."en-PH-x-icu" is 'English (Philippines)';

alter collation pg_catalog."en-PH-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PK-x-icu" (
    locale = 'en-PK'
    );

comment on collation pg_catalog."en-PK-x-icu" is 'English (Pakistan)';

alter collation pg_catalog."en-PK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PN-x-icu" (
    locale = 'en-PN'
    );

comment on collation pg_catalog."en-PN-x-icu" is 'English (Pitcairn Islands)';

alter collation pg_catalog."en-PN-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PR-x-icu" (
    locale = 'en-PR'
    );

comment on collation pg_catalog."en-PR-x-icu" is 'English (Puerto Rico)';

alter collation pg_catalog."en-PR-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-PW-x-icu" (
    locale = 'en-PW'
    );

comment on collation pg_catalog."en-PW-x-icu" is 'English (Palau)';

alter collation pg_catalog."en-PW-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-RW-x-icu" (
    locale = 'en-RW'
    );

comment on collation pg_catalog."en-RW-x-icu" is 'English (Rwanda)';

alter collation pg_catalog."en-RW-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SB-x-icu" (
    locale = 'en-SB'
    );

comment on collation pg_catalog."en-SB-x-icu" is 'English (Solomon Islands)';

alter collation pg_catalog."en-SB-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SC-x-icu" (
    locale = 'en-SC'
    );

comment on collation pg_catalog."en-SC-x-icu" is 'English (Seychelles)';

alter collation pg_catalog."en-SC-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SD-x-icu" (
    locale = 'en-SD'
    );

comment on collation pg_catalog."en-SD-x-icu" is 'English (Sudan)';

alter collation pg_catalog."en-SD-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SE-x-icu" (
    locale = 'en-SE'
    );

comment on collation pg_catalog."en-SE-x-icu" is 'English (Sweden)';

alter collation pg_catalog."en-SE-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SG-x-icu" (
    locale = 'en-SG'
    );

comment on collation pg_catalog."en-SG-x-icu" is 'English (Singapore)';

alter collation pg_catalog."en-SG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SH-x-icu" (
    locale = 'en-SH'
    );

comment on collation pg_catalog."en-SH-x-icu" is 'English (St. Helena)';

alter collation pg_catalog."en-SH-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SI-x-icu" (
    locale = 'en-SI'
    );

comment on collation pg_catalog."en-SI-x-icu" is 'English (Slovenia)';

alter collation pg_catalog."en-SI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SL-x-icu" (
    locale = 'en-SL'
    );

comment on collation pg_catalog."en-SL-x-icu" is 'English (Sierra Leone)';

alter collation pg_catalog."en-SL-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SS-x-icu" (
    locale = 'en-SS'
    );

comment on collation pg_catalog."en-SS-x-icu" is 'English (South Sudan)';

alter collation pg_catalog."en-SS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SX-x-icu" (
    locale = 'en-SX'
    );

comment on collation pg_catalog."en-SX-x-icu" is 'English (Sint Maarten)';

alter collation pg_catalog."en-SX-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-SZ-x-icu" (
    locale = 'en-SZ'
    );

comment on collation pg_catalog."en-SZ-x-icu" is 'English (Eswatini)';

alter collation pg_catalog."en-SZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TC-x-icu" (
    locale = 'en-TC'
    );

comment on collation pg_catalog."en-TC-x-icu" is 'English (Turks & Caicos Islands)';

alter collation pg_catalog."en-TC-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TK-x-icu" (
    locale = 'en-TK'
    );

comment on collation pg_catalog."en-TK-x-icu" is 'English (Tokelau)';

alter collation pg_catalog."en-TK-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TO-x-icu" (
    locale = 'en-TO'
    );

comment on collation pg_catalog."en-TO-x-icu" is 'English (Tonga)';

alter collation pg_catalog."en-TO-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TT-x-icu" (
    locale = 'en-TT'
    );

comment on collation pg_catalog."en-TT-x-icu" is 'English (Trinidad & Tobago)';

alter collation pg_catalog."en-TT-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TV-x-icu" (
    locale = 'en-TV'
    );

comment on collation pg_catalog."en-TV-x-icu" is 'English (Tuvalu)';

alter collation pg_catalog."en-TV-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-TZ-x-icu" (
    locale = 'en-TZ'
    );

comment on collation pg_catalog."en-TZ-x-icu" is 'English (Tanzania)';

alter collation pg_catalog."en-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-UG-x-icu" (
    locale = 'en-UG'
    );

comment on collation pg_catalog."en-UG-x-icu" is 'English (Uganda)';

alter collation pg_catalog."en-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-UM-x-icu" (
    locale = 'en-UM'
    );

comment on collation pg_catalog."en-UM-x-icu" is 'English (U.S. Outlying Islands)';

alter collation pg_catalog."en-UM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-US-x-icu" (
    locale = 'en-US'
    );

comment on collation pg_catalog."en-US-x-icu" is 'English (United States)';

alter collation pg_catalog."en-US-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-US-u-va-posix-x-icu" (
    locale = 'en-US-u-va-posix'
    );

comment on collation pg_catalog."en-US-u-va-posix-x-icu" is 'English (United States, Computer)';

alter collation pg_catalog."en-US-u-va-posix-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-VC-x-icu" (
    locale = 'en-VC'
    );

comment on collation pg_catalog."en-VC-x-icu" is 'English (St. Vincent & Grenadines)';

alter collation pg_catalog."en-VC-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-VG-x-icu" (
    locale = 'en-VG'
    );

comment on collation pg_catalog."en-VG-x-icu" is 'English (British Virgin Islands)';

alter collation pg_catalog."en-VG-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-VI-x-icu" (
    locale = 'en-VI'
    );

comment on collation pg_catalog."en-VI-x-icu" is 'English (U.S. Virgin Islands)';

alter collation pg_catalog."en-VI-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-VU-x-icu" (
    locale = 'en-VU'
    );

comment on collation pg_catalog."en-VU-x-icu" is 'English (Vanuatu)';

alter collation pg_catalog."en-VU-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-WS-x-icu" (
    locale = 'en-WS'
    );

comment on collation pg_catalog."en-WS-x-icu" is 'English (Samoa)';

alter collation pg_catalog."en-WS-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-ZA-x-icu" (
    locale = 'en-ZA'
    );

comment on collation pg_catalog."en-ZA-x-icu" is 'English (South Africa)';

alter collation pg_catalog."en-ZA-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-ZM-x-icu" (
    locale = 'en-ZM'
    );

comment on collation pg_catalog."en-ZM-x-icu" is 'English (Zambia)';

alter collation pg_catalog."en-ZM-x-icu" owner to "kim-uijin";

create collation pg_catalog."en-ZW-x-icu" (
    locale = 'en-ZW'
    );

comment on collation pg_catalog."en-ZW-x-icu" is 'English (Zimbabwe)';

alter collation pg_catalog."en-ZW-x-icu" owner to "kim-uijin";

create collation pg_catalog."eo-x-icu" (
    locale = 'eo'
    );

comment on collation pg_catalog."eo-x-icu" is 'Esperanto';

alter collation pg_catalog."eo-x-icu" owner to "kim-uijin";

create collation pg_catalog."eo-001-x-icu" (
    locale = 'eo-001'
    );

comment on collation pg_catalog."eo-001-x-icu" is 'Esperanto (world)';

alter collation pg_catalog."eo-001-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-x-icu" (
    locale = 'es'
    );

comment on collation pg_catalog."es-x-icu" is 'Spanish';

alter collation pg_catalog."es-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-419-x-icu" (
    locale = 'es-419'
    );

comment on collation pg_catalog."es-419-x-icu" is 'Spanish (Latin America)';

alter collation pg_catalog."es-419-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-AR-x-icu" (
    locale = 'es-AR'
    );

comment on collation pg_catalog."es-AR-x-icu" is 'Spanish (Argentina)';

alter collation pg_catalog."es-AR-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-BO-x-icu" (
    locale = 'es-BO'
    );

comment on collation pg_catalog."es-BO-x-icu" is 'Spanish (Bolivia)';

alter collation pg_catalog."es-BO-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-BR-x-icu" (
    locale = 'es-BR'
    );

comment on collation pg_catalog."es-BR-x-icu" is 'Spanish (Brazil)';

alter collation pg_catalog."es-BR-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-BZ-x-icu" (
    locale = 'es-BZ'
    );

comment on collation pg_catalog."es-BZ-x-icu" is 'Spanish (Belize)';

alter collation pg_catalog."es-BZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-CL-x-icu" (
    locale = 'es-CL'
    );

comment on collation pg_catalog."es-CL-x-icu" is 'Spanish (Chile)';

alter collation pg_catalog."es-CL-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-CO-x-icu" (
    locale = 'es-CO'
    );

comment on collation pg_catalog."es-CO-x-icu" is 'Spanish (Colombia)';

alter collation pg_catalog."es-CO-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-CR-x-icu" (
    locale = 'es-CR'
    );

comment on collation pg_catalog."es-CR-x-icu" is 'Spanish (Costa Rica)';

alter collation pg_catalog."es-CR-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-CU-x-icu" (
    locale = 'es-CU'
    );

comment on collation pg_catalog."es-CU-x-icu" is 'Spanish (Cuba)';

alter collation pg_catalog."es-CU-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-DO-x-icu" (
    locale = 'es-DO'
    );

comment on collation pg_catalog."es-DO-x-icu" is 'Spanish (Dominican Republic)';

alter collation pg_catalog."es-DO-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-EA-x-icu" (
    locale = 'es-EA'
    );

comment on collation pg_catalog."es-EA-x-icu" is 'Spanish (Ceuta & Melilla)';

alter collation pg_catalog."es-EA-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-EC-x-icu" (
    locale = 'es-EC'
    );

comment on collation pg_catalog."es-EC-x-icu" is 'Spanish (Ecuador)';

alter collation pg_catalog."es-EC-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-ES-x-icu" (
    locale = 'es-ES'
    );

comment on collation pg_catalog."es-ES-x-icu" is 'Spanish (Spain)';

alter collation pg_catalog."es-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-GQ-x-icu" (
    locale = 'es-GQ'
    );

comment on collation pg_catalog."es-GQ-x-icu" is 'Spanish (Equatorial Guinea)';

alter collation pg_catalog."es-GQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-GT-x-icu" (
    locale = 'es-GT'
    );

comment on collation pg_catalog."es-GT-x-icu" is 'Spanish (Guatemala)';

alter collation pg_catalog."es-GT-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-HN-x-icu" (
    locale = 'es-HN'
    );

comment on collation pg_catalog."es-HN-x-icu" is 'Spanish (Honduras)';

alter collation pg_catalog."es-HN-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-IC-x-icu" (
    locale = 'es-IC'
    );

comment on collation pg_catalog."es-IC-x-icu" is 'Spanish (Canary Islands)';

alter collation pg_catalog."es-IC-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-MX-x-icu" (
    locale = 'es-MX'
    );

comment on collation pg_catalog."es-MX-x-icu" is 'Spanish (Mexico)';

alter collation pg_catalog."es-MX-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-NI-x-icu" (
    locale = 'es-NI'
    );

comment on collation pg_catalog."es-NI-x-icu" is 'Spanish (Nicaragua)';

alter collation pg_catalog."es-NI-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-PA-x-icu" (
    locale = 'es-PA'
    );

comment on collation pg_catalog."es-PA-x-icu" is 'Spanish (Panama)';

alter collation pg_catalog."es-PA-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-PE-x-icu" (
    locale = 'es-PE'
    );

comment on collation pg_catalog."es-PE-x-icu" is 'Spanish (Peru)';

alter collation pg_catalog."es-PE-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-PH-x-icu" (
    locale = 'es-PH'
    );

comment on collation pg_catalog."es-PH-x-icu" is 'Spanish (Philippines)';

alter collation pg_catalog."es-PH-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-PR-x-icu" (
    locale = 'es-PR'
    );

comment on collation pg_catalog."es-PR-x-icu" is 'Spanish (Puerto Rico)';

alter collation pg_catalog."es-PR-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-PY-x-icu" (
    locale = 'es-PY'
    );

comment on collation pg_catalog."es-PY-x-icu" is 'Spanish (Paraguay)';

alter collation pg_catalog."es-PY-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-SV-x-icu" (
    locale = 'es-SV'
    );

comment on collation pg_catalog."es-SV-x-icu" is 'Spanish (El Salvador)';

alter collation pg_catalog."es-SV-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-US-x-icu" (
    locale = 'es-US'
    );

comment on collation pg_catalog."es-US-x-icu" is 'Spanish (United States)';

alter collation pg_catalog."es-US-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-UY-x-icu" (
    locale = 'es-UY'
    );

comment on collation pg_catalog."es-UY-x-icu" is 'Spanish (Uruguay)';

alter collation pg_catalog."es-UY-x-icu" owner to "kim-uijin";

create collation pg_catalog."es-VE-x-icu" (
    locale = 'es-VE'
    );

comment on collation pg_catalog."es-VE-x-icu" is 'Spanish (Venezuela)';

alter collation pg_catalog."es-VE-x-icu" owner to "kim-uijin";

create collation pg_catalog."et-x-icu" (
    locale = 'et'
    );

comment on collation pg_catalog."et-x-icu" is 'Estonian';

alter collation pg_catalog."et-x-icu" owner to "kim-uijin";

create collation pg_catalog."et-EE-x-icu" (
    locale = 'et-EE'
    );

comment on collation pg_catalog."et-EE-x-icu" is 'Estonian (Estonia)';

alter collation pg_catalog."et-EE-x-icu" owner to "kim-uijin";

create collation pg_catalog."eu-x-icu" (
    locale = 'eu'
    );

comment on collation pg_catalog."eu-x-icu" is 'Basque';

alter collation pg_catalog."eu-x-icu" owner to "kim-uijin";

create collation pg_catalog."eu-ES-x-icu" (
    locale = 'eu-ES'
    );

comment on collation pg_catalog."eu-ES-x-icu" is 'Basque (Spain)';

alter collation pg_catalog."eu-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."ewo-x-icu" (
    locale = 'ewo'
    );

comment on collation pg_catalog."ewo-x-icu" is 'Ewondo';

alter collation pg_catalog."ewo-x-icu" owner to "kim-uijin";

create collation pg_catalog."ewo-CM-x-icu" (
    locale = 'ewo-CM'
    );

comment on collation pg_catalog."ewo-CM-x-icu" is 'Ewondo (Cameroon)';

alter collation pg_catalog."ewo-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."fa-x-icu" (
    locale = 'fa'
    );

comment on collation pg_catalog."fa-x-icu" is 'Persian';

alter collation pg_catalog."fa-x-icu" owner to "kim-uijin";

create collation pg_catalog."fa-AF-x-icu" (
    locale = 'fa-AF'
    );

comment on collation pg_catalog."fa-AF-x-icu" is 'Persian (Afghanistan)';

alter collation pg_catalog."fa-AF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fa-IR-x-icu" (
    locale = 'fa-IR'
    );

comment on collation pg_catalog."fa-IR-x-icu" is 'Persian (Iran)';

alter collation pg_catalog."fa-IR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-x-icu" (
    locale = 'ff'
    );

comment on collation pg_catalog."ff-x-icu" is 'Fula';

alter collation pg_catalog."ff-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-x-icu" (
    locale = 'ff-Adlm'
    );

comment on collation pg_catalog."ff-Adlm-x-icu" is 'Fula (Adlam)';

alter collation pg_catalog."ff-Adlm-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-BF-x-icu" (
    locale = 'ff-Adlm-BF'
    );

comment on collation pg_catalog."ff-Adlm-BF-x-icu" is 'Fula (Adlam, Burkina Faso)';

alter collation pg_catalog."ff-Adlm-BF-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-CM-x-icu" (
    locale = 'ff-Adlm-CM'
    );

comment on collation pg_catalog."ff-Adlm-CM-x-icu" is 'Fula (Adlam, Cameroon)';

alter collation pg_catalog."ff-Adlm-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-GH-x-icu" (
    locale = 'ff-Adlm-GH'
    );

comment on collation pg_catalog."ff-Adlm-GH-x-icu" is 'Fula (Adlam, Ghana)';

alter collation pg_catalog."ff-Adlm-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-GM-x-icu" (
    locale = 'ff-Adlm-GM'
    );

comment on collation pg_catalog."ff-Adlm-GM-x-icu" is 'Fula (Adlam, Gambia)';

alter collation pg_catalog."ff-Adlm-GM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-GN-x-icu" (
    locale = 'ff-Adlm-GN'
    );

comment on collation pg_catalog."ff-Adlm-GN-x-icu" is 'Fula (Adlam, Guinea)';

alter collation pg_catalog."ff-Adlm-GN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-GW-x-icu" (
    locale = 'ff-Adlm-GW'
    );

comment on collation pg_catalog."ff-Adlm-GW-x-icu" is 'Fula (Adlam, Guinea-Bissau)';

alter collation pg_catalog."ff-Adlm-GW-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-LR-x-icu" (
    locale = 'ff-Adlm-LR'
    );

comment on collation pg_catalog."ff-Adlm-LR-x-icu" is 'Fula (Adlam, Liberia)';

alter collation pg_catalog."ff-Adlm-LR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-MR-x-icu" (
    locale = 'ff-Adlm-MR'
    );

comment on collation pg_catalog."ff-Adlm-MR-x-icu" is 'Fula (Adlam, Mauritania)';

alter collation pg_catalog."ff-Adlm-MR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-NE-x-icu" (
    locale = 'ff-Adlm-NE'
    );

comment on collation pg_catalog."ff-Adlm-NE-x-icu" is 'Fula (Adlam, Niger)';

alter collation pg_catalog."ff-Adlm-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-NG-x-icu" (
    locale = 'ff-Adlm-NG'
    );

comment on collation pg_catalog."ff-Adlm-NG-x-icu" is 'Fula (Adlam, Nigeria)';

alter collation pg_catalog."ff-Adlm-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-SL-x-icu" (
    locale = 'ff-Adlm-SL'
    );

comment on collation pg_catalog."ff-Adlm-SL-x-icu" is 'Fula (Adlam, Sierra Leone)';

alter collation pg_catalog."ff-Adlm-SL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Adlm-SN-x-icu" (
    locale = 'ff-Adlm-SN'
    );

comment on collation pg_catalog."ff-Adlm-SN-x-icu" is 'Fula (Adlam, Senegal)';

alter collation pg_catalog."ff-Adlm-SN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-x-icu" (
    locale = 'ff-Latn'
    );

comment on collation pg_catalog."ff-Latn-x-icu" is 'Fula (Latin)';

alter collation pg_catalog."ff-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-BF-x-icu" (
    locale = 'ff-Latn-BF'
    );

comment on collation pg_catalog."ff-Latn-BF-x-icu" is 'Fula (Latin, Burkina Faso)';

alter collation pg_catalog."ff-Latn-BF-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-CM-x-icu" (
    locale = 'ff-Latn-CM'
    );

comment on collation pg_catalog."ff-Latn-CM-x-icu" is 'Fula (Latin, Cameroon)';

alter collation pg_catalog."ff-Latn-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-GH-x-icu" (
    locale = 'ff-Latn-GH'
    );

comment on collation pg_catalog."ff-Latn-GH-x-icu" is 'Fula (Latin, Ghana)';

alter collation pg_catalog."ff-Latn-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-GM-x-icu" (
    locale = 'ff-Latn-GM'
    );

comment on collation pg_catalog."ff-Latn-GM-x-icu" is 'Fula (Latin, Gambia)';

alter collation pg_catalog."ff-Latn-GM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-GN-x-icu" (
    locale = 'ff-Latn-GN'
    );

comment on collation pg_catalog."ff-Latn-GN-x-icu" is 'Fula (Latin, Guinea)';

alter collation pg_catalog."ff-Latn-GN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-GW-x-icu" (
    locale = 'ff-Latn-GW'
    );

comment on collation pg_catalog."ff-Latn-GW-x-icu" is 'Fula (Latin, Guinea-Bissau)';

alter collation pg_catalog."ff-Latn-GW-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-LR-x-icu" (
    locale = 'ff-Latn-LR'
    );

comment on collation pg_catalog."ff-Latn-LR-x-icu" is 'Fula (Latin, Liberia)';

alter collation pg_catalog."ff-Latn-LR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-MR-x-icu" (
    locale = 'ff-Latn-MR'
    );

comment on collation pg_catalog."ff-Latn-MR-x-icu" is 'Fula (Latin, Mauritania)';

alter collation pg_catalog."ff-Latn-MR-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-NE-x-icu" (
    locale = 'ff-Latn-NE'
    );

comment on collation pg_catalog."ff-Latn-NE-x-icu" is 'Fula (Latin, Niger)';

alter collation pg_catalog."ff-Latn-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-NG-x-icu" (
    locale = 'ff-Latn-NG'
    );

comment on collation pg_catalog."ff-Latn-NG-x-icu" is 'Fula (Latin, Nigeria)';

alter collation pg_catalog."ff-Latn-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-SL-x-icu" (
    locale = 'ff-Latn-SL'
    );

comment on collation pg_catalog."ff-Latn-SL-x-icu" is 'Fula (Latin, Sierra Leone)';

alter collation pg_catalog."ff-Latn-SL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ff-Latn-SN-x-icu" (
    locale = 'ff-Latn-SN'
    );

comment on collation pg_catalog."ff-Latn-SN-x-icu" is 'Fula (Latin, Senegal)';

alter collation pg_catalog."ff-Latn-SN-x-icu" owner to "kim-uijin";

create collation pg_catalog."fi-x-icu" (
    locale = 'fi'
    );

comment on collation pg_catalog."fi-x-icu" is 'Finnish';

alter collation pg_catalog."fi-x-icu" owner to "kim-uijin";

create collation pg_catalog."fi-FI-x-icu" (
    locale = 'fi-FI'
    );

comment on collation pg_catalog."fi-FI-x-icu" is 'Finnish (Finland)';

alter collation pg_catalog."fi-FI-x-icu" owner to "kim-uijin";

create collation pg_catalog."fil-x-icu" (
    locale = 'fil'
    );

comment on collation pg_catalog."fil-x-icu" is 'Filipino';

alter collation pg_catalog."fil-x-icu" owner to "kim-uijin";

create collation pg_catalog."fil-PH-x-icu" (
    locale = 'fil-PH'
    );

comment on collation pg_catalog."fil-PH-x-icu" is 'Filipino (Philippines)';

alter collation pg_catalog."fil-PH-x-icu" owner to "kim-uijin";

create collation pg_catalog."fo-x-icu" (
    locale = 'fo'
    );

comment on collation pg_catalog."fo-x-icu" is 'Faroese';

alter collation pg_catalog."fo-x-icu" owner to "kim-uijin";

create collation pg_catalog."fo-DK-x-icu" (
    locale = 'fo-DK'
    );

comment on collation pg_catalog."fo-DK-x-icu" is 'Faroese (Denmark)';

alter collation pg_catalog."fo-DK-x-icu" owner to "kim-uijin";

create collation pg_catalog."fo-FO-x-icu" (
    locale = 'fo-FO'
    );

comment on collation pg_catalog."fo-FO-x-icu" is 'Faroese (Faroe Islands)';

alter collation pg_catalog."fo-FO-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-x-icu" (
    locale = 'fr'
    );

comment on collation pg_catalog."fr-x-icu" is 'French';

alter collation pg_catalog."fr-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-BE-x-icu" (
    locale = 'fr-BE'
    );

comment on collation pg_catalog."fr-BE-x-icu" is 'French (Belgium)';

alter collation pg_catalog."fr-BE-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-BF-x-icu" (
    locale = 'fr-BF'
    );

comment on collation pg_catalog."fr-BF-x-icu" is 'French (Burkina Faso)';

alter collation pg_catalog."fr-BF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-BI-x-icu" (
    locale = 'fr-BI'
    );

comment on collation pg_catalog."fr-BI-x-icu" is 'French (Burundi)';

alter collation pg_catalog."fr-BI-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-BJ-x-icu" (
    locale = 'fr-BJ'
    );

comment on collation pg_catalog."fr-BJ-x-icu" is 'French (Benin)';

alter collation pg_catalog."fr-BJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-BL-x-icu" (
    locale = 'fr-BL'
    );

alter collation pg_catalog."fr-BL-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CA-x-icu" (
    locale = 'fr-CA'
    );

comment on collation pg_catalog."fr-CA-x-icu" is 'French (Canada)';

alter collation pg_catalog."fr-CA-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CD-x-icu" (
    locale = 'fr-CD'
    );

comment on collation pg_catalog."fr-CD-x-icu" is 'French (Congo - Kinshasa)';

alter collation pg_catalog."fr-CD-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CF-x-icu" (
    locale = 'fr-CF'
    );

comment on collation pg_catalog."fr-CF-x-icu" is 'French (Central African Republic)';

alter collation pg_catalog."fr-CF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CG-x-icu" (
    locale = 'fr-CG'
    );

comment on collation pg_catalog."fr-CG-x-icu" is 'French (Congo - Brazzaville)';

alter collation pg_catalog."fr-CG-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CH-x-icu" (
    locale = 'fr-CH'
    );

comment on collation pg_catalog."fr-CH-x-icu" is 'French (Switzerland)';

alter collation pg_catalog."fr-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CI-x-icu" (
    locale = 'fr-CI'
    );

alter collation pg_catalog."fr-CI-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-CM-x-icu" (
    locale = 'fr-CM'
    );

comment on collation pg_catalog."fr-CM-x-icu" is 'French (Cameroon)';

alter collation pg_catalog."fr-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-DJ-x-icu" (
    locale = 'fr-DJ'
    );

comment on collation pg_catalog."fr-DJ-x-icu" is 'French (Djibouti)';

alter collation pg_catalog."fr-DJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-DZ-x-icu" (
    locale = 'fr-DZ'
    );

comment on collation pg_catalog."fr-DZ-x-icu" is 'French (Algeria)';

alter collation pg_catalog."fr-DZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-FR-x-icu" (
    locale = 'fr-FR'
    );

comment on collation pg_catalog."fr-FR-x-icu" is 'French (France)';

alter collation pg_catalog."fr-FR-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-GA-x-icu" (
    locale = 'fr-GA'
    );

comment on collation pg_catalog."fr-GA-x-icu" is 'French (Gabon)';

alter collation pg_catalog."fr-GA-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-GF-x-icu" (
    locale = 'fr-GF'
    );

comment on collation pg_catalog."fr-GF-x-icu" is 'French (French Guiana)';

alter collation pg_catalog."fr-GF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-GN-x-icu" (
    locale = 'fr-GN'
    );

comment on collation pg_catalog."fr-GN-x-icu" is 'French (Guinea)';

alter collation pg_catalog."fr-GN-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-GP-x-icu" (
    locale = 'fr-GP'
    );

comment on collation pg_catalog."fr-GP-x-icu" is 'French (Guadeloupe)';

alter collation pg_catalog."fr-GP-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-GQ-x-icu" (
    locale = 'fr-GQ'
    );

comment on collation pg_catalog."fr-GQ-x-icu" is 'French (Equatorial Guinea)';

alter collation pg_catalog."fr-GQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-HT-x-icu" (
    locale = 'fr-HT'
    );

comment on collation pg_catalog."fr-HT-x-icu" is 'French (Haiti)';

alter collation pg_catalog."fr-HT-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-KM-x-icu" (
    locale = 'fr-KM'
    );

comment on collation pg_catalog."fr-KM-x-icu" is 'French (Comoros)';

alter collation pg_catalog."fr-KM-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-LU-x-icu" (
    locale = 'fr-LU'
    );

comment on collation pg_catalog."fr-LU-x-icu" is 'French (Luxembourg)';

alter collation pg_catalog."fr-LU-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MA-x-icu" (
    locale = 'fr-MA'
    );

comment on collation pg_catalog."fr-MA-x-icu" is 'French (Morocco)';

alter collation pg_catalog."fr-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MC-x-icu" (
    locale = 'fr-MC'
    );

comment on collation pg_catalog."fr-MC-x-icu" is 'French (Monaco)';

alter collation pg_catalog."fr-MC-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MF-x-icu" (
    locale = 'fr-MF'
    );

comment on collation pg_catalog."fr-MF-x-icu" is 'French (St. Martin)';

alter collation pg_catalog."fr-MF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MG-x-icu" (
    locale = 'fr-MG'
    );

comment on collation pg_catalog."fr-MG-x-icu" is 'French (Madagascar)';

alter collation pg_catalog."fr-MG-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-ML-x-icu" (
    locale = 'fr-ML'
    );

comment on collation pg_catalog."fr-ML-x-icu" is 'French (Mali)';

alter collation pg_catalog."fr-ML-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MQ-x-icu" (
    locale = 'fr-MQ'
    );

comment on collation pg_catalog."fr-MQ-x-icu" is 'French (Martinique)';

alter collation pg_catalog."fr-MQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MR-x-icu" (
    locale = 'fr-MR'
    );

comment on collation pg_catalog."fr-MR-x-icu" is 'French (Mauritania)';

alter collation pg_catalog."fr-MR-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-MU-x-icu" (
    locale = 'fr-MU'
    );

comment on collation pg_catalog."fr-MU-x-icu" is 'French (Mauritius)';

alter collation pg_catalog."fr-MU-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-NC-x-icu" (
    locale = 'fr-NC'
    );

comment on collation pg_catalog."fr-NC-x-icu" is 'French (New Caledonia)';

alter collation pg_catalog."fr-NC-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-NE-x-icu" (
    locale = 'fr-NE'
    );

comment on collation pg_catalog."fr-NE-x-icu" is 'French (Niger)';

alter collation pg_catalog."fr-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-PF-x-icu" (
    locale = 'fr-PF'
    );

comment on collation pg_catalog."fr-PF-x-icu" is 'French (French Polynesia)';

alter collation pg_catalog."fr-PF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-PM-x-icu" (
    locale = 'fr-PM'
    );

comment on collation pg_catalog."fr-PM-x-icu" is 'French (St. Pierre & Miquelon)';

alter collation pg_catalog."fr-PM-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-RE-x-icu" (
    locale = 'fr-RE'
    );

alter collation pg_catalog."fr-RE-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-RW-x-icu" (
    locale = 'fr-RW'
    );

comment on collation pg_catalog."fr-RW-x-icu" is 'French (Rwanda)';

alter collation pg_catalog."fr-RW-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-SC-x-icu" (
    locale = 'fr-SC'
    );

comment on collation pg_catalog."fr-SC-x-icu" is 'French (Seychelles)';

alter collation pg_catalog."fr-SC-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-SN-x-icu" (
    locale = 'fr-SN'
    );

comment on collation pg_catalog."fr-SN-x-icu" is 'French (Senegal)';

alter collation pg_catalog."fr-SN-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-SY-x-icu" (
    locale = 'fr-SY'
    );

comment on collation pg_catalog."fr-SY-x-icu" is 'French (Syria)';

alter collation pg_catalog."fr-SY-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-TD-x-icu" (
    locale = 'fr-TD'
    );

comment on collation pg_catalog."fr-TD-x-icu" is 'French (Chad)';

alter collation pg_catalog."fr-TD-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-TG-x-icu" (
    locale = 'fr-TG'
    );

comment on collation pg_catalog."fr-TG-x-icu" is 'French (Togo)';

alter collation pg_catalog."fr-TG-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-TN-x-icu" (
    locale = 'fr-TN'
    );

comment on collation pg_catalog."fr-TN-x-icu" is 'French (Tunisia)';

alter collation pg_catalog."fr-TN-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-VU-x-icu" (
    locale = 'fr-VU'
    );

comment on collation pg_catalog."fr-VU-x-icu" is 'French (Vanuatu)';

alter collation pg_catalog."fr-VU-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-WF-x-icu" (
    locale = 'fr-WF'
    );

comment on collation pg_catalog."fr-WF-x-icu" is 'French (Wallis & Futuna)';

alter collation pg_catalog."fr-WF-x-icu" owner to "kim-uijin";

create collation pg_catalog."fr-YT-x-icu" (
    locale = 'fr-YT'
    );

comment on collation pg_catalog."fr-YT-x-icu" is 'French (Mayotte)';

alter collation pg_catalog."fr-YT-x-icu" owner to "kim-uijin";

create collation pg_catalog."fur-x-icu" (
    locale = 'fur'
    );

comment on collation pg_catalog."fur-x-icu" is 'Friulian';

alter collation pg_catalog."fur-x-icu" owner to "kim-uijin";

create collation pg_catalog."fur-IT-x-icu" (
    locale = 'fur-IT'
    );

comment on collation pg_catalog."fur-IT-x-icu" is 'Friulian (Italy)';

alter collation pg_catalog."fur-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."fy-x-icu" (
    locale = 'fy'
    );

comment on collation pg_catalog."fy-x-icu" is 'Western Frisian';

alter collation pg_catalog."fy-x-icu" owner to "kim-uijin";

create collation pg_catalog."fy-NL-x-icu" (
    locale = 'fy-NL'
    );

comment on collation pg_catalog."fy-NL-x-icu" is 'Western Frisian (Netherlands)';

alter collation pg_catalog."fy-NL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ga-x-icu" (
    locale = 'ga'
    );

comment on collation pg_catalog."ga-x-icu" is 'Irish';

alter collation pg_catalog."ga-x-icu" owner to "kim-uijin";

create collation pg_catalog."ga-GB-x-icu" (
    locale = 'ga-GB'
    );

comment on collation pg_catalog."ga-GB-x-icu" is 'Irish (United Kingdom)';

alter collation pg_catalog."ga-GB-x-icu" owner to "kim-uijin";

create collation pg_catalog."ga-IE-x-icu" (
    locale = 'ga-IE'
    );

comment on collation pg_catalog."ga-IE-x-icu" is 'Irish (Ireland)';

alter collation pg_catalog."ga-IE-x-icu" owner to "kim-uijin";

create collation pg_catalog."gd-x-icu" (
    locale = 'gd'
    );

comment on collation pg_catalog."gd-x-icu" is 'Scottish Gaelic';

alter collation pg_catalog."gd-x-icu" owner to "kim-uijin";

create collation pg_catalog."gd-GB-x-icu" (
    locale = 'gd-GB'
    );

comment on collation pg_catalog."gd-GB-x-icu" is 'Scottish Gaelic (United Kingdom)';

alter collation pg_catalog."gd-GB-x-icu" owner to "kim-uijin";

create collation pg_catalog."gl-x-icu" (
    locale = 'gl'
    );

comment on collation pg_catalog."gl-x-icu" is 'Galician';

alter collation pg_catalog."gl-x-icu" owner to "kim-uijin";

create collation pg_catalog."gl-ES-x-icu" (
    locale = 'gl-ES'
    );

comment on collation pg_catalog."gl-ES-x-icu" is 'Galician (Spain)';

alter collation pg_catalog."gl-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."gsw-x-icu" (
    locale = 'gsw'
    );

comment on collation pg_catalog."gsw-x-icu" is 'Swiss German';

alter collation pg_catalog."gsw-x-icu" owner to "kim-uijin";

create collation pg_catalog."gsw-CH-x-icu" (
    locale = 'gsw-CH'
    );

comment on collation pg_catalog."gsw-CH-x-icu" is 'Swiss German (Switzerland)';

alter collation pg_catalog."gsw-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."gsw-FR-x-icu" (
    locale = 'gsw-FR'
    );

comment on collation pg_catalog."gsw-FR-x-icu" is 'Swiss German (France)';

alter collation pg_catalog."gsw-FR-x-icu" owner to "kim-uijin";

create collation pg_catalog."gsw-LI-x-icu" (
    locale = 'gsw-LI'
    );

comment on collation pg_catalog."gsw-LI-x-icu" is 'Swiss German (Liechtenstein)';

alter collation pg_catalog."gsw-LI-x-icu" owner to "kim-uijin";

create collation pg_catalog."gu-x-icu" (
    locale = 'gu'
    );

comment on collation pg_catalog."gu-x-icu" is 'Gujarati';

alter collation pg_catalog."gu-x-icu" owner to "kim-uijin";

create collation pg_catalog."gu-IN-x-icu" (
    locale = 'gu-IN'
    );

comment on collation pg_catalog."gu-IN-x-icu" is 'Gujarati (India)';

alter collation pg_catalog."gu-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."guz-x-icu" (
    locale = 'guz'
    );

comment on collation pg_catalog."guz-x-icu" is 'Gusii';

alter collation pg_catalog."guz-x-icu" owner to "kim-uijin";

create collation pg_catalog."guz-KE-x-icu" (
    locale = 'guz-KE'
    );

comment on collation pg_catalog."guz-KE-x-icu" is 'Gusii (Kenya)';

alter collation pg_catalog."guz-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."gv-x-icu" (
    locale = 'gv'
    );

comment on collation pg_catalog."gv-x-icu" is 'Manx';

alter collation pg_catalog."gv-x-icu" owner to "kim-uijin";

create collation pg_catalog."gv-IM-x-icu" (
    locale = 'gv-IM'
    );

comment on collation pg_catalog."gv-IM-x-icu" is 'Manx (Isle of Man)';

alter collation pg_catalog."gv-IM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ha-x-icu" (
    locale = 'ha'
    );

comment on collation pg_catalog."ha-x-icu" is 'Hausa';

alter collation pg_catalog."ha-x-icu" owner to "kim-uijin";

create collation pg_catalog."ha-GH-x-icu" (
    locale = 'ha-GH'
    );

comment on collation pg_catalog."ha-GH-x-icu" is 'Hausa (Ghana)';

alter collation pg_catalog."ha-GH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ha-NE-x-icu" (
    locale = 'ha-NE'
    );

comment on collation pg_catalog."ha-NE-x-icu" is 'Hausa (Niger)';

alter collation pg_catalog."ha-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ha-NG-x-icu" (
    locale = 'ha-NG'
    );

comment on collation pg_catalog."ha-NG-x-icu" is 'Hausa (Nigeria)';

alter collation pg_catalog."ha-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."haw-x-icu" (
    locale = 'haw'
    );

comment on collation pg_catalog."haw-x-icu" is 'Hawaiian';

alter collation pg_catalog."haw-x-icu" owner to "kim-uijin";

create collation pg_catalog."haw-US-x-icu" (
    locale = 'haw-US'
    );

comment on collation pg_catalog."haw-US-x-icu" is 'Hawaiian (United States)';

alter collation pg_catalog."haw-US-x-icu" owner to "kim-uijin";

create collation pg_catalog."he-x-icu" (
    locale = 'he'
    );

comment on collation pg_catalog."he-x-icu" is 'Hebrew';

alter collation pg_catalog."he-x-icu" owner to "kim-uijin";

create collation pg_catalog."he-IL-x-icu" (
    locale = 'he-IL'
    );

comment on collation pg_catalog."he-IL-x-icu" is 'Hebrew (Israel)';

alter collation pg_catalog."he-IL-x-icu" owner to "kim-uijin";

create collation pg_catalog."hi-x-icu" (
    locale = 'hi'
    );

comment on collation pg_catalog."hi-x-icu" is 'Hindi';

alter collation pg_catalog."hi-x-icu" owner to "kim-uijin";

create collation pg_catalog."hi-IN-x-icu" (
    locale = 'hi-IN'
    );

comment on collation pg_catalog."hi-IN-x-icu" is 'Hindi (India)';

alter collation pg_catalog."hi-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."hi-Latn-x-icu" (
    locale = 'hi-Latn'
    );

comment on collation pg_catalog."hi-Latn-x-icu" is 'Hindi (Latin)';

alter collation pg_catalog."hi-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."hi-Latn-IN-x-icu" (
    locale = 'hi-Latn-IN'
    );

comment on collation pg_catalog."hi-Latn-IN-x-icu" is 'Hindi (Latin, India)';

alter collation pg_catalog."hi-Latn-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."hr-x-icu" (
    locale = 'hr'
    );

comment on collation pg_catalog."hr-x-icu" is 'Croatian';

alter collation pg_catalog."hr-x-icu" owner to "kim-uijin";

create collation pg_catalog."hr-BA-x-icu" (
    locale = 'hr-BA'
    );

comment on collation pg_catalog."hr-BA-x-icu" is 'Croatian (Bosnia & Herzegovina)';

alter collation pg_catalog."hr-BA-x-icu" owner to "kim-uijin";

create collation pg_catalog."hr-HR-x-icu" (
    locale = 'hr-HR'
    );

comment on collation pg_catalog."hr-HR-x-icu" is 'Croatian (Croatia)';

alter collation pg_catalog."hr-HR-x-icu" owner to "kim-uijin";

create collation pg_catalog."hsb-x-icu" (
    locale = 'hsb'
    );

comment on collation pg_catalog."hsb-x-icu" is 'Upper Sorbian';

alter collation pg_catalog."hsb-x-icu" owner to "kim-uijin";

create collation pg_catalog."hsb-DE-x-icu" (
    locale = 'hsb-DE'
    );

comment on collation pg_catalog."hsb-DE-x-icu" is 'Upper Sorbian (Germany)';

alter collation pg_catalog."hsb-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."hu-x-icu" (
    locale = 'hu'
    );

comment on collation pg_catalog."hu-x-icu" is 'Hungarian';

alter collation pg_catalog."hu-x-icu" owner to "kim-uijin";

create collation pg_catalog."hu-HU-x-icu" (
    locale = 'hu-HU'
    );

comment on collation pg_catalog."hu-HU-x-icu" is 'Hungarian (Hungary)';

alter collation pg_catalog."hu-HU-x-icu" owner to "kim-uijin";

create collation pg_catalog."hy-x-icu" (
    locale = 'hy'
    );

comment on collation pg_catalog."hy-x-icu" is 'Armenian';

alter collation pg_catalog."hy-x-icu" owner to "kim-uijin";

create collation pg_catalog."hy-AM-x-icu" (
    locale = 'hy-AM'
    );

comment on collation pg_catalog."hy-AM-x-icu" is 'Armenian (Armenia)';

alter collation pg_catalog."hy-AM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ia-x-icu" (
    locale = 'ia'
    );

comment on collation pg_catalog."ia-x-icu" is 'Interlingua';

alter collation pg_catalog."ia-x-icu" owner to "kim-uijin";

create collation pg_catalog."ia-001-x-icu" (
    locale = 'ia-001'
    );

comment on collation pg_catalog."ia-001-x-icu" is 'Interlingua (world)';

alter collation pg_catalog."ia-001-x-icu" owner to "kim-uijin";

create collation pg_catalog."id-x-icu" (
    locale = 'id'
    );

comment on collation pg_catalog."id-x-icu" is 'Indonesian';

alter collation pg_catalog."id-x-icu" owner to "kim-uijin";

create collation pg_catalog."id-ID-x-icu" (
    locale = 'id-ID'
    );

comment on collation pg_catalog."id-ID-x-icu" is 'Indonesian (Indonesia)';

alter collation pg_catalog."id-ID-x-icu" owner to "kim-uijin";

create collation pg_catalog."ie-x-icu" (
    locale = 'ie'
    );

comment on collation pg_catalog."ie-x-icu" is 'Interlingue';

alter collation pg_catalog."ie-x-icu" owner to "kim-uijin";

create collation pg_catalog."ie-EE-x-icu" (
    locale = 'ie-EE'
    );

comment on collation pg_catalog."ie-EE-x-icu" is 'Interlingue (Estonia)';

alter collation pg_catalog."ie-EE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ig-x-icu" (
    locale = 'ig'
    );

comment on collation pg_catalog."ig-x-icu" is 'Igbo';

alter collation pg_catalog."ig-x-icu" owner to "kim-uijin";

create collation pg_catalog."ig-NG-x-icu" (
    locale = 'ig-NG'
    );

comment on collation pg_catalog."ig-NG-x-icu" is 'Igbo (Nigeria)';

alter collation pg_catalog."ig-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."ii-x-icu" (
    locale = 'ii'
    );

comment on collation pg_catalog."ii-x-icu" is 'Sichuan Yi';

alter collation pg_catalog."ii-x-icu" owner to "kim-uijin";

create collation pg_catalog."ii-CN-x-icu" (
    locale = 'ii-CN'
    );

comment on collation pg_catalog."ii-CN-x-icu" is 'Sichuan Yi (China)';

alter collation pg_catalog."ii-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."is-x-icu" (
    locale = 'is'
    );

comment on collation pg_catalog."is-x-icu" is 'Icelandic';

alter collation pg_catalog."is-x-icu" owner to "kim-uijin";

create collation pg_catalog."is-IS-x-icu" (
    locale = 'is-IS'
    );

comment on collation pg_catalog."is-IS-x-icu" is 'Icelandic (Iceland)';

alter collation pg_catalog."is-IS-x-icu" owner to "kim-uijin";

create collation pg_catalog."it-x-icu" (
    locale = 'it'
    );

comment on collation pg_catalog."it-x-icu" is 'Italian';

alter collation pg_catalog."it-x-icu" owner to "kim-uijin";

create collation pg_catalog."it-CH-x-icu" (
    locale = 'it-CH'
    );

comment on collation pg_catalog."it-CH-x-icu" is 'Italian (Switzerland)';

alter collation pg_catalog."it-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."it-IT-x-icu" (
    locale = 'it-IT'
    );

comment on collation pg_catalog."it-IT-x-icu" is 'Italian (Italy)';

alter collation pg_catalog."it-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."it-SM-x-icu" (
    locale = 'it-SM'
    );

comment on collation pg_catalog."it-SM-x-icu" is 'Italian (San Marino)';

alter collation pg_catalog."it-SM-x-icu" owner to "kim-uijin";

create collation pg_catalog."it-VA-x-icu" (
    locale = 'it-VA'
    );

comment on collation pg_catalog."it-VA-x-icu" is 'Italian (Vatican City)';

alter collation pg_catalog."it-VA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ja-x-icu" (
    locale = 'ja'
    );

comment on collation pg_catalog."ja-x-icu" is 'Japanese';

alter collation pg_catalog."ja-x-icu" owner to "kim-uijin";

create collation pg_catalog."ja-JP-x-icu" (
    locale = 'ja-JP'
    );

comment on collation pg_catalog."ja-JP-x-icu" is 'Japanese (Japan)';

alter collation pg_catalog."ja-JP-x-icu" owner to "kim-uijin";

create collation pg_catalog."jgo-x-icu" (
    locale = 'jgo'
    );

comment on collation pg_catalog."jgo-x-icu" is 'Ngomba';

alter collation pg_catalog."jgo-x-icu" owner to "kim-uijin";

create collation pg_catalog."jgo-CM-x-icu" (
    locale = 'jgo-CM'
    );

comment on collation pg_catalog."jgo-CM-x-icu" is 'Ngomba (Cameroon)';

alter collation pg_catalog."jgo-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."jmc-x-icu" (
    locale = 'jmc'
    );

comment on collation pg_catalog."jmc-x-icu" is 'Machame';

alter collation pg_catalog."jmc-x-icu" owner to "kim-uijin";

create collation pg_catalog."jmc-TZ-x-icu" (
    locale = 'jmc-TZ'
    );

comment on collation pg_catalog."jmc-TZ-x-icu" is 'Machame (Tanzania)';

alter collation pg_catalog."jmc-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."jv-x-icu" (
    locale = 'jv'
    );

comment on collation pg_catalog."jv-x-icu" is 'Javanese';

alter collation pg_catalog."jv-x-icu" owner to "kim-uijin";

create collation pg_catalog."jv-ID-x-icu" (
    locale = 'jv-ID'
    );

comment on collation pg_catalog."jv-ID-x-icu" is 'Javanese (Indonesia)';

alter collation pg_catalog."jv-ID-x-icu" owner to "kim-uijin";

create collation pg_catalog."ka-x-icu" (
    locale = 'ka'
    );

comment on collation pg_catalog."ka-x-icu" is 'Georgian';

alter collation pg_catalog."ka-x-icu" owner to "kim-uijin";

create collation pg_catalog."ka-GE-x-icu" (
    locale = 'ka-GE'
    );

comment on collation pg_catalog."ka-GE-x-icu" is 'Georgian (Georgia)';

alter collation pg_catalog."ka-GE-x-icu" owner to "kim-uijin";

create collation pg_catalog."kab-x-icu" (
    locale = 'kab'
    );

comment on collation pg_catalog."kab-x-icu" is 'Kabyle';

alter collation pg_catalog."kab-x-icu" owner to "kim-uijin";

create collation pg_catalog."kab-DZ-x-icu" (
    locale = 'kab-DZ'
    );

comment on collation pg_catalog."kab-DZ-x-icu" is 'Kabyle (Algeria)';

alter collation pg_catalog."kab-DZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."kam-x-icu" (
    locale = 'kam'
    );

comment on collation pg_catalog."kam-x-icu" is 'Kamba';

alter collation pg_catalog."kam-x-icu" owner to "kim-uijin";

create collation pg_catalog."kam-KE-x-icu" (
    locale = 'kam-KE'
    );

comment on collation pg_catalog."kam-KE-x-icu" is 'Kamba (Kenya)';

alter collation pg_catalog."kam-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."kde-x-icu" (
    locale = 'kde'
    );

comment on collation pg_catalog."kde-x-icu" is 'Makonde';

alter collation pg_catalog."kde-x-icu" owner to "kim-uijin";

create collation pg_catalog."kde-TZ-x-icu" (
    locale = 'kde-TZ'
    );

comment on collation pg_catalog."kde-TZ-x-icu" is 'Makonde (Tanzania)';

alter collation pg_catalog."kde-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."kea-x-icu" (
    locale = 'kea'
    );

comment on collation pg_catalog."kea-x-icu" is 'Kabuverdianu';

alter collation pg_catalog."kea-x-icu" owner to "kim-uijin";

create collation pg_catalog."kea-CV-x-icu" (
    locale = 'kea-CV'
    );

comment on collation pg_catalog."kea-CV-x-icu" is 'Kabuverdianu (Cape Verde)';

alter collation pg_catalog."kea-CV-x-icu" owner to "kim-uijin";

create collation pg_catalog."kgp-x-icu" (
    locale = 'kgp'
    );

comment on collation pg_catalog."kgp-x-icu" is 'Kaingang';

alter collation pg_catalog."kgp-x-icu" owner to "kim-uijin";

create collation pg_catalog."kgp-BR-x-icu" (
    locale = 'kgp-BR'
    );

comment on collation pg_catalog."kgp-BR-x-icu" is 'Kaingang (Brazil)';

alter collation pg_catalog."kgp-BR-x-icu" owner to "kim-uijin";

create collation pg_catalog."khq-x-icu" (
    locale = 'khq'
    );

comment on collation pg_catalog."khq-x-icu" is 'Koyra Chiini';

alter collation pg_catalog."khq-x-icu" owner to "kim-uijin";

create collation pg_catalog."khq-ML-x-icu" (
    locale = 'khq-ML'
    );

comment on collation pg_catalog."khq-ML-x-icu" is 'Koyra Chiini (Mali)';

alter collation pg_catalog."khq-ML-x-icu" owner to "kim-uijin";

create collation pg_catalog."ki-x-icu" (
    locale = 'ki'
    );

comment on collation pg_catalog."ki-x-icu" is 'Kikuyu';

alter collation pg_catalog."ki-x-icu" owner to "kim-uijin";

create collation pg_catalog."ki-KE-x-icu" (
    locale = 'ki-KE'
    );

comment on collation pg_catalog."ki-KE-x-icu" is 'Kikuyu (Kenya)';

alter collation pg_catalog."ki-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."kk-x-icu" (
    locale = 'kk'
    );

comment on collation pg_catalog."kk-x-icu" is 'Kazakh';

alter collation pg_catalog."kk-x-icu" owner to "kim-uijin";

create collation pg_catalog."kk-KZ-x-icu" (
    locale = 'kk-KZ'
    );

comment on collation pg_catalog."kk-KZ-x-icu" is 'Kazakh (Kazakhstan)';

alter collation pg_catalog."kk-KZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."kkj-x-icu" (
    locale = 'kkj'
    );

comment on collation pg_catalog."kkj-x-icu" is 'Kako';

alter collation pg_catalog."kkj-x-icu" owner to "kim-uijin";

create collation pg_catalog."kkj-CM-x-icu" (
    locale = 'kkj-CM'
    );

comment on collation pg_catalog."kkj-CM-x-icu" is 'Kako (Cameroon)';

alter collation pg_catalog."kkj-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."kl-x-icu" (
    locale = 'kl'
    );

comment on collation pg_catalog."kl-x-icu" is 'Kalaallisut';

alter collation pg_catalog."kl-x-icu" owner to "kim-uijin";

create collation pg_catalog."kl-GL-x-icu" (
    locale = 'kl-GL'
    );

comment on collation pg_catalog."kl-GL-x-icu" is 'Kalaallisut (Greenland)';

alter collation pg_catalog."kl-GL-x-icu" owner to "kim-uijin";

create collation pg_catalog."kln-x-icu" (
    locale = 'kln'
    );

comment on collation pg_catalog."kln-x-icu" is 'Kalenjin';

alter collation pg_catalog."kln-x-icu" owner to "kim-uijin";

create collation pg_catalog."kln-KE-x-icu" (
    locale = 'kln-KE'
    );

comment on collation pg_catalog."kln-KE-x-icu" is 'Kalenjin (Kenya)';

alter collation pg_catalog."kln-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."km-x-icu" (
    locale = 'km'
    );

comment on collation pg_catalog."km-x-icu" is 'Khmer';

alter collation pg_catalog."km-x-icu" owner to "kim-uijin";

create collation pg_catalog."km-KH-x-icu" (
    locale = 'km-KH'
    );

comment on collation pg_catalog."km-KH-x-icu" is 'Khmer (Cambodia)';

alter collation pg_catalog."km-KH-x-icu" owner to "kim-uijin";

create collation pg_catalog."kn-x-icu" (
    locale = 'kn'
    );

comment on collation pg_catalog."kn-x-icu" is 'Kannada';

alter collation pg_catalog."kn-x-icu" owner to "kim-uijin";

create collation pg_catalog."kn-IN-x-icu" (
    locale = 'kn-IN'
    );

comment on collation pg_catalog."kn-IN-x-icu" is 'Kannada (India)';

alter collation pg_catalog."kn-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ko-x-icu" (
    locale = 'ko'
    );

comment on collation pg_catalog."ko-x-icu" is 'Korean';

alter collation pg_catalog."ko-x-icu" owner to "kim-uijin";

create collation pg_catalog."ko-CN-x-icu" (
    locale = 'ko-CN'
    );

comment on collation pg_catalog."ko-CN-x-icu" is 'Korean (China)';

alter collation pg_catalog."ko-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ko-KP-x-icu" (
    locale = 'ko-KP'
    );

comment on collation pg_catalog."ko-KP-x-icu" is 'Korean (North Korea)';

alter collation pg_catalog."ko-KP-x-icu" owner to "kim-uijin";

create collation pg_catalog."ko-KR-x-icu" (
    locale = 'ko-KR'
    );

comment on collation pg_catalog."ko-KR-x-icu" is 'Korean (South Korea)';

alter collation pg_catalog."ko-KR-x-icu" owner to "kim-uijin";

create collation pg_catalog."kok-x-icu" (
    locale = 'kok'
    );

comment on collation pg_catalog."kok-x-icu" is 'Konkani';

alter collation pg_catalog."kok-x-icu" owner to "kim-uijin";

create collation pg_catalog."kok-IN-x-icu" (
    locale = 'kok-IN'
    );

comment on collation pg_catalog."kok-IN-x-icu" is 'Konkani (India)';

alter collation pg_catalog."kok-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ks-x-icu" (
    locale = 'ks'
    );

comment on collation pg_catalog."ks-x-icu" is 'Kashmiri';

alter collation pg_catalog."ks-x-icu" owner to "kim-uijin";

create collation pg_catalog."ks-Arab-x-icu" (
    locale = 'ks-Arab'
    );

comment on collation pg_catalog."ks-Arab-x-icu" is 'Kashmiri (Arabic)';

alter collation pg_catalog."ks-Arab-x-icu" owner to "kim-uijin";

create collation pg_catalog."ks-Arab-IN-x-icu" (
    locale = 'ks-Arab-IN'
    );

comment on collation pg_catalog."ks-Arab-IN-x-icu" is 'Kashmiri (Arabic, India)';

alter collation pg_catalog."ks-Arab-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ks-Deva-x-icu" (
    locale = 'ks-Deva'
    );

comment on collation pg_catalog."ks-Deva-x-icu" is 'Kashmiri (Devanagari)';

alter collation pg_catalog."ks-Deva-x-icu" owner to "kim-uijin";

create collation pg_catalog."ks-Deva-IN-x-icu" (
    locale = 'ks-Deva-IN'
    );

comment on collation pg_catalog."ks-Deva-IN-x-icu" is 'Kashmiri (Devanagari, India)';

alter collation pg_catalog."ks-Deva-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksb-x-icu" (
    locale = 'ksb'
    );

comment on collation pg_catalog."ksb-x-icu" is 'Shambala';

alter collation pg_catalog."ksb-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksb-TZ-x-icu" (
    locale = 'ksb-TZ'
    );

comment on collation pg_catalog."ksb-TZ-x-icu" is 'Shambala (Tanzania)';

alter collation pg_catalog."ksb-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksf-x-icu" (
    locale = 'ksf'
    );

comment on collation pg_catalog."ksf-x-icu" is 'Bafia';

alter collation pg_catalog."ksf-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksf-CM-x-icu" (
    locale = 'ksf-CM'
    );

comment on collation pg_catalog."ksf-CM-x-icu" is 'Bafia (Cameroon)';

alter collation pg_catalog."ksf-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksh-x-icu" (
    locale = 'ksh'
    );

comment on collation pg_catalog."ksh-x-icu" is 'Colognian';

alter collation pg_catalog."ksh-x-icu" owner to "kim-uijin";

create collation pg_catalog."ksh-DE-x-icu" (
    locale = 'ksh-DE'
    );

comment on collation pg_catalog."ksh-DE-x-icu" is 'Colognian (Germany)';

alter collation pg_catalog."ksh-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."ku-x-icu" (
    locale = 'ku'
    );

comment on collation pg_catalog."ku-x-icu" is 'Kurdish';

alter collation pg_catalog."ku-x-icu" owner to "kim-uijin";

create collation pg_catalog."ku-TR-x-icu" (
    locale = 'ku-TR'
    );

alter collation pg_catalog."ku-TR-x-icu" owner to "kim-uijin";

create collation pg_catalog."kw-x-icu" (
    locale = 'kw'
    );

comment on collation pg_catalog."kw-x-icu" is 'Cornish';

alter collation pg_catalog."kw-x-icu" owner to "kim-uijin";

create collation pg_catalog."kw-GB-x-icu" (
    locale = 'kw-GB'
    );

comment on collation pg_catalog."kw-GB-x-icu" is 'Cornish (United Kingdom)';

alter collation pg_catalog."kw-GB-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-x-icu" (
    locale = 'kxv'
    );

comment on collation pg_catalog."kxv-x-icu" is 'Kuvi';

alter collation pg_catalog."kxv-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Deva-x-icu" (
    locale = 'kxv-Deva'
    );

comment on collation pg_catalog."kxv-Deva-x-icu" is 'Kuvi (Devanagari)';

alter collation pg_catalog."kxv-Deva-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Deva-IN-x-icu" (
    locale = 'kxv-Deva-IN'
    );

comment on collation pg_catalog."kxv-Deva-IN-x-icu" is 'Kuvi (Devanagari, India)';

alter collation pg_catalog."kxv-Deva-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Latn-x-icu" (
    locale = 'kxv-Latn'
    );

comment on collation pg_catalog."kxv-Latn-x-icu" is 'Kuvi (Latin)';

alter collation pg_catalog."kxv-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Latn-IN-x-icu" (
    locale = 'kxv-Latn-IN'
    );

comment on collation pg_catalog."kxv-Latn-IN-x-icu" is 'Kuvi (Latin, India)';

alter collation pg_catalog."kxv-Latn-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Orya-x-icu" (
    locale = 'kxv-Orya'
    );

comment on collation pg_catalog."kxv-Orya-x-icu" is 'Kuvi (Odia)';

alter collation pg_catalog."kxv-Orya-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Orya-IN-x-icu" (
    locale = 'kxv-Orya-IN'
    );

comment on collation pg_catalog."kxv-Orya-IN-x-icu" is 'Kuvi (Odia, India)';

alter collation pg_catalog."kxv-Orya-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Telu-x-icu" (
    locale = 'kxv-Telu'
    );

comment on collation pg_catalog."kxv-Telu-x-icu" is 'Kuvi (Telugu)';

alter collation pg_catalog."kxv-Telu-x-icu" owner to "kim-uijin";

create collation pg_catalog."kxv-Telu-IN-x-icu" (
    locale = 'kxv-Telu-IN'
    );

comment on collation pg_catalog."kxv-Telu-IN-x-icu" is 'Kuvi (Telugu, India)';

alter collation pg_catalog."kxv-Telu-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ky-x-icu" (
    locale = 'ky'
    );

comment on collation pg_catalog."ky-x-icu" is 'Kyrgyz';

alter collation pg_catalog."ky-x-icu" owner to "kim-uijin";

create collation pg_catalog."ky-KG-x-icu" (
    locale = 'ky-KG'
    );

comment on collation pg_catalog."ky-KG-x-icu" is 'Kyrgyz (Kyrgyzstan)';

alter collation pg_catalog."ky-KG-x-icu" owner to "kim-uijin";

create collation pg_catalog."lag-x-icu" (
    locale = 'lag'
    );

comment on collation pg_catalog."lag-x-icu" is 'Langi';

alter collation pg_catalog."lag-x-icu" owner to "kim-uijin";

create collation pg_catalog."lag-TZ-x-icu" (
    locale = 'lag-TZ'
    );

comment on collation pg_catalog."lag-TZ-x-icu" is 'Langi (Tanzania)';

alter collation pg_catalog."lag-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."lb-x-icu" (
    locale = 'lb'
    );

comment on collation pg_catalog."lb-x-icu" is 'Luxembourgish';

alter collation pg_catalog."lb-x-icu" owner to "kim-uijin";

create collation pg_catalog."lb-LU-x-icu" (
    locale = 'lb-LU'
    );

comment on collation pg_catalog."lb-LU-x-icu" is 'Luxembourgish (Luxembourg)';

alter collation pg_catalog."lb-LU-x-icu" owner to "kim-uijin";

create collation pg_catalog."lg-x-icu" (
    locale = 'lg'
    );

comment on collation pg_catalog."lg-x-icu" is 'Ganda';

alter collation pg_catalog."lg-x-icu" owner to "kim-uijin";

create collation pg_catalog."lg-UG-x-icu" (
    locale = 'lg-UG'
    );

comment on collation pg_catalog."lg-UG-x-icu" is 'Ganda (Uganda)';

alter collation pg_catalog."lg-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."lij-x-icu" (
    locale = 'lij'
    );

comment on collation pg_catalog."lij-x-icu" is 'Ligurian';

alter collation pg_catalog."lij-x-icu" owner to "kim-uijin";

create collation pg_catalog."lij-IT-x-icu" (
    locale = 'lij-IT'
    );

comment on collation pg_catalog."lij-IT-x-icu" is 'Ligurian (Italy)';

alter collation pg_catalog."lij-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."lkt-x-icu" (
    locale = 'lkt'
    );

comment on collation pg_catalog."lkt-x-icu" is 'Lakota';

alter collation pg_catalog."lkt-x-icu" owner to "kim-uijin";

create collation pg_catalog."lkt-US-x-icu" (
    locale = 'lkt-US'
    );

comment on collation pg_catalog."lkt-US-x-icu" is 'Lakota (United States)';

alter collation pg_catalog."lkt-US-x-icu" owner to "kim-uijin";

create collation pg_catalog."lmo-x-icu" (
    locale = 'lmo'
    );

comment on collation pg_catalog."lmo-x-icu" is 'Lombard';

alter collation pg_catalog."lmo-x-icu" owner to "kim-uijin";

create collation pg_catalog."lmo-IT-x-icu" (
    locale = 'lmo-IT'
    );

comment on collation pg_catalog."lmo-IT-x-icu" is 'Lombard (Italy)';

alter collation pg_catalog."lmo-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."ln-x-icu" (
    locale = 'ln'
    );

comment on collation pg_catalog."ln-x-icu" is 'Lingala';

alter collation pg_catalog."ln-x-icu" owner to "kim-uijin";

create collation pg_catalog."ln-AO-x-icu" (
    locale = 'ln-AO'
    );

comment on collation pg_catalog."ln-AO-x-icu" is 'Lingala (Angola)';

alter collation pg_catalog."ln-AO-x-icu" owner to "kim-uijin";

create collation pg_catalog."ln-CD-x-icu" (
    locale = 'ln-CD'
    );

comment on collation pg_catalog."ln-CD-x-icu" is 'Lingala (Congo - Kinshasa)';

alter collation pg_catalog."ln-CD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ln-CF-x-icu" (
    locale = 'ln-CF'
    );

comment on collation pg_catalog."ln-CF-x-icu" is 'Lingala (Central African Republic)';

alter collation pg_catalog."ln-CF-x-icu" owner to "kim-uijin";

create collation pg_catalog."ln-CG-x-icu" (
    locale = 'ln-CG'
    );

comment on collation pg_catalog."ln-CG-x-icu" is 'Lingala (Congo - Brazzaville)';

alter collation pg_catalog."ln-CG-x-icu" owner to "kim-uijin";

create collation pg_catalog."lo-x-icu" (
    locale = 'lo'
    );

comment on collation pg_catalog."lo-x-icu" is 'Lao';

alter collation pg_catalog."lo-x-icu" owner to "kim-uijin";

create collation pg_catalog."lo-LA-x-icu" (
    locale = 'lo-LA'
    );

comment on collation pg_catalog."lo-LA-x-icu" is 'Lao (Laos)';

alter collation pg_catalog."lo-LA-x-icu" owner to "kim-uijin";

create collation pg_catalog."lrc-x-icu" (
    locale = 'lrc'
    );

comment on collation pg_catalog."lrc-x-icu" is 'Northern Luri';

alter collation pg_catalog."lrc-x-icu" owner to "kim-uijin";

create collation pg_catalog."lrc-IQ-x-icu" (
    locale = 'lrc-IQ'
    );

comment on collation pg_catalog."lrc-IQ-x-icu" is 'Northern Luri (Iraq)';

alter collation pg_catalog."lrc-IQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."lrc-IR-x-icu" (
    locale = 'lrc-IR'
    );

comment on collation pg_catalog."lrc-IR-x-icu" is 'Northern Luri (Iran)';

alter collation pg_catalog."lrc-IR-x-icu" owner to "kim-uijin";

create collation pg_catalog."lt-x-icu" (
    locale = 'lt'
    );

comment on collation pg_catalog."lt-x-icu" is 'Lithuanian';

alter collation pg_catalog."lt-x-icu" owner to "kim-uijin";

create collation pg_catalog."lt-LT-x-icu" (
    locale = 'lt-LT'
    );

comment on collation pg_catalog."lt-LT-x-icu" is 'Lithuanian (Lithuania)';

alter collation pg_catalog."lt-LT-x-icu" owner to "kim-uijin";

create collation pg_catalog."lu-x-icu" (
    locale = 'lu'
    );

comment on collation pg_catalog."lu-x-icu" is 'Luba-Katanga';

alter collation pg_catalog."lu-x-icu" owner to "kim-uijin";

create collation pg_catalog."lu-CD-x-icu" (
    locale = 'lu-CD'
    );

comment on collation pg_catalog."lu-CD-x-icu" is 'Luba-Katanga (Congo - Kinshasa)';

alter collation pg_catalog."lu-CD-x-icu" owner to "kim-uijin";

create collation pg_catalog."luo-x-icu" (
    locale = 'luo'
    );

comment on collation pg_catalog."luo-x-icu" is 'Luo';

alter collation pg_catalog."luo-x-icu" owner to "kim-uijin";

create collation pg_catalog."luo-KE-x-icu" (
    locale = 'luo-KE'
    );

comment on collation pg_catalog."luo-KE-x-icu" is 'Luo (Kenya)';

alter collation pg_catalog."luo-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."luy-x-icu" (
    locale = 'luy'
    );

comment on collation pg_catalog."luy-x-icu" is 'Luyia';

alter collation pg_catalog."luy-x-icu" owner to "kim-uijin";

create collation pg_catalog."luy-KE-x-icu" (
    locale = 'luy-KE'
    );

comment on collation pg_catalog."luy-KE-x-icu" is 'Luyia (Kenya)';

alter collation pg_catalog."luy-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."lv-x-icu" (
    locale = 'lv'
    );

comment on collation pg_catalog."lv-x-icu" is 'Latvian';

alter collation pg_catalog."lv-x-icu" owner to "kim-uijin";

create collation pg_catalog."lv-LV-x-icu" (
    locale = 'lv-LV'
    );

comment on collation pg_catalog."lv-LV-x-icu" is 'Latvian (Latvia)';

alter collation pg_catalog."lv-LV-x-icu" owner to "kim-uijin";

create collation pg_catalog."mai-x-icu" (
    locale = 'mai'
    );

comment on collation pg_catalog."mai-x-icu" is 'Maithili';

alter collation pg_catalog."mai-x-icu" owner to "kim-uijin";

create collation pg_catalog."mai-IN-x-icu" (
    locale = 'mai-IN'
    );

comment on collation pg_catalog."mai-IN-x-icu" is 'Maithili (India)';

alter collation pg_catalog."mai-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."mas-x-icu" (
    locale = 'mas'
    );

comment on collation pg_catalog."mas-x-icu" is 'Masai';

alter collation pg_catalog."mas-x-icu" owner to "kim-uijin";

create collation pg_catalog."mas-KE-x-icu" (
    locale = 'mas-KE'
    );

comment on collation pg_catalog."mas-KE-x-icu" is 'Masai (Kenya)';

alter collation pg_catalog."mas-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."mas-TZ-x-icu" (
    locale = 'mas-TZ'
    );

comment on collation pg_catalog."mas-TZ-x-icu" is 'Masai (Tanzania)';

alter collation pg_catalog."mas-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."mer-x-icu" (
    locale = 'mer'
    );

comment on collation pg_catalog."mer-x-icu" is 'Meru';

alter collation pg_catalog."mer-x-icu" owner to "kim-uijin";

create collation pg_catalog."mer-KE-x-icu" (
    locale = 'mer-KE'
    );

comment on collation pg_catalog."mer-KE-x-icu" is 'Meru (Kenya)';

alter collation pg_catalog."mer-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."mfe-x-icu" (
    locale = 'mfe'
    );

comment on collation pg_catalog."mfe-x-icu" is 'Morisyen';

alter collation pg_catalog."mfe-x-icu" owner to "kim-uijin";

create collation pg_catalog."mfe-MU-x-icu" (
    locale = 'mfe-MU'
    );

comment on collation pg_catalog."mfe-MU-x-icu" is 'Morisyen (Mauritius)';

alter collation pg_catalog."mfe-MU-x-icu" owner to "kim-uijin";

create collation pg_catalog."mg-x-icu" (
    locale = 'mg'
    );

comment on collation pg_catalog."mg-x-icu" is 'Malagasy';

alter collation pg_catalog."mg-x-icu" owner to "kim-uijin";

create collation pg_catalog."mg-MG-x-icu" (
    locale = 'mg-MG'
    );

comment on collation pg_catalog."mg-MG-x-icu" is 'Malagasy (Madagascar)';

alter collation pg_catalog."mg-MG-x-icu" owner to "kim-uijin";

create collation pg_catalog."mgh-x-icu" (
    locale = 'mgh'
    );

comment on collation pg_catalog."mgh-x-icu" is 'Makhuwa-Meetto';

alter collation pg_catalog."mgh-x-icu" owner to "kim-uijin";

create collation pg_catalog."mgh-MZ-x-icu" (
    locale = 'mgh-MZ'
    );

comment on collation pg_catalog."mgh-MZ-x-icu" is 'Makhuwa-Meetto (Mozambique)';

alter collation pg_catalog."mgh-MZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."mgo-x-icu" (
    locale = 'mgo'
    );

alter collation pg_catalog."mgo-x-icu" owner to "kim-uijin";

create collation pg_catalog."mgo-CM-x-icu" (
    locale = 'mgo-CM'
    );

alter collation pg_catalog."mgo-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."mi-x-icu" (
    locale = 'mi'
    );

alter collation pg_catalog."mi-x-icu" owner to "kim-uijin";

create collation pg_catalog."mi-NZ-x-icu" (
    locale = 'mi-NZ'
    );

alter collation pg_catalog."mi-NZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."mk-x-icu" (
    locale = 'mk'
    );

comment on collation pg_catalog."mk-x-icu" is 'Macedonian';

alter collation pg_catalog."mk-x-icu" owner to "kim-uijin";

create collation pg_catalog."mk-MK-x-icu" (
    locale = 'mk-MK'
    );

comment on collation pg_catalog."mk-MK-x-icu" is 'Macedonian (North Macedonia)';

alter collation pg_catalog."mk-MK-x-icu" owner to "kim-uijin";

create collation pg_catalog."ml-x-icu" (
    locale = 'ml'
    );

comment on collation pg_catalog."ml-x-icu" is 'Malayalam';

alter collation pg_catalog."ml-x-icu" owner to "kim-uijin";

create collation pg_catalog."ml-IN-x-icu" (
    locale = 'ml-IN'
    );

comment on collation pg_catalog."ml-IN-x-icu" is 'Malayalam (India)';

alter collation pg_catalog."ml-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."mn-x-icu" (
    locale = 'mn'
    );

comment on collation pg_catalog."mn-x-icu" is 'Mongolian';

alter collation pg_catalog."mn-x-icu" owner to "kim-uijin";

create collation pg_catalog."mn-MN-x-icu" (
    locale = 'mn-MN'
    );

comment on collation pg_catalog."mn-MN-x-icu" is 'Mongolian (Mongolia)';

alter collation pg_catalog."mn-MN-x-icu" owner to "kim-uijin";

create collation pg_catalog."mni-x-icu" (
    locale = 'mni'
    );

comment on collation pg_catalog."mni-x-icu" is 'Manipuri';

alter collation pg_catalog."mni-x-icu" owner to "kim-uijin";

create collation pg_catalog."mni-Beng-x-icu" (
    locale = 'mni-Beng'
    );

comment on collation pg_catalog."mni-Beng-x-icu" is 'Manipuri (Bangla)';

alter collation pg_catalog."mni-Beng-x-icu" owner to "kim-uijin";

create collation pg_catalog."mni-Beng-IN-x-icu" (
    locale = 'mni-Beng-IN'
    );

comment on collation pg_catalog."mni-Beng-IN-x-icu" is 'Manipuri (Bangla, India)';

alter collation pg_catalog."mni-Beng-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."mr-x-icu" (
    locale = 'mr'
    );

comment on collation pg_catalog."mr-x-icu" is 'Marathi';

alter collation pg_catalog."mr-x-icu" owner to "kim-uijin";

create collation pg_catalog."mr-IN-x-icu" (
    locale = 'mr-IN'
    );

comment on collation pg_catalog."mr-IN-x-icu" is 'Marathi (India)';

alter collation pg_catalog."mr-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ms-x-icu" (
    locale = 'ms'
    );

comment on collation pg_catalog."ms-x-icu" is 'Malay';

alter collation pg_catalog."ms-x-icu" owner to "kim-uijin";

create collation pg_catalog."ms-BN-x-icu" (
    locale = 'ms-BN'
    );

comment on collation pg_catalog."ms-BN-x-icu" is 'Malay (Brunei)';

alter collation pg_catalog."ms-BN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ms-ID-x-icu" (
    locale = 'ms-ID'
    );

comment on collation pg_catalog."ms-ID-x-icu" is 'Malay (Indonesia)';

alter collation pg_catalog."ms-ID-x-icu" owner to "kim-uijin";

create collation pg_catalog."ms-MY-x-icu" (
    locale = 'ms-MY'
    );

comment on collation pg_catalog."ms-MY-x-icu" is 'Malay (Malaysia)';

alter collation pg_catalog."ms-MY-x-icu" owner to "kim-uijin";

create collation pg_catalog."ms-SG-x-icu" (
    locale = 'ms-SG'
    );

comment on collation pg_catalog."ms-SG-x-icu" is 'Malay (Singapore)';

alter collation pg_catalog."ms-SG-x-icu" owner to "kim-uijin";

create collation pg_catalog."mt-x-icu" (
    locale = 'mt'
    );

comment on collation pg_catalog."mt-x-icu" is 'Maltese';

alter collation pg_catalog."mt-x-icu" owner to "kim-uijin";

create collation pg_catalog."mt-MT-x-icu" (
    locale = 'mt-MT'
    );

comment on collation pg_catalog."mt-MT-x-icu" is 'Maltese (Malta)';

alter collation pg_catalog."mt-MT-x-icu" owner to "kim-uijin";

create collation pg_catalog."mua-x-icu" (
    locale = 'mua'
    );

comment on collation pg_catalog."mua-x-icu" is 'Mundang';

alter collation pg_catalog."mua-x-icu" owner to "kim-uijin";

create collation pg_catalog."mua-CM-x-icu" (
    locale = 'mua-CM'
    );

comment on collation pg_catalog."mua-CM-x-icu" is 'Mundang (Cameroon)';

alter collation pg_catalog."mua-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."my-x-icu" (
    locale = 'my'
    );

comment on collation pg_catalog."my-x-icu" is 'Burmese';

alter collation pg_catalog."my-x-icu" owner to "kim-uijin";

create collation pg_catalog."my-MM-x-icu" (
    locale = 'my-MM'
    );

comment on collation pg_catalog."my-MM-x-icu" is 'Burmese (Myanmar [Burma])';

alter collation pg_catalog."my-MM-x-icu" owner to "kim-uijin";

create collation pg_catalog."mzn-x-icu" (
    locale = 'mzn'
    );

comment on collation pg_catalog."mzn-x-icu" is 'Mazanderani';

alter collation pg_catalog."mzn-x-icu" owner to "kim-uijin";

create collation pg_catalog."mzn-IR-x-icu" (
    locale = 'mzn-IR'
    );

comment on collation pg_catalog."mzn-IR-x-icu" is 'Mazanderani (Iran)';

alter collation pg_catalog."mzn-IR-x-icu" owner to "kim-uijin";

create collation pg_catalog."naq-x-icu" (
    locale = 'naq'
    );

comment on collation pg_catalog."naq-x-icu" is 'Nama';

alter collation pg_catalog."naq-x-icu" owner to "kim-uijin";

create collation pg_catalog."naq-NA-x-icu" (
    locale = 'naq-NA'
    );

comment on collation pg_catalog."naq-NA-x-icu" is 'Nama (Namibia)';

alter collation pg_catalog."naq-NA-x-icu" owner to "kim-uijin";

create collation pg_catalog."nb-x-icu" (
    locale = 'nb'
    );

alter collation pg_catalog."nb-x-icu" owner to "kim-uijin";

create collation pg_catalog."nb-NO-x-icu" (
    locale = 'nb-NO'
    );

alter collation pg_catalog."nb-NO-x-icu" owner to "kim-uijin";

create collation pg_catalog."nb-SJ-x-icu" (
    locale = 'nb-SJ'
    );

alter collation pg_catalog."nb-SJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."nd-x-icu" (
    locale = 'nd'
    );

comment on collation pg_catalog."nd-x-icu" is 'North Ndebele';

alter collation pg_catalog."nd-x-icu" owner to "kim-uijin";

create collation pg_catalog."nd-ZW-x-icu" (
    locale = 'nd-ZW'
    );

comment on collation pg_catalog."nd-ZW-x-icu" is 'North Ndebele (Zimbabwe)';

alter collation pg_catalog."nd-ZW-x-icu" owner to "kim-uijin";

create collation pg_catalog."nds-x-icu" (
    locale = 'nds'
    );

comment on collation pg_catalog."nds-x-icu" is 'Low German';

alter collation pg_catalog."nds-x-icu" owner to "kim-uijin";

create collation pg_catalog."nds-DE-x-icu" (
    locale = 'nds-DE'
    );

comment on collation pg_catalog."nds-DE-x-icu" is 'Low German (Germany)';

alter collation pg_catalog."nds-DE-x-icu" owner to "kim-uijin";

create collation pg_catalog."nds-NL-x-icu" (
    locale = 'nds-NL'
    );

comment on collation pg_catalog."nds-NL-x-icu" is 'Low German (Netherlands)';

alter collation pg_catalog."nds-NL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ne-x-icu" (
    locale = 'ne'
    );

comment on collation pg_catalog."ne-x-icu" is 'Nepali';

alter collation pg_catalog."ne-x-icu" owner to "kim-uijin";

create collation pg_catalog."ne-IN-x-icu" (
    locale = 'ne-IN'
    );

comment on collation pg_catalog."ne-IN-x-icu" is 'Nepali (India)';

alter collation pg_catalog."ne-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ne-NP-x-icu" (
    locale = 'ne-NP'
    );

comment on collation pg_catalog."ne-NP-x-icu" is 'Nepali (Nepal)';

alter collation pg_catalog."ne-NP-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-x-icu" (
    locale = 'nl'
    );

comment on collation pg_catalog."nl-x-icu" is 'Dutch';

alter collation pg_catalog."nl-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-AW-x-icu" (
    locale = 'nl-AW'
    );

comment on collation pg_catalog."nl-AW-x-icu" is 'Dutch (Aruba)';

alter collation pg_catalog."nl-AW-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-BE-x-icu" (
    locale = 'nl-BE'
    );

comment on collation pg_catalog."nl-BE-x-icu" is 'Dutch (Belgium)';

alter collation pg_catalog."nl-BE-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-BQ-x-icu" (
    locale = 'nl-BQ'
    );

comment on collation pg_catalog."nl-BQ-x-icu" is 'Dutch (Caribbean Netherlands)';

alter collation pg_catalog."nl-BQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-CW-x-icu" (
    locale = 'nl-CW'
    );

alter collation pg_catalog."nl-CW-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-NL-x-icu" (
    locale = 'nl-NL'
    );

comment on collation pg_catalog."nl-NL-x-icu" is 'Dutch (Netherlands)';

alter collation pg_catalog."nl-NL-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-SR-x-icu" (
    locale = 'nl-SR'
    );

comment on collation pg_catalog."nl-SR-x-icu" is 'Dutch (Suriname)';

alter collation pg_catalog."nl-SR-x-icu" owner to "kim-uijin";

create collation pg_catalog."nl-SX-x-icu" (
    locale = 'nl-SX'
    );

comment on collation pg_catalog."nl-SX-x-icu" is 'Dutch (Sint Maarten)';

alter collation pg_catalog."nl-SX-x-icu" owner to "kim-uijin";

create collation pg_catalog."nmg-x-icu" (
    locale = 'nmg'
    );

comment on collation pg_catalog."nmg-x-icu" is 'Kwasio';

alter collation pg_catalog."nmg-x-icu" owner to "kim-uijin";

create collation pg_catalog."nmg-CM-x-icu" (
    locale = 'nmg-CM'
    );

comment on collation pg_catalog."nmg-CM-x-icu" is 'Kwasio (Cameroon)';

alter collation pg_catalog."nmg-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."nn-x-icu" (
    locale = 'nn'
    );

comment on collation pg_catalog."nn-x-icu" is 'Norwegian Nynorsk';

alter collation pg_catalog."nn-x-icu" owner to "kim-uijin";

create collation pg_catalog."nn-NO-x-icu" (
    locale = 'nn-NO'
    );

comment on collation pg_catalog."nn-NO-x-icu" is 'Norwegian Nynorsk (Norway)';

alter collation pg_catalog."nn-NO-x-icu" owner to "kim-uijin";

create collation pg_catalog."nnh-x-icu" (
    locale = 'nnh'
    );

comment on collation pg_catalog."nnh-x-icu" is 'Ngiemboon';

alter collation pg_catalog."nnh-x-icu" owner to "kim-uijin";

create collation pg_catalog."nnh-CM-x-icu" (
    locale = 'nnh-CM'
    );

comment on collation pg_catalog."nnh-CM-x-icu" is 'Ngiemboon (Cameroon)';

alter collation pg_catalog."nnh-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."no-x-icu" (
    locale = 'no'
    );

comment on collation pg_catalog."no-x-icu" is 'Norwegian';

alter collation pg_catalog."no-x-icu" owner to "kim-uijin";

create collation pg_catalog."nqo-x-icu" (
    locale = 'nqo'
    );

alter collation pg_catalog."nqo-x-icu" owner to "kim-uijin";

create collation pg_catalog."nqo-GN-x-icu" (
    locale = 'nqo-GN'
    );

alter collation pg_catalog."nqo-GN-x-icu" owner to "kim-uijin";

create collation pg_catalog."nus-x-icu" (
    locale = 'nus'
    );

comment on collation pg_catalog."nus-x-icu" is 'Nuer';

alter collation pg_catalog."nus-x-icu" owner to "kim-uijin";

create collation pg_catalog."nus-SS-x-icu" (
    locale = 'nus-SS'
    );

comment on collation pg_catalog."nus-SS-x-icu" is 'Nuer (South Sudan)';

alter collation pg_catalog."nus-SS-x-icu" owner to "kim-uijin";

create collation pg_catalog."nyn-x-icu" (
    locale = 'nyn'
    );

comment on collation pg_catalog."nyn-x-icu" is 'Nyankole';

alter collation pg_catalog."nyn-x-icu" owner to "kim-uijin";

create collation pg_catalog."nyn-UG-x-icu" (
    locale = 'nyn-UG'
    );

comment on collation pg_catalog."nyn-UG-x-icu" is 'Nyankole (Uganda)';

alter collation pg_catalog."nyn-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."oc-x-icu" (
    locale = 'oc'
    );

comment on collation pg_catalog."oc-x-icu" is 'Occitan';

alter collation pg_catalog."oc-x-icu" owner to "kim-uijin";

create collation pg_catalog."oc-ES-x-icu" (
    locale = 'oc-ES'
    );

comment on collation pg_catalog."oc-ES-x-icu" is 'Occitan (Spain)';

alter collation pg_catalog."oc-ES-x-icu" owner to "kim-uijin";

create collation pg_catalog."oc-FR-x-icu" (
    locale = 'oc-FR'
    );

comment on collation pg_catalog."oc-FR-x-icu" is 'Occitan (France)';

alter collation pg_catalog."oc-FR-x-icu" owner to "kim-uijin";

create collation pg_catalog."om-x-icu" (
    locale = 'om'
    );

comment on collation pg_catalog."om-x-icu" is 'Oromo';

alter collation pg_catalog."om-x-icu" owner to "kim-uijin";

create collation pg_catalog."om-ET-x-icu" (
    locale = 'om-ET'
    );

comment on collation pg_catalog."om-ET-x-icu" is 'Oromo (Ethiopia)';

alter collation pg_catalog."om-ET-x-icu" owner to "kim-uijin";

create collation pg_catalog."om-KE-x-icu" (
    locale = 'om-KE'
    );

comment on collation pg_catalog."om-KE-x-icu" is 'Oromo (Kenya)';

alter collation pg_catalog."om-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."or-x-icu" (
    locale = 'or'
    );

comment on collation pg_catalog."or-x-icu" is 'Odia';

alter collation pg_catalog."or-x-icu" owner to "kim-uijin";

create collation pg_catalog."or-IN-x-icu" (
    locale = 'or-IN'
    );

comment on collation pg_catalog."or-IN-x-icu" is 'Odia (India)';

alter collation pg_catalog."or-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."os-x-icu" (
    locale = 'os'
    );

comment on collation pg_catalog."os-x-icu" is 'Ossetic';

alter collation pg_catalog."os-x-icu" owner to "kim-uijin";

create collation pg_catalog."os-GE-x-icu" (
    locale = 'os-GE'
    );

comment on collation pg_catalog."os-GE-x-icu" is 'Ossetic (Georgia)';

alter collation pg_catalog."os-GE-x-icu" owner to "kim-uijin";

create collation pg_catalog."os-RU-x-icu" (
    locale = 'os-RU'
    );

comment on collation pg_catalog."os-RU-x-icu" is 'Ossetic (Russia)';

alter collation pg_catalog."os-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."pa-x-icu" (
    locale = 'pa'
    );

comment on collation pg_catalog."pa-x-icu" is 'Punjabi';

alter collation pg_catalog."pa-x-icu" owner to "kim-uijin";

create collation pg_catalog."pa-Arab-x-icu" (
    locale = 'pa-Arab'
    );

comment on collation pg_catalog."pa-Arab-x-icu" is 'Punjabi (Arabic)';

alter collation pg_catalog."pa-Arab-x-icu" owner to "kim-uijin";

create collation pg_catalog."pa-Arab-PK-x-icu" (
    locale = 'pa-Arab-PK'
    );

comment on collation pg_catalog."pa-Arab-PK-x-icu" is 'Punjabi (Arabic, Pakistan)';

alter collation pg_catalog."pa-Arab-PK-x-icu" owner to "kim-uijin";

create collation pg_catalog."pa-Guru-x-icu" (
    locale = 'pa-Guru'
    );

comment on collation pg_catalog."pa-Guru-x-icu" is 'Punjabi (Gurmukhi)';

alter collation pg_catalog."pa-Guru-x-icu" owner to "kim-uijin";

create collation pg_catalog."pa-Guru-IN-x-icu" (
    locale = 'pa-Guru-IN'
    );

comment on collation pg_catalog."pa-Guru-IN-x-icu" is 'Punjabi (Gurmukhi, India)';

alter collation pg_catalog."pa-Guru-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."pcm-x-icu" (
    locale = 'pcm'
    );

comment on collation pg_catalog."pcm-x-icu" is 'Nigerian Pidgin';

alter collation pg_catalog."pcm-x-icu" owner to "kim-uijin";

create collation pg_catalog."pcm-NG-x-icu" (
    locale = 'pcm-NG'
    );

comment on collation pg_catalog."pcm-NG-x-icu" is 'Nigerian Pidgin (Nigeria)';

alter collation pg_catalog."pcm-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."pl-x-icu" (
    locale = 'pl'
    );

comment on collation pg_catalog."pl-x-icu" is 'Polish';

alter collation pg_catalog."pl-x-icu" owner to "kim-uijin";

create collation pg_catalog."pl-PL-x-icu" (
    locale = 'pl-PL'
    );

comment on collation pg_catalog."pl-PL-x-icu" is 'Polish (Poland)';

alter collation pg_catalog."pl-PL-x-icu" owner to "kim-uijin";

create collation pg_catalog."prg-x-icu" (
    locale = 'prg'
    );

comment on collation pg_catalog."prg-x-icu" is 'Prussian';

alter collation pg_catalog."prg-x-icu" owner to "kim-uijin";

create collation pg_catalog."prg-PL-x-icu" (
    locale = 'prg-PL'
    );

comment on collation pg_catalog."prg-PL-x-icu" is 'Prussian (Poland)';

alter collation pg_catalog."prg-PL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ps-x-icu" (
    locale = 'ps'
    );

comment on collation pg_catalog."ps-x-icu" is 'Pashto';

alter collation pg_catalog."ps-x-icu" owner to "kim-uijin";

create collation pg_catalog."ps-AF-x-icu" (
    locale = 'ps-AF'
    );

comment on collation pg_catalog."ps-AF-x-icu" is 'Pashto (Afghanistan)';

alter collation pg_catalog."ps-AF-x-icu" owner to "kim-uijin";

create collation pg_catalog."ps-PK-x-icu" (
    locale = 'ps-PK'
    );

comment on collation pg_catalog."ps-PK-x-icu" is 'Pashto (Pakistan)';

alter collation pg_catalog."ps-PK-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-x-icu" (
    locale = 'pt'
    );

comment on collation pg_catalog."pt-x-icu" is 'Portuguese';

alter collation pg_catalog."pt-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-AO-x-icu" (
    locale = 'pt-AO'
    );

comment on collation pg_catalog."pt-AO-x-icu" is 'Portuguese (Angola)';

alter collation pg_catalog."pt-AO-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-BR-x-icu" (
    locale = 'pt-BR'
    );

comment on collation pg_catalog."pt-BR-x-icu" is 'Portuguese (Brazil)';

alter collation pg_catalog."pt-BR-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-CH-x-icu" (
    locale = 'pt-CH'
    );

comment on collation pg_catalog."pt-CH-x-icu" is 'Portuguese (Switzerland)';

alter collation pg_catalog."pt-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-CV-x-icu" (
    locale = 'pt-CV'
    );

comment on collation pg_catalog."pt-CV-x-icu" is 'Portuguese (Cape Verde)';

alter collation pg_catalog."pt-CV-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-GQ-x-icu" (
    locale = 'pt-GQ'
    );

comment on collation pg_catalog."pt-GQ-x-icu" is 'Portuguese (Equatorial Guinea)';

alter collation pg_catalog."pt-GQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-GW-x-icu" (
    locale = 'pt-GW'
    );

comment on collation pg_catalog."pt-GW-x-icu" is 'Portuguese (Guinea-Bissau)';

alter collation pg_catalog."pt-GW-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-LU-x-icu" (
    locale = 'pt-LU'
    );

comment on collation pg_catalog."pt-LU-x-icu" is 'Portuguese (Luxembourg)';

alter collation pg_catalog."pt-LU-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-MO-x-icu" (
    locale = 'pt-MO'
    );

comment on collation pg_catalog."pt-MO-x-icu" is 'Portuguese (Macao SAR China)';

alter collation pg_catalog."pt-MO-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-MZ-x-icu" (
    locale = 'pt-MZ'
    );

comment on collation pg_catalog."pt-MZ-x-icu" is 'Portuguese (Mozambique)';

alter collation pg_catalog."pt-MZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-PT-x-icu" (
    locale = 'pt-PT'
    );

comment on collation pg_catalog."pt-PT-x-icu" is 'Portuguese (Portugal)';

alter collation pg_catalog."pt-PT-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-ST-x-icu" (
    locale = 'pt-ST'
    );

alter collation pg_catalog."pt-ST-x-icu" owner to "kim-uijin";

create collation pg_catalog."pt-TL-x-icu" (
    locale = 'pt-TL'
    );

comment on collation pg_catalog."pt-TL-x-icu" is 'Portuguese (Timor-Leste)';

alter collation pg_catalog."pt-TL-x-icu" owner to "kim-uijin";

create collation pg_catalog."qu-x-icu" (
    locale = 'qu'
    );

comment on collation pg_catalog."qu-x-icu" is 'Quechua';

alter collation pg_catalog."qu-x-icu" owner to "kim-uijin";

create collation pg_catalog."qu-BO-x-icu" (
    locale = 'qu-BO'
    );

comment on collation pg_catalog."qu-BO-x-icu" is 'Quechua (Bolivia)';

alter collation pg_catalog."qu-BO-x-icu" owner to "kim-uijin";

create collation pg_catalog."qu-EC-x-icu" (
    locale = 'qu-EC'
    );

comment on collation pg_catalog."qu-EC-x-icu" is 'Quechua (Ecuador)';

alter collation pg_catalog."qu-EC-x-icu" owner to "kim-uijin";

create collation pg_catalog."qu-PE-x-icu" (
    locale = 'qu-PE'
    );

comment on collation pg_catalog."qu-PE-x-icu" is 'Quechua (Peru)';

alter collation pg_catalog."qu-PE-x-icu" owner to "kim-uijin";

create collation pg_catalog."raj-x-icu" (
    locale = 'raj'
    );

comment on collation pg_catalog."raj-x-icu" is 'Rajasthani';

alter collation pg_catalog."raj-x-icu" owner to "kim-uijin";

create collation pg_catalog."raj-IN-x-icu" (
    locale = 'raj-IN'
    );

comment on collation pg_catalog."raj-IN-x-icu" is 'Rajasthani (India)';

alter collation pg_catalog."raj-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."rm-x-icu" (
    locale = 'rm'
    );

comment on collation pg_catalog."rm-x-icu" is 'Romansh';

alter collation pg_catalog."rm-x-icu" owner to "kim-uijin";

create collation pg_catalog."rm-CH-x-icu" (
    locale = 'rm-CH'
    );

comment on collation pg_catalog."rm-CH-x-icu" is 'Romansh (Switzerland)';

alter collation pg_catalog."rm-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."rn-x-icu" (
    locale = 'rn'
    );

comment on collation pg_catalog."rn-x-icu" is 'Rundi';

alter collation pg_catalog."rn-x-icu" owner to "kim-uijin";

create collation pg_catalog."rn-BI-x-icu" (
    locale = 'rn-BI'
    );

comment on collation pg_catalog."rn-BI-x-icu" is 'Rundi (Burundi)';

alter collation pg_catalog."rn-BI-x-icu" owner to "kim-uijin";

create collation pg_catalog."ro-x-icu" (
    locale = 'ro'
    );

comment on collation pg_catalog."ro-x-icu" is 'Romanian';

alter collation pg_catalog."ro-x-icu" owner to "kim-uijin";

create collation pg_catalog."ro-MD-x-icu" (
    locale = 'ro-MD'
    );

comment on collation pg_catalog."ro-MD-x-icu" is 'Romanian (Moldova)';

alter collation pg_catalog."ro-MD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ro-RO-x-icu" (
    locale = 'ro-RO'
    );

comment on collation pg_catalog."ro-RO-x-icu" is 'Romanian (Romania)';

alter collation pg_catalog."ro-RO-x-icu" owner to "kim-uijin";

create collation pg_catalog."rof-x-icu" (
    locale = 'rof'
    );

comment on collation pg_catalog."rof-x-icu" is 'Rombo';

alter collation pg_catalog."rof-x-icu" owner to "kim-uijin";

create collation pg_catalog."rof-TZ-x-icu" (
    locale = 'rof-TZ'
    );

comment on collation pg_catalog."rof-TZ-x-icu" is 'Rombo (Tanzania)';

alter collation pg_catalog."rof-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-x-icu" (
    locale = 'ru'
    );

comment on collation pg_catalog."ru-x-icu" is 'Russian';

alter collation pg_catalog."ru-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-BY-x-icu" (
    locale = 'ru-BY'
    );

comment on collation pg_catalog."ru-BY-x-icu" is 'Russian (Belarus)';

alter collation pg_catalog."ru-BY-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-KG-x-icu" (
    locale = 'ru-KG'
    );

comment on collation pg_catalog."ru-KG-x-icu" is 'Russian (Kyrgyzstan)';

alter collation pg_catalog."ru-KG-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-KZ-x-icu" (
    locale = 'ru-KZ'
    );

comment on collation pg_catalog."ru-KZ-x-icu" is 'Russian (Kazakhstan)';

alter collation pg_catalog."ru-KZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-MD-x-icu" (
    locale = 'ru-MD'
    );

comment on collation pg_catalog."ru-MD-x-icu" is 'Russian (Moldova)';

alter collation pg_catalog."ru-MD-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-RU-x-icu" (
    locale = 'ru-RU'
    );

comment on collation pg_catalog."ru-RU-x-icu" is 'Russian (Russia)';

alter collation pg_catalog."ru-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."ru-UA-x-icu" (
    locale = 'ru-UA'
    );

comment on collation pg_catalog."ru-UA-x-icu" is 'Russian (Ukraine)';

alter collation pg_catalog."ru-UA-x-icu" owner to "kim-uijin";

create collation pg_catalog."rw-x-icu" (
    locale = 'rw'
    );

comment on collation pg_catalog."rw-x-icu" is 'Kinyarwanda';

alter collation pg_catalog."rw-x-icu" owner to "kim-uijin";

create collation pg_catalog."rw-RW-x-icu" (
    locale = 'rw-RW'
    );

comment on collation pg_catalog."rw-RW-x-icu" is 'Kinyarwanda (Rwanda)';

alter collation pg_catalog."rw-RW-x-icu" owner to "kim-uijin";

create collation pg_catalog."rwk-x-icu" (
    locale = 'rwk'
    );

comment on collation pg_catalog."rwk-x-icu" is 'Rwa';

alter collation pg_catalog."rwk-x-icu" owner to "kim-uijin";

create collation pg_catalog."rwk-TZ-x-icu" (
    locale = 'rwk-TZ'
    );

comment on collation pg_catalog."rwk-TZ-x-icu" is 'Rwa (Tanzania)';

alter collation pg_catalog."rwk-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."sa-x-icu" (
    locale = 'sa'
    );

comment on collation pg_catalog."sa-x-icu" is 'Sanskrit';

alter collation pg_catalog."sa-x-icu" owner to "kim-uijin";

create collation pg_catalog."sa-IN-x-icu" (
    locale = 'sa-IN'
    );

comment on collation pg_catalog."sa-IN-x-icu" is 'Sanskrit (India)';

alter collation pg_catalog."sa-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."sah-x-icu" (
    locale = 'sah'
    );

comment on collation pg_catalog."sah-x-icu" is 'Yakut';

alter collation pg_catalog."sah-x-icu" owner to "kim-uijin";

create collation pg_catalog."sah-RU-x-icu" (
    locale = 'sah-RU'
    );

comment on collation pg_catalog."sah-RU-x-icu" is 'Yakut (Russia)';

alter collation pg_catalog."sah-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."saq-x-icu" (
    locale = 'saq'
    );

comment on collation pg_catalog."saq-x-icu" is 'Samburu';

alter collation pg_catalog."saq-x-icu" owner to "kim-uijin";

create collation pg_catalog."saq-KE-x-icu" (
    locale = 'saq-KE'
    );

comment on collation pg_catalog."saq-KE-x-icu" is 'Samburu (Kenya)';

alter collation pg_catalog."saq-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."sat-x-icu" (
    locale = 'sat'
    );

comment on collation pg_catalog."sat-x-icu" is 'Santali';

alter collation pg_catalog."sat-x-icu" owner to "kim-uijin";

create collation pg_catalog."sat-Olck-x-icu" (
    locale = 'sat-Olck'
    );

comment on collation pg_catalog."sat-Olck-x-icu" is 'Santali (Ol Chiki)';

alter collation pg_catalog."sat-Olck-x-icu" owner to "kim-uijin";

create collation pg_catalog."sat-Olck-IN-x-icu" (
    locale = 'sat-Olck-IN'
    );

comment on collation pg_catalog."sat-Olck-IN-x-icu" is 'Santali (Ol Chiki, India)';

alter collation pg_catalog."sat-Olck-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."sbp-x-icu" (
    locale = 'sbp'
    );

comment on collation pg_catalog."sbp-x-icu" is 'Sangu';

alter collation pg_catalog."sbp-x-icu" owner to "kim-uijin";

create collation pg_catalog."sbp-TZ-x-icu" (
    locale = 'sbp-TZ'
    );

comment on collation pg_catalog."sbp-TZ-x-icu" is 'Sangu (Tanzania)';

alter collation pg_catalog."sbp-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."sc-x-icu" (
    locale = 'sc'
    );

comment on collation pg_catalog."sc-x-icu" is 'Sardinian';

alter collation pg_catalog."sc-x-icu" owner to "kim-uijin";

create collation pg_catalog."sc-IT-x-icu" (
    locale = 'sc-IT'
    );

comment on collation pg_catalog."sc-IT-x-icu" is 'Sardinian (Italy)';

alter collation pg_catalog."sc-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."sd-x-icu" (
    locale = 'sd'
    );

comment on collation pg_catalog."sd-x-icu" is 'Sindhi';

alter collation pg_catalog."sd-x-icu" owner to "kim-uijin";

create collation pg_catalog."sd-Arab-x-icu" (
    locale = 'sd-Arab'
    );

comment on collation pg_catalog."sd-Arab-x-icu" is 'Sindhi (Arabic)';

alter collation pg_catalog."sd-Arab-x-icu" owner to "kim-uijin";

create collation pg_catalog."sd-Arab-PK-x-icu" (
    locale = 'sd-Arab-PK'
    );

comment on collation pg_catalog."sd-Arab-PK-x-icu" is 'Sindhi (Arabic, Pakistan)';

alter collation pg_catalog."sd-Arab-PK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sd-Deva-x-icu" (
    locale = 'sd-Deva'
    );

comment on collation pg_catalog."sd-Deva-x-icu" is 'Sindhi (Devanagari)';

alter collation pg_catalog."sd-Deva-x-icu" owner to "kim-uijin";

create collation pg_catalog."sd-Deva-IN-x-icu" (
    locale = 'sd-Deva-IN'
    );

comment on collation pg_catalog."sd-Deva-IN-x-icu" is 'Sindhi (Devanagari, India)';

alter collation pg_catalog."sd-Deva-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."se-x-icu" (
    locale = 'se'
    );

comment on collation pg_catalog."se-x-icu" is 'Northern Sami';

alter collation pg_catalog."se-x-icu" owner to "kim-uijin";

create collation pg_catalog."se-FI-x-icu" (
    locale = 'se-FI'
    );

comment on collation pg_catalog."se-FI-x-icu" is 'Northern Sami (Finland)';

alter collation pg_catalog."se-FI-x-icu" owner to "kim-uijin";

create collation pg_catalog."se-NO-x-icu" (
    locale = 'se-NO'
    );

comment on collation pg_catalog."se-NO-x-icu" is 'Northern Sami (Norway)';

alter collation pg_catalog."se-NO-x-icu" owner to "kim-uijin";

create collation pg_catalog."se-SE-x-icu" (
    locale = 'se-SE'
    );

comment on collation pg_catalog."se-SE-x-icu" is 'Northern Sami (Sweden)';

alter collation pg_catalog."se-SE-x-icu" owner to "kim-uijin";

create collation pg_catalog."seh-x-icu" (
    locale = 'seh'
    );

comment on collation pg_catalog."seh-x-icu" is 'Sena';

alter collation pg_catalog."seh-x-icu" owner to "kim-uijin";

create collation pg_catalog."seh-MZ-x-icu" (
    locale = 'seh-MZ'
    );

comment on collation pg_catalog."seh-MZ-x-icu" is 'Sena (Mozambique)';

alter collation pg_catalog."seh-MZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."ses-x-icu" (
    locale = 'ses'
    );

comment on collation pg_catalog."ses-x-icu" is 'Koyraboro Senni';

alter collation pg_catalog."ses-x-icu" owner to "kim-uijin";

create collation pg_catalog."ses-ML-x-icu" (
    locale = 'ses-ML'
    );

comment on collation pg_catalog."ses-ML-x-icu" is 'Koyraboro Senni (Mali)';

alter collation pg_catalog."ses-ML-x-icu" owner to "kim-uijin";

create collation pg_catalog."sg-x-icu" (
    locale = 'sg'
    );

comment on collation pg_catalog."sg-x-icu" is 'Sango';

alter collation pg_catalog."sg-x-icu" owner to "kim-uijin";

create collation pg_catalog."sg-CF-x-icu" (
    locale = 'sg-CF'
    );

comment on collation pg_catalog."sg-CF-x-icu" is 'Sango (Central African Republic)';

alter collation pg_catalog."sg-CF-x-icu" owner to "kim-uijin";

create collation pg_catalog."shi-x-icu" (
    locale = 'shi'
    );

comment on collation pg_catalog."shi-x-icu" is 'Tachelhit';

alter collation pg_catalog."shi-x-icu" owner to "kim-uijin";

create collation pg_catalog."shi-Latn-x-icu" (
    locale = 'shi-Latn'
    );

comment on collation pg_catalog."shi-Latn-x-icu" is 'Tachelhit (Latin)';

alter collation pg_catalog."shi-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."shi-Latn-MA-x-icu" (
    locale = 'shi-Latn-MA'
    );

comment on collation pg_catalog."shi-Latn-MA-x-icu" is 'Tachelhit (Latin, Morocco)';

alter collation pg_catalog."shi-Latn-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."shi-Tfng-x-icu" (
    locale = 'shi-Tfng'
    );

comment on collation pg_catalog."shi-Tfng-x-icu" is 'Tachelhit (Tifinagh)';

alter collation pg_catalog."shi-Tfng-x-icu" owner to "kim-uijin";

create collation pg_catalog."shi-Tfng-MA-x-icu" (
    locale = 'shi-Tfng-MA'
    );

comment on collation pg_catalog."shi-Tfng-MA-x-icu" is 'Tachelhit (Tifinagh, Morocco)';

alter collation pg_catalog."shi-Tfng-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."si-x-icu" (
    locale = 'si'
    );

comment on collation pg_catalog."si-x-icu" is 'Sinhala';

alter collation pg_catalog."si-x-icu" owner to "kim-uijin";

create collation pg_catalog."si-LK-x-icu" (
    locale = 'si-LK'
    );

comment on collation pg_catalog."si-LK-x-icu" is 'Sinhala (Sri Lanka)';

alter collation pg_catalog."si-LK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sk-x-icu" (
    locale = 'sk'
    );

comment on collation pg_catalog."sk-x-icu" is 'Slovak';

alter collation pg_catalog."sk-x-icu" owner to "kim-uijin";

create collation pg_catalog."sk-SK-x-icu" (
    locale = 'sk-SK'
    );

comment on collation pg_catalog."sk-SK-x-icu" is 'Slovak (Slovakia)';

alter collation pg_catalog."sk-SK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sl-x-icu" (
    locale = 'sl'
    );

comment on collation pg_catalog."sl-x-icu" is 'Slovenian';

alter collation pg_catalog."sl-x-icu" owner to "kim-uijin";

create collation pg_catalog."sl-SI-x-icu" (
    locale = 'sl-SI'
    );

comment on collation pg_catalog."sl-SI-x-icu" is 'Slovenian (Slovenia)';

alter collation pg_catalog."sl-SI-x-icu" owner to "kim-uijin";

create collation pg_catalog."smn-x-icu" (
    locale = 'smn'
    );

comment on collation pg_catalog."smn-x-icu" is 'Inari Sami';

alter collation pg_catalog."smn-x-icu" owner to "kim-uijin";

create collation pg_catalog."smn-FI-x-icu" (
    locale = 'smn-FI'
    );

comment on collation pg_catalog."smn-FI-x-icu" is 'Inari Sami (Finland)';

alter collation pg_catalog."smn-FI-x-icu" owner to "kim-uijin";

create collation pg_catalog."sn-x-icu" (
    locale = 'sn'
    );

comment on collation pg_catalog."sn-x-icu" is 'Shona';

alter collation pg_catalog."sn-x-icu" owner to "kim-uijin";

create collation pg_catalog."sn-ZW-x-icu" (
    locale = 'sn-ZW'
    );

comment on collation pg_catalog."sn-ZW-x-icu" is 'Shona (Zimbabwe)';

alter collation pg_catalog."sn-ZW-x-icu" owner to "kim-uijin";

create collation pg_catalog."so-x-icu" (
    locale = 'so'
    );

comment on collation pg_catalog."so-x-icu" is 'Somali';

alter collation pg_catalog."so-x-icu" owner to "kim-uijin";

create collation pg_catalog."so-DJ-x-icu" (
    locale = 'so-DJ'
    );

comment on collation pg_catalog."so-DJ-x-icu" is 'Somali (Djibouti)';

alter collation pg_catalog."so-DJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."so-ET-x-icu" (
    locale = 'so-ET'
    );

comment on collation pg_catalog."so-ET-x-icu" is 'Somali (Ethiopia)';

alter collation pg_catalog."so-ET-x-icu" owner to "kim-uijin";

create collation pg_catalog."so-KE-x-icu" (
    locale = 'so-KE'
    );

comment on collation pg_catalog."so-KE-x-icu" is 'Somali (Kenya)';

alter collation pg_catalog."so-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."so-SO-x-icu" (
    locale = 'so-SO'
    );

comment on collation pg_catalog."so-SO-x-icu" is 'Somali (Somalia)';

alter collation pg_catalog."so-SO-x-icu" owner to "kim-uijin";

create collation pg_catalog."sq-x-icu" (
    locale = 'sq'
    );

comment on collation pg_catalog."sq-x-icu" is 'Albanian';

alter collation pg_catalog."sq-x-icu" owner to "kim-uijin";

create collation pg_catalog."sq-AL-x-icu" (
    locale = 'sq-AL'
    );

comment on collation pg_catalog."sq-AL-x-icu" is 'Albanian (Albania)';

alter collation pg_catalog."sq-AL-x-icu" owner to "kim-uijin";

create collation pg_catalog."sq-MK-x-icu" (
    locale = 'sq-MK'
    );

comment on collation pg_catalog."sq-MK-x-icu" is 'Albanian (North Macedonia)';

alter collation pg_catalog."sq-MK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sq-XK-x-icu" (
    locale = 'sq-XK'
    );

comment on collation pg_catalog."sq-XK-x-icu" is 'Albanian (Kosovo)';

alter collation pg_catalog."sq-XK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-x-icu" (
    locale = 'sr'
    );

comment on collation pg_catalog."sr-x-icu" is 'Serbian';

alter collation pg_catalog."sr-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Cyrl-x-icu" (
    locale = 'sr-Cyrl'
    );

comment on collation pg_catalog."sr-Cyrl-x-icu" is 'Serbian (Cyrillic)';

alter collation pg_catalog."sr-Cyrl-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Cyrl-BA-x-icu" (
    locale = 'sr-Cyrl-BA'
    );

comment on collation pg_catalog."sr-Cyrl-BA-x-icu" is 'Serbian (Cyrillic, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Cyrl-BA-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Cyrl-ME-x-icu" (
    locale = 'sr-Cyrl-ME'
    );

comment on collation pg_catalog."sr-Cyrl-ME-x-icu" is 'Serbian (Cyrillic, Montenegro)';

alter collation pg_catalog."sr-Cyrl-ME-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Cyrl-RS-x-icu" (
    locale = 'sr-Cyrl-RS'
    );

comment on collation pg_catalog."sr-Cyrl-RS-x-icu" is 'Serbian (Cyrillic, Serbia)';

alter collation pg_catalog."sr-Cyrl-RS-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Cyrl-XK-x-icu" (
    locale = 'sr-Cyrl-XK'
    );

comment on collation pg_catalog."sr-Cyrl-XK-x-icu" is 'Serbian (Cyrillic, Kosovo)';

alter collation pg_catalog."sr-Cyrl-XK-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Latn-x-icu" (
    locale = 'sr-Latn'
    );

comment on collation pg_catalog."sr-Latn-x-icu" is 'Serbian (Latin)';

alter collation pg_catalog."sr-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Latn-BA-x-icu" (
    locale = 'sr-Latn-BA'
    );

comment on collation pg_catalog."sr-Latn-BA-x-icu" is 'Serbian (Latin, Bosnia & Herzegovina)';

alter collation pg_catalog."sr-Latn-BA-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Latn-ME-x-icu" (
    locale = 'sr-Latn-ME'
    );

comment on collation pg_catalog."sr-Latn-ME-x-icu" is 'Serbian (Latin, Montenegro)';

alter collation pg_catalog."sr-Latn-ME-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Latn-RS-x-icu" (
    locale = 'sr-Latn-RS'
    );

comment on collation pg_catalog."sr-Latn-RS-x-icu" is 'Serbian (Latin, Serbia)';

alter collation pg_catalog."sr-Latn-RS-x-icu" owner to "kim-uijin";

create collation pg_catalog."sr-Latn-XK-x-icu" (
    locale = 'sr-Latn-XK'
    );

comment on collation pg_catalog."sr-Latn-XK-x-icu" is 'Serbian (Latin, Kosovo)';

alter collation pg_catalog."sr-Latn-XK-x-icu" owner to "kim-uijin";

create collation pg_catalog."su-x-icu" (
    locale = 'su'
    );

comment on collation pg_catalog."su-x-icu" is 'Sundanese';

alter collation pg_catalog."su-x-icu" owner to "kim-uijin";

create collation pg_catalog."su-Latn-x-icu" (
    locale = 'su-Latn'
    );

comment on collation pg_catalog."su-Latn-x-icu" is 'Sundanese (Latin)';

alter collation pg_catalog."su-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."su-Latn-ID-x-icu" (
    locale = 'su-Latn-ID'
    );

comment on collation pg_catalog."su-Latn-ID-x-icu" is 'Sundanese (Latin, Indonesia)';

alter collation pg_catalog."su-Latn-ID-x-icu" owner to "kim-uijin";

create collation pg_catalog."sv-x-icu" (
    locale = 'sv'
    );

comment on collation pg_catalog."sv-x-icu" is 'Swedish';

alter collation pg_catalog."sv-x-icu" owner to "kim-uijin";

create collation pg_catalog."sv-AX-x-icu" (
    locale = 'sv-AX'
    );

alter collation pg_catalog."sv-AX-x-icu" owner to "kim-uijin";

create collation pg_catalog."sv-FI-x-icu" (
    locale = 'sv-FI'
    );

comment on collation pg_catalog."sv-FI-x-icu" is 'Swedish (Finland)';

alter collation pg_catalog."sv-FI-x-icu" owner to "kim-uijin";

create collation pg_catalog."sv-SE-x-icu" (
    locale = 'sv-SE'
    );

comment on collation pg_catalog."sv-SE-x-icu" is 'Swedish (Sweden)';

alter collation pg_catalog."sv-SE-x-icu" owner to "kim-uijin";

create collation pg_catalog."sw-x-icu" (
    locale = 'sw'
    );

comment on collation pg_catalog."sw-x-icu" is 'Swahili';

alter collation pg_catalog."sw-x-icu" owner to "kim-uijin";

create collation pg_catalog."sw-CD-x-icu" (
    locale = 'sw-CD'
    );

comment on collation pg_catalog."sw-CD-x-icu" is 'Swahili (Congo - Kinshasa)';

alter collation pg_catalog."sw-CD-x-icu" owner to "kim-uijin";

create collation pg_catalog."sw-KE-x-icu" (
    locale = 'sw-KE'
    );

comment on collation pg_catalog."sw-KE-x-icu" is 'Swahili (Kenya)';

alter collation pg_catalog."sw-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."sw-TZ-x-icu" (
    locale = 'sw-TZ'
    );

comment on collation pg_catalog."sw-TZ-x-icu" is 'Swahili (Tanzania)';

alter collation pg_catalog."sw-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."sw-UG-x-icu" (
    locale = 'sw-UG'
    );

comment on collation pg_catalog."sw-UG-x-icu" is 'Swahili (Uganda)';

alter collation pg_catalog."sw-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."syr-x-icu" (
    locale = 'syr'
    );

comment on collation pg_catalog."syr-x-icu" is 'Syriac';

alter collation pg_catalog."syr-x-icu" owner to "kim-uijin";

create collation pg_catalog."syr-IQ-x-icu" (
    locale = 'syr-IQ'
    );

comment on collation pg_catalog."syr-IQ-x-icu" is 'Syriac (Iraq)';

alter collation pg_catalog."syr-IQ-x-icu" owner to "kim-uijin";

create collation pg_catalog."syr-SY-x-icu" (
    locale = 'syr-SY'
    );

comment on collation pg_catalog."syr-SY-x-icu" is 'Syriac (Syria)';

alter collation pg_catalog."syr-SY-x-icu" owner to "kim-uijin";

create collation pg_catalog."szl-x-icu" (
    locale = 'szl'
    );

comment on collation pg_catalog."szl-x-icu" is 'Silesian';

alter collation pg_catalog."szl-x-icu" owner to "kim-uijin";

create collation pg_catalog."szl-PL-x-icu" (
    locale = 'szl-PL'
    );

comment on collation pg_catalog."szl-PL-x-icu" is 'Silesian (Poland)';

alter collation pg_catalog."szl-PL-x-icu" owner to "kim-uijin";

create collation pg_catalog."ta-x-icu" (
    locale = 'ta'
    );

comment on collation pg_catalog."ta-x-icu" is 'Tamil';

alter collation pg_catalog."ta-x-icu" owner to "kim-uijin";

create collation pg_catalog."ta-IN-x-icu" (
    locale = 'ta-IN'
    );

comment on collation pg_catalog."ta-IN-x-icu" is 'Tamil (India)';

alter collation pg_catalog."ta-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ta-LK-x-icu" (
    locale = 'ta-LK'
    );

comment on collation pg_catalog."ta-LK-x-icu" is 'Tamil (Sri Lanka)';

alter collation pg_catalog."ta-LK-x-icu" owner to "kim-uijin";

create collation pg_catalog."ta-MY-x-icu" (
    locale = 'ta-MY'
    );

comment on collation pg_catalog."ta-MY-x-icu" is 'Tamil (Malaysia)';

alter collation pg_catalog."ta-MY-x-icu" owner to "kim-uijin";

create collation pg_catalog."ta-SG-x-icu" (
    locale = 'ta-SG'
    );

comment on collation pg_catalog."ta-SG-x-icu" is 'Tamil (Singapore)';

alter collation pg_catalog."ta-SG-x-icu" owner to "kim-uijin";

create collation pg_catalog."te-x-icu" (
    locale = 'te'
    );

comment on collation pg_catalog."te-x-icu" is 'Telugu';

alter collation pg_catalog."te-x-icu" owner to "kim-uijin";

create collation pg_catalog."te-IN-x-icu" (
    locale = 'te-IN'
    );

comment on collation pg_catalog."te-IN-x-icu" is 'Telugu (India)';

alter collation pg_catalog."te-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."teo-x-icu" (
    locale = 'teo'
    );

comment on collation pg_catalog."teo-x-icu" is 'Teso';

alter collation pg_catalog."teo-x-icu" owner to "kim-uijin";

create collation pg_catalog."teo-KE-x-icu" (
    locale = 'teo-KE'
    );

comment on collation pg_catalog."teo-KE-x-icu" is 'Teso (Kenya)';

alter collation pg_catalog."teo-KE-x-icu" owner to "kim-uijin";

create collation pg_catalog."teo-UG-x-icu" (
    locale = 'teo-UG'
    );

comment on collation pg_catalog."teo-UG-x-icu" is 'Teso (Uganda)';

alter collation pg_catalog."teo-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."tg-x-icu" (
    locale = 'tg'
    );

comment on collation pg_catalog."tg-x-icu" is 'Tajik';

alter collation pg_catalog."tg-x-icu" owner to "kim-uijin";

create collation pg_catalog."tg-TJ-x-icu" (
    locale = 'tg-TJ'
    );

comment on collation pg_catalog."tg-TJ-x-icu" is 'Tajik (Tajikistan)';

alter collation pg_catalog."tg-TJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."th-x-icu" (
    locale = 'th'
    );

comment on collation pg_catalog."th-x-icu" is 'Thai';

alter collation pg_catalog."th-x-icu" owner to "kim-uijin";

create collation pg_catalog."th-TH-x-icu" (
    locale = 'th-TH'
    );

comment on collation pg_catalog."th-TH-x-icu" is 'Thai (Thailand)';

alter collation pg_catalog."th-TH-x-icu" owner to "kim-uijin";

create collation pg_catalog."ti-x-icu" (
    locale = 'ti'
    );

comment on collation pg_catalog."ti-x-icu" is 'Tigrinya';

alter collation pg_catalog."ti-x-icu" owner to "kim-uijin";

create collation pg_catalog."ti-ER-x-icu" (
    locale = 'ti-ER'
    );

comment on collation pg_catalog."ti-ER-x-icu" is 'Tigrinya (Eritrea)';

alter collation pg_catalog."ti-ER-x-icu" owner to "kim-uijin";

create collation pg_catalog."ti-ET-x-icu" (
    locale = 'ti-ET'
    );

comment on collation pg_catalog."ti-ET-x-icu" is 'Tigrinya (Ethiopia)';

alter collation pg_catalog."ti-ET-x-icu" owner to "kim-uijin";

create collation pg_catalog."tk-x-icu" (
    locale = 'tk'
    );

comment on collation pg_catalog."tk-x-icu" is 'Turkmen';

alter collation pg_catalog."tk-x-icu" owner to "kim-uijin";

create collation pg_catalog."tk-TM-x-icu" (
    locale = 'tk-TM'
    );

comment on collation pg_catalog."tk-TM-x-icu" is 'Turkmen (Turkmenistan)';

alter collation pg_catalog."tk-TM-x-icu" owner to "kim-uijin";

create collation pg_catalog."to-x-icu" (
    locale = 'to'
    );

comment on collation pg_catalog."to-x-icu" is 'Tongan';

alter collation pg_catalog."to-x-icu" owner to "kim-uijin";

create collation pg_catalog."to-TO-x-icu" (
    locale = 'to-TO'
    );

comment on collation pg_catalog."to-TO-x-icu" is 'Tongan (Tonga)';

alter collation pg_catalog."to-TO-x-icu" owner to "kim-uijin";

create collation pg_catalog."tok-x-icu" (
    locale = 'tok'
    );

comment on collation pg_catalog."tok-x-icu" is 'Toki Pona';

alter collation pg_catalog."tok-x-icu" owner to "kim-uijin";

create collation pg_catalog."tok-001-x-icu" (
    locale = 'tok-001'
    );

comment on collation pg_catalog."tok-001-x-icu" is 'Toki Pona (world)';

alter collation pg_catalog."tok-001-x-icu" owner to "kim-uijin";

create collation pg_catalog."tr-x-icu" (
    locale = 'tr'
    );

comment on collation pg_catalog."tr-x-icu" is 'Turkish';

alter collation pg_catalog."tr-x-icu" owner to "kim-uijin";

create collation pg_catalog."tr-CY-x-icu" (
    locale = 'tr-CY'
    );

comment on collation pg_catalog."tr-CY-x-icu" is 'Turkish (Cyprus)';

alter collation pg_catalog."tr-CY-x-icu" owner to "kim-uijin";

create collation pg_catalog."tr-TR-x-icu" (
    locale = 'tr-TR'
    );

alter collation pg_catalog."tr-TR-x-icu" owner to "kim-uijin";

create collation pg_catalog."tt-x-icu" (
    locale = 'tt'
    );

comment on collation pg_catalog."tt-x-icu" is 'Tatar';

alter collation pg_catalog."tt-x-icu" owner to "kim-uijin";

create collation pg_catalog."tt-RU-x-icu" (
    locale = 'tt-RU'
    );

comment on collation pg_catalog."tt-RU-x-icu" is 'Tatar (Russia)';

alter collation pg_catalog."tt-RU-x-icu" owner to "kim-uijin";

create collation pg_catalog."twq-x-icu" (
    locale = 'twq'
    );

comment on collation pg_catalog."twq-x-icu" is 'Tasawaq';

alter collation pg_catalog."twq-x-icu" owner to "kim-uijin";

create collation pg_catalog."twq-NE-x-icu" (
    locale = 'twq-NE'
    );

comment on collation pg_catalog."twq-NE-x-icu" is 'Tasawaq (Niger)';

alter collation pg_catalog."twq-NE-x-icu" owner to "kim-uijin";

create collation pg_catalog."tzm-x-icu" (
    locale = 'tzm'
    );

comment on collation pg_catalog."tzm-x-icu" is 'Central Atlas Tamazight';

alter collation pg_catalog."tzm-x-icu" owner to "kim-uijin";

create collation pg_catalog."tzm-MA-x-icu" (
    locale = 'tzm-MA'
    );

comment on collation pg_catalog."tzm-MA-x-icu" is 'Central Atlas Tamazight (Morocco)';

alter collation pg_catalog."tzm-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ug-x-icu" (
    locale = 'ug'
    );

comment on collation pg_catalog."ug-x-icu" is 'Uyghur';

alter collation pg_catalog."ug-x-icu" owner to "kim-uijin";

create collation pg_catalog."ug-CN-x-icu" (
    locale = 'ug-CN'
    );

comment on collation pg_catalog."ug-CN-x-icu" is 'Uyghur (China)';

alter collation pg_catalog."ug-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."uk-x-icu" (
    locale = 'uk'
    );

comment on collation pg_catalog."uk-x-icu" is 'Ukrainian';

alter collation pg_catalog."uk-x-icu" owner to "kim-uijin";

create collation pg_catalog."uk-UA-x-icu" (
    locale = 'uk-UA'
    );

comment on collation pg_catalog."uk-UA-x-icu" is 'Ukrainian (Ukraine)';

alter collation pg_catalog."uk-UA-x-icu" owner to "kim-uijin";

create collation pg_catalog."ur-x-icu" (
    locale = 'ur'
    );

comment on collation pg_catalog."ur-x-icu" is 'Urdu';

alter collation pg_catalog."ur-x-icu" owner to "kim-uijin";

create collation pg_catalog."ur-IN-x-icu" (
    locale = 'ur-IN'
    );

comment on collation pg_catalog."ur-IN-x-icu" is 'Urdu (India)';

alter collation pg_catalog."ur-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."ur-PK-x-icu" (
    locale = 'ur-PK'
    );

comment on collation pg_catalog."ur-PK-x-icu" is 'Urdu (Pakistan)';

alter collation pg_catalog."ur-PK-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-x-icu" (
    locale = 'uz'
    );

comment on collation pg_catalog."uz-x-icu" is 'Uzbek';

alter collation pg_catalog."uz-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Arab-x-icu" (
    locale = 'uz-Arab'
    );

comment on collation pg_catalog."uz-Arab-x-icu" is 'Uzbek (Arabic)';

alter collation pg_catalog."uz-Arab-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Arab-AF-x-icu" (
    locale = 'uz-Arab-AF'
    );

comment on collation pg_catalog."uz-Arab-AF-x-icu" is 'Uzbek (Arabic, Afghanistan)';

alter collation pg_catalog."uz-Arab-AF-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Cyrl-x-icu" (
    locale = 'uz-Cyrl'
    );

comment on collation pg_catalog."uz-Cyrl-x-icu" is 'Uzbek (Cyrillic)';

alter collation pg_catalog."uz-Cyrl-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Cyrl-UZ-x-icu" (
    locale = 'uz-Cyrl-UZ'
    );

comment on collation pg_catalog."uz-Cyrl-UZ-x-icu" is 'Uzbek (Cyrillic, Uzbekistan)';

alter collation pg_catalog."uz-Cyrl-UZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Latn-x-icu" (
    locale = 'uz-Latn'
    );

comment on collation pg_catalog."uz-Latn-x-icu" is 'Uzbek (Latin)';

alter collation pg_catalog."uz-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."uz-Latn-UZ-x-icu" (
    locale = 'uz-Latn-UZ'
    );

comment on collation pg_catalog."uz-Latn-UZ-x-icu" is 'Uzbek (Latin, Uzbekistan)';

alter collation pg_catalog."uz-Latn-UZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."vai-x-icu" (
    locale = 'vai'
    );

comment on collation pg_catalog."vai-x-icu" is 'Vai';

alter collation pg_catalog."vai-x-icu" owner to "kim-uijin";

create collation pg_catalog."vai-Latn-x-icu" (
    locale = 'vai-Latn'
    );

comment on collation pg_catalog."vai-Latn-x-icu" is 'Vai (Latin)';

alter collation pg_catalog."vai-Latn-x-icu" owner to "kim-uijin";

create collation pg_catalog."vai-Latn-LR-x-icu" (
    locale = 'vai-Latn-LR'
    );

comment on collation pg_catalog."vai-Latn-LR-x-icu" is 'Vai (Latin, Liberia)';

alter collation pg_catalog."vai-Latn-LR-x-icu" owner to "kim-uijin";

create collation pg_catalog."vai-Vaii-x-icu" (
    locale = 'vai-Vaii'
    );

comment on collation pg_catalog."vai-Vaii-x-icu" is 'Vai (Vai)';

alter collation pg_catalog."vai-Vaii-x-icu" owner to "kim-uijin";

create collation pg_catalog."vai-Vaii-LR-x-icu" (
    locale = 'vai-Vaii-LR'
    );

comment on collation pg_catalog."vai-Vaii-LR-x-icu" is 'Vai (Vai, Liberia)';

alter collation pg_catalog."vai-Vaii-LR-x-icu" owner to "kim-uijin";

create collation pg_catalog."vec-x-icu" (
    locale = 'vec'
    );

comment on collation pg_catalog."vec-x-icu" is 'Venetian';

alter collation pg_catalog."vec-x-icu" owner to "kim-uijin";

create collation pg_catalog."vec-IT-x-icu" (
    locale = 'vec-IT'
    );

comment on collation pg_catalog."vec-IT-x-icu" is 'Venetian (Italy)';

alter collation pg_catalog."vec-IT-x-icu" owner to "kim-uijin";

create collation pg_catalog."vi-x-icu" (
    locale = 'vi'
    );

comment on collation pg_catalog."vi-x-icu" is 'Vietnamese';

alter collation pg_catalog."vi-x-icu" owner to "kim-uijin";

create collation pg_catalog."vi-VN-x-icu" (
    locale = 'vi-VN'
    );

comment on collation pg_catalog."vi-VN-x-icu" is 'Vietnamese (Vietnam)';

alter collation pg_catalog."vi-VN-x-icu" owner to "kim-uijin";

create collation pg_catalog."vmw-x-icu" (
    locale = 'vmw'
    );

comment on collation pg_catalog."vmw-x-icu" is 'Makhuwa';

alter collation pg_catalog."vmw-x-icu" owner to "kim-uijin";

create collation pg_catalog."vmw-MZ-x-icu" (
    locale = 'vmw-MZ'
    );

comment on collation pg_catalog."vmw-MZ-x-icu" is 'Makhuwa (Mozambique)';

alter collation pg_catalog."vmw-MZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."vun-x-icu" (
    locale = 'vun'
    );

comment on collation pg_catalog."vun-x-icu" is 'Vunjo';

alter collation pg_catalog."vun-x-icu" owner to "kim-uijin";

create collation pg_catalog."vun-TZ-x-icu" (
    locale = 'vun-TZ'
    );

comment on collation pg_catalog."vun-TZ-x-icu" is 'Vunjo (Tanzania)';

alter collation pg_catalog."vun-TZ-x-icu" owner to "kim-uijin";

create collation pg_catalog."wae-x-icu" (
    locale = 'wae'
    );

comment on collation pg_catalog."wae-x-icu" is 'Walser';

alter collation pg_catalog."wae-x-icu" owner to "kim-uijin";

create collation pg_catalog."wae-CH-x-icu" (
    locale = 'wae-CH'
    );

comment on collation pg_catalog."wae-CH-x-icu" is 'Walser (Switzerland)';

alter collation pg_catalog."wae-CH-x-icu" owner to "kim-uijin";

create collation pg_catalog."wo-x-icu" (
    locale = 'wo'
    );

comment on collation pg_catalog."wo-x-icu" is 'Wolof';

alter collation pg_catalog."wo-x-icu" owner to "kim-uijin";

create collation pg_catalog."wo-SN-x-icu" (
    locale = 'wo-SN'
    );

comment on collation pg_catalog."wo-SN-x-icu" is 'Wolof (Senegal)';

alter collation pg_catalog."wo-SN-x-icu" owner to "kim-uijin";

create collation pg_catalog."xh-x-icu" (
    locale = 'xh'
    );

comment on collation pg_catalog."xh-x-icu" is 'Xhosa';

alter collation pg_catalog."xh-x-icu" owner to "kim-uijin";

create collation pg_catalog."xh-ZA-x-icu" (
    locale = 'xh-ZA'
    );

comment on collation pg_catalog."xh-ZA-x-icu" is 'Xhosa (South Africa)';

alter collation pg_catalog."xh-ZA-x-icu" owner to "kim-uijin";

create collation pg_catalog."xnr-x-icu" (
    locale = 'xnr'
    );

comment on collation pg_catalog."xnr-x-icu" is 'Kangri';

alter collation pg_catalog."xnr-x-icu" owner to "kim-uijin";

create collation pg_catalog."xnr-IN-x-icu" (
    locale = 'xnr-IN'
    );

comment on collation pg_catalog."xnr-IN-x-icu" is 'Kangri (India)';

alter collation pg_catalog."xnr-IN-x-icu" owner to "kim-uijin";

create collation pg_catalog."xog-x-icu" (
    locale = 'xog'
    );

comment on collation pg_catalog."xog-x-icu" is 'Soga';

alter collation pg_catalog."xog-x-icu" owner to "kim-uijin";

create collation pg_catalog."xog-UG-x-icu" (
    locale = 'xog-UG'
    );

comment on collation pg_catalog."xog-UG-x-icu" is 'Soga (Uganda)';

alter collation pg_catalog."xog-UG-x-icu" owner to "kim-uijin";

create collation pg_catalog."yav-x-icu" (
    locale = 'yav'
    );

comment on collation pg_catalog."yav-x-icu" is 'Yangben';

alter collation pg_catalog."yav-x-icu" owner to "kim-uijin";

create collation pg_catalog."yav-CM-x-icu" (
    locale = 'yav-CM'
    );

comment on collation pg_catalog."yav-CM-x-icu" is 'Yangben (Cameroon)';

alter collation pg_catalog."yav-CM-x-icu" owner to "kim-uijin";

create collation pg_catalog."yi-x-icu" (
    locale = 'yi'
    );

comment on collation pg_catalog."yi-x-icu" is 'Yiddish';

alter collation pg_catalog."yi-x-icu" owner to "kim-uijin";

create collation pg_catalog."yi-UA-x-icu" (
    locale = 'yi-UA'
    );

comment on collation pg_catalog."yi-UA-x-icu" is 'Yiddish (Ukraine)';

alter collation pg_catalog."yi-UA-x-icu" owner to "kim-uijin";

create collation pg_catalog."yo-x-icu" (
    locale = 'yo'
    );

comment on collation pg_catalog."yo-x-icu" is 'Yoruba';

alter collation pg_catalog."yo-x-icu" owner to "kim-uijin";

create collation pg_catalog."yo-BJ-x-icu" (
    locale = 'yo-BJ'
    );

comment on collation pg_catalog."yo-BJ-x-icu" is 'Yoruba (Benin)';

alter collation pg_catalog."yo-BJ-x-icu" owner to "kim-uijin";

create collation pg_catalog."yo-NG-x-icu" (
    locale = 'yo-NG'
    );

comment on collation pg_catalog."yo-NG-x-icu" is 'Yoruba (Nigeria)';

alter collation pg_catalog."yo-NG-x-icu" owner to "kim-uijin";

create collation pg_catalog."yrl-x-icu" (
    locale = 'yrl'
    );

comment on collation pg_catalog."yrl-x-icu" is 'Nheengatu';

alter collation pg_catalog."yrl-x-icu" owner to "kim-uijin";

create collation pg_catalog."yrl-BR-x-icu" (
    locale = 'yrl-BR'
    );

comment on collation pg_catalog."yrl-BR-x-icu" is 'Nheengatu (Brazil)';

alter collation pg_catalog."yrl-BR-x-icu" owner to "kim-uijin";

create collation pg_catalog."yrl-CO-x-icu" (
    locale = 'yrl-CO'
    );

comment on collation pg_catalog."yrl-CO-x-icu" is 'Nheengatu (Colombia)';

alter collation pg_catalog."yrl-CO-x-icu" owner to "kim-uijin";

create collation pg_catalog."yrl-VE-x-icu" (
    locale = 'yrl-VE'
    );

comment on collation pg_catalog."yrl-VE-x-icu" is 'Nheengatu (Venezuela)';

alter collation pg_catalog."yrl-VE-x-icu" owner to "kim-uijin";

create collation pg_catalog."yue-x-icu" (
    locale = 'yue'
    );

comment on collation pg_catalog."yue-x-icu" is 'Cantonese';

alter collation pg_catalog."yue-x-icu" owner to "kim-uijin";

create collation pg_catalog."yue-Hans-x-icu" (
    locale = 'yue-Hans'
    );

comment on collation pg_catalog."yue-Hans-x-icu" is 'Cantonese (Simplified)';

alter collation pg_catalog."yue-Hans-x-icu" owner to "kim-uijin";

create collation pg_catalog."yue-Hans-CN-x-icu" (
    locale = 'yue-Hans-CN'
    );

comment on collation pg_catalog."yue-Hans-CN-x-icu" is 'Cantonese (Simplified, China)';

alter collation pg_catalog."yue-Hans-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."yue-Hant-x-icu" (
    locale = 'yue-Hant'
    );

comment on collation pg_catalog."yue-Hant-x-icu" is 'Cantonese (Traditional)';

alter collation pg_catalog."yue-Hant-x-icu" owner to "kim-uijin";

create collation pg_catalog."yue-Hant-HK-x-icu" (
    locale = 'yue-Hant-HK'
    );

comment on collation pg_catalog."yue-Hant-HK-x-icu" is 'Cantonese (Traditional, Hong Kong SAR China)';

alter collation pg_catalog."yue-Hant-HK-x-icu" owner to "kim-uijin";

create collation pg_catalog."za-x-icu" (
    locale = 'za'
    );

comment on collation pg_catalog."za-x-icu" is 'Zhuang';

alter collation pg_catalog."za-x-icu" owner to "kim-uijin";

create collation pg_catalog."za-CN-x-icu" (
    locale = 'za-CN'
    );

comment on collation pg_catalog."za-CN-x-icu" is 'Zhuang (China)';

alter collation pg_catalog."za-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."zgh-x-icu" (
    locale = 'zgh'
    );

comment on collation pg_catalog."zgh-x-icu" is 'Standard Moroccan Tamazight';

alter collation pg_catalog."zgh-x-icu" owner to "kim-uijin";

create collation pg_catalog."zgh-MA-x-icu" (
    locale = 'zgh-MA'
    );

comment on collation pg_catalog."zgh-MA-x-icu" is 'Standard Moroccan Tamazight (Morocco)';

alter collation pg_catalog."zgh-MA-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-x-icu" (
    locale = 'zh'
    );

comment on collation pg_catalog."zh-x-icu" is 'Chinese';

alter collation pg_catalog."zh-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hans-x-icu" (
    locale = 'zh-Hans'
    );

comment on collation pg_catalog."zh-Hans-x-icu" is 'Chinese (Simplified)';

alter collation pg_catalog."zh-Hans-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hans-CN-x-icu" (
    locale = 'zh-Hans-CN'
    );

comment on collation pg_catalog."zh-Hans-CN-x-icu" is 'Chinese (Simplified, China)';

alter collation pg_catalog."zh-Hans-CN-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hans-HK-x-icu" (
    locale = 'zh-Hans-HK'
    );

comment on collation pg_catalog."zh-Hans-HK-x-icu" is 'Chinese (Simplified, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hans-HK-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hans-MO-x-icu" (
    locale = 'zh-Hans-MO'
    );

comment on collation pg_catalog."zh-Hans-MO-x-icu" is 'Chinese (Simplified, Macao SAR China)';

alter collation pg_catalog."zh-Hans-MO-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hans-SG-x-icu" (
    locale = 'zh-Hans-SG'
    );

comment on collation pg_catalog."zh-Hans-SG-x-icu" is 'Chinese (Simplified, Singapore)';

alter collation pg_catalog."zh-Hans-SG-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hant-x-icu" (
    locale = 'zh-Hant'
    );

comment on collation pg_catalog."zh-Hant-x-icu" is 'Chinese (Traditional)';

alter collation pg_catalog."zh-Hant-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hant-HK-x-icu" (
    locale = 'zh-Hant-HK'
    );

comment on collation pg_catalog."zh-Hant-HK-x-icu" is 'Chinese (Traditional, Hong Kong SAR China)';

alter collation pg_catalog."zh-Hant-HK-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hant-MO-x-icu" (
    locale = 'zh-Hant-MO'
    );

comment on collation pg_catalog."zh-Hant-MO-x-icu" is 'Chinese (Traditional, Macao SAR China)';

alter collation pg_catalog."zh-Hant-MO-x-icu" owner to "kim-uijin";

create collation pg_catalog."zh-Hant-TW-x-icu" (
    locale = 'zh-Hant-TW'
    );

comment on collation pg_catalog."zh-Hant-TW-x-icu" is 'Chinese (Traditional, Taiwan)';

alter collation pg_catalog."zh-Hant-TW-x-icu" owner to "kim-uijin";

create collation pg_catalog."zu-x-icu" (
    locale = 'zu'
    );

comment on collation pg_catalog."zu-x-icu" is 'Zulu';

alter collation pg_catalog."zu-x-icu" owner to "kim-uijin";

create collation pg_catalog."zu-ZA-x-icu" (
    locale = 'zu-ZA'
    );

comment on collation pg_catalog."zu-ZA-x-icu" is 'Zulu (South Africa)';

alter collation pg_catalog."zu-ZA-x-icu" owner to "kim-uijin";

create aggregate pg_catalog.avg(bigint) (
    sfunc = int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_avg,
    combinefunc = int8_avg_combine,
    serialfunc = int8_avg_serialize,
    deserialfunc = int8_avg_deserialize,
    parallel = safe,
    msfunc = int8_avg_accum,
    minvfunc = int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_avg
    );

comment on aggregate pg_catalog.avg(bigint) is 'the average (arithmetic mean) as numeric of all bigint values';

alter aggregate pg_catalog.avg(bigint) owner to "kim-uijin";

create aggregate pg_catalog.avg(integer) (
    sfunc = int4_avg_accum,
    stype = bigint[],
    finalfunc = int8_avg,
    combinefunc = int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = int4_avg_accum,
    minvfunc = int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(integer) is 'the average (arithmetic mean) as numeric of all integer values';

alter aggregate pg_catalog.avg(integer) owner to "kim-uijin";

create aggregate pg_catalog.avg(smallint) (
    sfunc = int2_avg_accum,
    stype = bigint[],
    finalfunc = int8_avg,
    combinefunc = int4_avg_combine,
    initcond = '{0,0}',
    parallel = safe,
    msfunc = int2_avg_accum,
    minvfunc = int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int8_avg,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.avg(smallint) is 'the average (arithmetic mean) as numeric of all smallint values';

alter aggregate pg_catalog.avg(smallint) owner to "kim-uijin";

create aggregate pg_catalog.avg(numeric) (
    sfunc = numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_avg,
    combinefunc = numeric_avg_combine,
    serialfunc = numeric_avg_serialize,
    deserialfunc = numeric_avg_deserialize,
    parallel = safe,
    msfunc = numeric_avg_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_avg
    );

comment on aggregate pg_catalog.avg(numeric) is 'the average (arithmetic mean) as numeric of all numeric values';

alter aggregate pg_catalog.avg(numeric) owner to "kim-uijin";

create aggregate pg_catalog.avg(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_avg,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(real) is 'the average (arithmetic mean) as float8 of all float4 values';

alter aggregate pg_catalog.avg(real) owner to "kim-uijin";

create aggregate pg_catalog.avg(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_avg,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.avg(double precision) is 'the average (arithmetic mean) as float8 of all float8 values';

alter aggregate pg_catalog.avg(double precision) owner to "kim-uijin";

create aggregate pg_catalog.avg(interval) (
    sfunc = interval_accum,
    stype = interval[],
    finalfunc = interval_avg,
    combinefunc = interval_combine,
    initcond = '{0 second,0 second}',
    parallel = safe,
    msfunc = interval_accum,
    minvfunc = interval_accum_inv,
    mstype = interval[],
    mfinalfunc = interval_avg,
    minitcond = '{0 second,0 second}'
    );

comment on aggregate pg_catalog.avg(interval) is 'the average (arithmetic mean) as interval of all interval values';

alter aggregate pg_catalog.avg(interval) owner to "kim-uijin";

create aggregate pg_catalog.sum(bigint) (
    sfunc = int8_avg_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_sum,
    combinefunc = int8_avg_combine,
    serialfunc = int8_avg_serialize,
    deserialfunc = int8_avg_deserialize,
    parallel = safe,
    msfunc = int8_avg_accum,
    minvfunc = int8_avg_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_sum
    );

comment on aggregate pg_catalog.sum(bigint) is 'sum as numeric across all bigint input values';

alter aggregate pg_catalog.sum(bigint) owner to "kim-uijin";

create aggregate pg_catalog.sum(integer) (
    sfunc = int4_sum,
    stype = bigint,
    combinefunc = int8pl,
    parallel = safe,
    msfunc = int4_avg_accum,
    minvfunc = int4_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(integer) is 'sum as bigint across all integer input values';

alter aggregate pg_catalog.sum(integer) owner to "kim-uijin";

create aggregate pg_catalog.sum(smallint) (
    sfunc = int2_sum,
    stype = bigint,
    combinefunc = int8pl,
    parallel = safe,
    msfunc = int2_avg_accum,
    minvfunc = int2_avg_accum_inv,
    mstype = bigint[],
    mfinalfunc = int2int4_sum,
    minitcond = '{0,0}'
    );

comment on aggregate pg_catalog.sum(smallint) is 'sum as bigint across all smallint input values';

alter aggregate pg_catalog.sum(smallint) owner to "kim-uijin";

create aggregate pg_catalog.sum(real) (
    sfunc = float4pl,
    stype = real,
    combinefunc = float4pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(real) is 'sum as float4 across all float4 input values';

alter aggregate pg_catalog.sum(real) owner to "kim-uijin";

create aggregate pg_catalog.sum(double precision) (
    sfunc = float8pl,
    stype = double precision,
    combinefunc = float8pl,
    parallel = safe
    );

comment on aggregate pg_catalog.sum(double precision) is 'sum as float8 across all float8 input values';

alter aggregate pg_catalog.sum(double precision) owner to "kim-uijin";

create aggregate pg_catalog.sum(money) (
    sfunc = cash_pl,
    stype = money,
    combinefunc = cash_pl,
    parallel = safe,
    msfunc = cash_pl,
    minvfunc = cash_mi,
    mstype = money
    );

comment on aggregate pg_catalog.sum(money) is 'sum as money across all money input values';

alter aggregate pg_catalog.sum(money) owner to "kim-uijin";

create aggregate pg_catalog.sum(interval) (
    sfunc = interval_pl,
    stype = interval,
    combinefunc = interval_pl,
    parallel = safe,
    msfunc = interval_pl,
    minvfunc = interval_mi,
    mstype = interval
    );

comment on aggregate pg_catalog.sum(interval) is 'sum as interval across all interval input values';

alter aggregate pg_catalog.sum(interval) owner to "kim-uijin";

create aggregate pg_catalog.sum(numeric) (
    sfunc = numeric_avg_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_sum,
    combinefunc = numeric_avg_combine,
    serialfunc = numeric_avg_serialize,
    deserialfunc = numeric_avg_deserialize,
    parallel = safe,
    msfunc = numeric_avg_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_sum
    );

comment on aggregate pg_catalog.sum(numeric) is 'sum as numeric across all numeric input values';

alter aggregate pg_catalog.sum(numeric) owner to "kim-uijin";

create aggregate pg_catalog.count("any") (
    sfunc = int8inc_any,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = int8inc_any,
    minvfunc = int8dec_any,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count("any") is 'number of input rows for which the input expression is not null';

alter aggregate pg_catalog.count("any") owner to "kim-uijin";

create aggregate pg_catalog.variance(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.variance(bigint) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(bigint) owner to "kim-uijin";

create aggregate pg_catalog.variance(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance(integer) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(integer) owner to "kim-uijin";

create aggregate pg_catalog.variance(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.variance(smallint) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(smallint) owner to "kim-uijin";

create aggregate pg_catalog.variance(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(real) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(real) owner to "kim-uijin";

create aggregate pg_catalog.variance(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.variance(double precision) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(double precision) owner to "kim-uijin";

create aggregate pg_catalog.variance(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.variance(numeric) is 'historical alias for var_samp';

alter aggregate pg_catalog.variance(numeric) owner to "kim-uijin";

create aggregate pg_catalog.stddev(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev(bigint) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(bigint) owner to "kim-uijin";

create aggregate pg_catalog.stddev(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev(integer) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(integer) owner to "kim-uijin";

create aggregate pg_catalog.stddev(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev(smallint) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(smallint) owner to "kim-uijin";

create aggregate pg_catalog.stddev(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(real) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(real) owner to "kim-uijin";

create aggregate pg_catalog.stddev(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev(double precision) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(double precision) owner to "kim-uijin";

create aggregate pg_catalog.stddev(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev(numeric) is 'historical alias for stddev_samp';

alter aggregate pg_catalog.stddev(numeric) owner to "kim-uijin";

create aggregate pg_catalog.bit_and(smallint) (
    sfunc = int2and,
    stype = smallint,
    combinefunc = int2and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(smallint) is 'bitwise-and smallint aggregate';

alter aggregate pg_catalog.bit_and(smallint) owner to "kim-uijin";

create aggregate pg_catalog.bit_or(smallint) (
    sfunc = int2or,
    stype = smallint,
    combinefunc = int2or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(smallint) is 'bitwise-or smallint aggregate';

alter aggregate pg_catalog.bit_or(smallint) owner to "kim-uijin";

create aggregate pg_catalog.bit_and(integer) (
    sfunc = int4and,
    stype = integer,
    combinefunc = int4and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(integer) is 'bitwise-and integer aggregate';

alter aggregate pg_catalog.bit_and(integer) owner to "kim-uijin";

create aggregate pg_catalog.bit_or(integer) (
    sfunc = int4or,
    stype = integer,
    combinefunc = int4or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(integer) is 'bitwise-or integer aggregate';

alter aggregate pg_catalog.bit_or(integer) owner to "kim-uijin";

create aggregate pg_catalog.bit_and(bigint) (
    sfunc = int8and,
    stype = bigint,
    combinefunc = int8and,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bigint) is 'bitwise-and bigint aggregate';

alter aggregate pg_catalog.bit_and(bigint) owner to "kim-uijin";

create aggregate pg_catalog.bit_or(bigint) (
    sfunc = int8or,
    stype = bigint,
    combinefunc = int8or,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bigint) is 'bitwise-or bigint aggregate';

alter aggregate pg_catalog.bit_or(bigint) owner to "kim-uijin";

create aggregate pg_catalog.bit_and(bit) (
    sfunc = bitand,
    stype = bit,
    combinefunc = bitand,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_and(bit) is 'bitwise-and bit aggregate';

alter aggregate pg_catalog.bit_and(bit) owner to "kim-uijin";

create aggregate pg_catalog.bit_or(bit) (
    sfunc = bitor,
    stype = bit,
    combinefunc = bitor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_or(bit) is 'bitwise-or bit aggregate';

alter aggregate pg_catalog.bit_or(bit) owner to "kim-uijin";

create aggregate pg_catalog.array_agg(anynonarray) (
    sfunc = array_agg_transfn,
    stype = internal,
    finalfunc = array_agg_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anynonarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anynonarray) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp(bigint) is 'sample variance of bigint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(bigint) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(integer) is 'sample variance of integer input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(integer) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_samp
    );

comment on aggregate pg_catalog.var_samp(smallint) is 'sample variance of smallint input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(smallint) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(real) is 'sample variance of float4 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(real) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_samp(double precision) is 'sample variance of float8 input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(double precision) owner to "kim-uijin";

create aggregate pg_catalog.var_samp(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_samp
    );

comment on aggregate pg_catalog.var_samp(numeric) is 'sample variance of numeric input values (square of the sample standard deviation)';

alter aggregate pg_catalog.var_samp(numeric) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(bigint) is 'sample standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_samp(bigint) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(integer) is 'sample standard deviation of integer input values';

alter aggregate pg_catalog.stddev_samp(integer) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_samp,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(smallint) is 'sample standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_samp(smallint) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(real) is 'sample standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_samp(real) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_samp,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_samp(double precision) is 'sample standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_samp(double precision) owner to "kim-uijin";

create aggregate pg_catalog.stddev_samp(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_samp,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_samp
    );

comment on aggregate pg_catalog.stddev_samp(numeric) is 'sample standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_samp(numeric) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop(bigint) is 'population variance of bigint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(bigint) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(integer) is 'population variance of integer input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(integer) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_var_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_var_pop
    );

comment on aggregate pg_catalog.var_pop(smallint) is 'population variance of smallint input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(smallint) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_var_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(real) is 'population variance of float4 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(real) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_var_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.var_pop(double precision) is 'population variance of float8 input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(double precision) owner to "kim-uijin";

create aggregate pg_catalog.var_pop(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_var_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_var_pop
    );

comment on aggregate pg_catalog.var_pop(numeric) is 'population variance of numeric input values (square of the population standard deviation)';

alter aggregate pg_catalog.var_pop(numeric) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(bigint) (
    sfunc = int8_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = int8_accum,
    minvfunc = int8_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(bigint) is 'population standard deviation of bigint input values';

alter aggregate pg_catalog.stddev_pop(bigint) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(integer) (
    sfunc = int4_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int4_accum,
    minvfunc = int4_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(integer) is 'population standard deviation of integer input values';

alter aggregate pg_catalog.stddev_pop(integer) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(smallint) (
    sfunc = int2_accum,
    stype = internal,
    sspace = 48,
    finalfunc = numeric_poly_stddev_pop,
    combinefunc = numeric_poly_combine,
    serialfunc = numeric_poly_serialize,
    deserialfunc = numeric_poly_deserialize,
    parallel = safe,
    msfunc = int2_accum,
    minvfunc = int2_accum_inv,
    mstype = internal,
    msspace = 48,
    mfinalfunc = numeric_poly_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(smallint) is 'population standard deviation of smallint input values';

alter aggregate pg_catalog.stddev_pop(smallint) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(real) (
    sfunc = float4_accum,
    stype = double precision[],
    finalfunc = float8_stddev_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(real) is 'population standard deviation of float4 input values';

alter aggregate pg_catalog.stddev_pop(real) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(double precision) (
    sfunc = float8_accum,
    stype = double precision[],
    finalfunc = float8_stddev_pop,
    combinefunc = float8_combine,
    initcond = '{0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.stddev_pop(double precision) is 'population standard deviation of float8 input values';

alter aggregate pg_catalog.stddev_pop(double precision) owner to "kim-uijin";

create aggregate pg_catalog.stddev_pop(numeric) (
    sfunc = numeric_accum,
    stype = internal,
    sspace = 128,
    finalfunc = numeric_stddev_pop,
    combinefunc = numeric_combine,
    serialfunc = numeric_serialize,
    deserialfunc = numeric_deserialize,
    parallel = safe,
    msfunc = numeric_accum,
    minvfunc = numeric_accum_inv,
    mstype = internal,
    msspace = 128,
    mfinalfunc = numeric_stddev_pop
    );

comment on aggregate pg_catalog.stddev_pop(numeric) is 'population standard deviation of numeric input values';

alter aggregate pg_catalog.stddev_pop(numeric) owner to "kim-uijin";

create aggregate pg_catalog.count(unknown) (
    sfunc = int8inc,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe,
    msfunc = int8inc,
    minvfunc = int8dec,
    mstype = bigint,
    minitcond = '0'
    );

comment on aggregate pg_catalog.count(unknown) is 'number of input rows';

alter aggregate pg_catalog.count(unknown) owner to "kim-uijin";

create aggregate pg_catalog.regr_count(double precision, double precision) (
    sfunc = int8inc_float8_float8,
    stype = bigint,
    combinefunc = int8pl,
    initcond = '0',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_count(double precision, double precision) is 'number of input rows in which both expressions are not null';

alter aggregate pg_catalog.regr_count(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_sxx(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_sxx,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxx(double precision, double precision) is 'sum of squares of the independent variable (sum(X^2) - sum(X)^2/N)';

alter aggregate pg_catalog.regr_sxx(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_syy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_syy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_syy(double precision, double precision) is 'sum of squares of the dependent variable (sum(Y^2) - sum(Y)^2/N)';

alter aggregate pg_catalog.regr_syy(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_sxy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_sxy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_sxy(double precision, double precision) is 'sum of products of independent times dependent variable (sum(X*Y) - sum(X) * sum(Y)/N)';

alter aggregate pg_catalog.regr_sxy(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_avgx(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_avgx,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgx(double precision, double precision) is 'average of the independent variable (sum(X)/N)';

alter aggregate pg_catalog.regr_avgx(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_avgy(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_avgy,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_avgy(double precision, double precision) is 'average of the dependent variable (sum(Y)/N)';

alter aggregate pg_catalog.regr_avgy(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_r2(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_r2,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_r2(double precision, double precision) is 'square of the correlation coefficient';

alter aggregate pg_catalog.regr_r2(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_slope(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_slope,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_slope(double precision, double precision) is 'slope of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_slope(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.regr_intercept(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_regr_intercept,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.regr_intercept(double precision, double precision) is 'y-intercept of the least-squares-fit linear equation determined by the (X, Y) pairs';

alter aggregate pg_catalog.regr_intercept(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.covar_pop(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_covar_pop,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_pop(double precision, double precision) is 'population covariance';

alter aggregate pg_catalog.covar_pop(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.covar_samp(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_covar_samp,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.covar_samp(double precision, double precision) is 'sample covariance';

alter aggregate pg_catalog.covar_samp(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.corr(double precision, double precision) (
    sfunc = float8_regr_accum,
    stype = double precision[],
    finalfunc = float8_corr,
    combinefunc = float8_regr_combine,
    initcond = '{0,0,0,0,0,0}',
    parallel = safe
    );

comment on aggregate pg_catalog.corr(double precision, double precision) is 'correlation coefficient';

alter aggregate pg_catalog.corr(double precision, double precision) owner to "kim-uijin";

create aggregate pg_catalog.xmlagg(xml) (
    sfunc = xmlconcat2,
    stype = xml,
    parallel = safe
    );

comment on aggregate pg_catalog.xmlagg(xml) is 'concatenate XML values';

alter aggregate pg_catalog.xmlagg(xml) owner to "kim-uijin";

create aggregate pg_catalog.json_agg(anyelement) (
    sfunc = json_agg_transfn,
    stype = internal,
    finalfunc = json_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_agg(anyelement) is 'aggregate input into json';

alter aggregate pg_catalog.json_agg(anyelement) owner to "kim-uijin";

create aggregate pg_catalog.json_object_agg("any", "any") (
    sfunc = json_object_agg_transfn,
    stype = internal,
    finalfunc = json_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.json_object_agg("any", "any") is 'aggregate input into a json object';

alter aggregate pg_catalog.json_object_agg("any", "any") owner to "kim-uijin";

create aggregate pg_catalog.jsonb_agg(anyelement) (
    sfunc = jsonb_agg_transfn,
    stype = internal,
    finalfunc = jsonb_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_agg(anyelement) is 'aggregate input into jsonb';

alter aggregate pg_catalog.jsonb_agg(anyelement) owner to "kim-uijin";

create aggregate pg_catalog.jsonb_object_agg("any", "any") (
    sfunc = jsonb_object_agg_transfn,
    stype = internal,
    finalfunc = jsonb_object_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.jsonb_object_agg("any", "any") is 'aggregate inputs into jsonb object';

alter aggregate pg_catalog.jsonb_object_agg("any", "any") owner to "kim-uijin";

create aggregate pg_catalog.string_agg(text, text) (
    sfunc = string_agg_transfn,
    stype = internal,
    finalfunc = string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg(text, text) is 'concatenate aggregate input into a string';

alter aggregate pg_catalog.string_agg(text, text) owner to "kim-uijin";

create aggregate pg_catalog.string_agg(bytea, bytea) (
    sfunc = bytea_string_agg_transfn,
    stype = internal,
    finalfunc = bytea_string_agg_finalfn,
    parallel = safe
    );

comment on aggregate pg_catalog.string_agg(bytea, bytea) is 'concatenate aggregate input into a bytea';

alter aggregate pg_catalog.string_agg(bytea, bytea) owner to "kim-uijin";

create aggregate pg_catalog.percentile_disc(double precision order by anyelement) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc(double precision, anyelement) is 'discrete percentile';

alter aggregate pg_catalog.percentile_disc(double precision order by anyelement) owner to "kim-uijin";

create aggregate pg_catalog.percentile_cont(double precision order by double precision) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_float8_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision, double precision) is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by double precision) owner to "kim-uijin";

create aggregate pg_catalog.percentile_cont(double precision order by interval) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_interval_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision, interval) is 'continuous distribution percentile';

alter aggregate pg_catalog.percentile_cont(double precision order by interval) owner to "kim-uijin";

create aggregate pg_catalog.percentile_disc(double precision[] order by anyelement) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_disc_multi_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_disc(double precision[], anyelement) is 'multiple discrete percentiles';

alter aggregate pg_catalog.percentile_disc(double precision[] order by anyelement) owner to "kim-uijin";

create aggregate pg_catalog.percentile_cont(double precision[] order by double precision) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_float8_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision[], double precision) is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision[] order by double precision) owner to "kim-uijin";

create aggregate pg_catalog.percentile_cont(double precision[] order by interval) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = percentile_cont_interval_multi_final,
    parallel = safe
    );

comment on aggregate pg_catalog.percentile_cont(double precision[], interval) is 'multiple continuous percentiles';

alter aggregate pg_catalog.percentile_cont(double precision[] order by interval) owner to "kim-uijin";

create aggregate pg_catalog.mode( order by anyelement) (
    sfunc = ordered_set_transition,
    stype = internal,
    finalfunc = mode_final,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.mode(anyelement) is 'most common value';

alter aggregate pg_catalog.mode( order by anyelement) owner to "kim-uijin";

create aggregate pg_catalog.rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.rank("any") is 'rank of hypothetical row';

alter aggregate pg_catalog.rank("any") owner to "kim-uijin";

create aggregate pg_catalog.percent_rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = percent_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.percent_rank("any") is 'fractional rank of hypothetical row';

alter aggregate pg_catalog.percent_rank("any") owner to "kim-uijin";

create aggregate pg_catalog.cume_dist("any") (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = cume_dist_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.cume_dist("any") is 'cumulative distribution of hypothetical row';

alter aggregate pg_catalog.cume_dist("any") owner to "kim-uijin";

create aggregate pg_catalog.dense_rank("any") (
    sfunc = ordered_set_transition_multi,
    stype = internal,
    finalfunc = dense_rank_final,
    finalfunc_extra,
    parallel = safe,
    hypothetical
    );

comment on aggregate pg_catalog.dense_rank("any") is 'rank of hypothetical row without gaps';

alter aggregate pg_catalog.dense_rank("any") owner to "kim-uijin";

create aggregate pg_catalog.array_agg(anyarray) (
    sfunc = array_agg_array_transfn,
    stype = internal,
    finalfunc = array_agg_array_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.array_agg(anyarray) is 'concatenate aggregate input into an array';

alter aggregate pg_catalog.array_agg(anyarray) owner to "kim-uijin";

create aggregate pg_catalog.range_agg(anyrange) (
    sfunc = range_agg_transfn,
    stype = internal,
    finalfunc = range_agg_finalfn,
    finalfunc_extra,
    parallel = safe
    );

comment on aggregate pg_catalog.range_agg(anyrange) is 'combine aggregate input into a multirange';

alter aggregate pg_catalog.range_agg(anyrange) owner to "kim-uijin";

create aggregate pg_catalog.range_intersect_agg(anymultirange) (
    sfunc = multirange_intersect_agg_transfn,
    stype = anymultirange,
    combinefunc = multirange_intersect_agg_transfn,
    parallel = safe
    );

comment on aggregate pg_catalog.range_intersect_agg(anymultirange) is 'range aggregate by intersecting';

alter aggregate pg_catalog.range_intersect_agg(anymultirange) owner to "kim-uijin";

create aggregate pg_catalog.range_intersect_agg(anyrange) (
    sfunc = range_intersect_agg_transfn,
    stype = anyrange,
    combinefunc = range_intersect_agg_transfn,
    parallel = safe
    );

comment on aggregate pg_catalog.range_intersect_agg(anyrange) is 'range aggregate by intersecting';

alter aggregate pg_catalog.range_intersect_agg(anyrange) owner to "kim-uijin";

create aggregate pg_catalog.bit_xor(smallint) (
    sfunc = int2xor,
    stype = smallint,
    combinefunc = int2xor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_xor(smallint) is 'bitwise-xor smallint aggregate';

alter aggregate pg_catalog.bit_xor(smallint) owner to "kim-uijin";

create aggregate pg_catalog.bit_xor(integer) (
    sfunc = int4xor,
    stype = integer,
    combinefunc = int4xor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_xor(integer) is 'bitwise-xor integer aggregate';

alter aggregate pg_catalog.bit_xor(integer) owner to "kim-uijin";

create aggregate pg_catalog.bit_xor(bigint) (
    sfunc = int8xor,
    stype = bigint,
    combinefunc = int8xor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_xor(bigint) is 'bitwise-xor bigint aggregate';

alter aggregate pg_catalog.bit_xor(bigint) owner to "kim-uijin";

create aggregate pg_catalog.bit_xor(bit) (
    sfunc = bitxor,
    stype = bit,
    combinefunc = bitxor,
    parallel = safe
    );

comment on aggregate pg_catalog.bit_xor(bit) is 'bitwise-xor bit aggregate';

alter aggregate pg_catalog.bit_xor(bit) owner to "kim-uijin";

create operator family pg_catalog.array_ops using btree;

alter operator family pg_catalog.array_ops using btree add
    function 1(anyarray, anyarray) pg_catalog.btarraycmp(anyarray, anyarray);

alter operator family pg_catalog.array_ops using btree owner to "kim-uijin";

create operator class pg_catalog.array_ops default for type anyarray using btree as
    operator 2 pg_catalog.<=(anyarray, anyarray),
    operator 1 pg_catalog.<(anyarray, anyarray),
    operator 5 pg_catalog.>(anyarray, anyarray),
    operator 4 pg_catalog.>=(anyarray, anyarray),
    operator 3 pg_catalog.=(anyarray, anyarray);

alter operator class pg_catalog.array_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bit_ops using btree;

alter operator family pg_catalog.bit_ops using btree add
    function 1(bit, bit) pg_catalog.bitcmp(bit, bit),
    function 4(bit, bit) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.bit_ops using btree owner to "kim-uijin";

create operator class pg_catalog.bit_ops default for type bit using btree as
    operator 3 pg_catalog.=(bit, bit),
    operator 4 pg_catalog.>=(bit, bit),
    operator 5 pg_catalog.>(bit, bit),
    operator 1 pg_catalog.<(bit, bit),
    operator 2 pg_catalog.<=(bit, bit);

alter operator class pg_catalog.bit_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bool_ops using btree;

alter operator family pg_catalog.bool_ops using btree add
    function 1(boolean, boolean) pg_catalog.btboolcmp(boolean, boolean),
    function 4(boolean, boolean) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.bool_ops using btree owner to "kim-uijin";

create operator class pg_catalog.bool_ops default for type boolean using btree as
    operator 3 pg_catalog.=(boolean, boolean),
    operator 2 pg_catalog.<=(boolean, boolean),
    operator 1 pg_catalog.<(boolean, boolean),
    operator 5 pg_catalog.>(boolean, boolean),
    operator 4 pg_catalog.>=(boolean, boolean);

alter operator class pg_catalog.bool_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bpchar_ops using btree;

alter operator family pg_catalog.bpchar_ops using btree add
    function 1(character, character) pg_catalog.bpcharcmp(char, char),
    function 2(character, character) pg_catalog.bpchar_sortsupport(internal),
    function 4(character, character) pg_catalog.btvarstrequalimage(oid);

alter operator family pg_catalog.bpchar_ops using btree owner to "kim-uijin";

create operator class pg_catalog.bpchar_ops default for type character using btree as
    operator 1 pg_catalog.<(char, char),
    operator 2 pg_catalog.<=(char, char),
    operator 3 pg_catalog.=(char, char),
    operator 5 pg_catalog.>(char, char),
    operator 4 pg_catalog.>=(char, char);

alter operator class pg_catalog.bpchar_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bpchar_ops using hash;

alter operator family pg_catalog.bpchar_ops using hash add
    function 2(character, character) pg_catalog.hashbpcharextended(char, bigint),
    function 1(character, character) pg_catalog.hashbpchar(char);

alter operator family pg_catalog.bpchar_ops using hash owner to "kim-uijin";

create operator class pg_catalog.bpchar_ops default for type character using hash as
    operator 1 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_ops using hash owner to "kim-uijin";

create operator family pg_catalog.bytea_ops using btree;

alter operator family pg_catalog.bytea_ops using btree add
    function 2(bytea, bytea) pg_catalog.bytea_sortsupport(internal),
    function 1(bytea, bytea) pg_catalog.byteacmp(bytea, bytea),
    function 4(bytea, bytea) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.bytea_ops using btree owner to "kim-uijin";

create operator class pg_catalog.bytea_ops default for type bytea using btree as
    operator 5 pg_catalog.>(bytea, bytea),
    operator 1 pg_catalog.<(bytea, bytea),
    operator 2 pg_catalog.<=(bytea, bytea),
    operator 3 pg_catalog.=(bytea, bytea),
    operator 4 pg_catalog.>=(bytea, bytea);

alter operator class pg_catalog.bytea_ops using btree owner to "kim-uijin";

create operator family pg_catalog.char_ops using btree;

alter operator family pg_catalog.char_ops using btree add
    function 1("char", "char") pg_catalog.btcharcmp("char", "char"),
    function 4("char", "char") pg_catalog.btequalimage(oid);

alter operator family pg_catalog.char_ops using btree owner to "kim-uijin";

create operator class pg_catalog.char_ops default for type "char" using btree as
    operator 4 pg_catalog.>=("char", "char"),
    operator 2 pg_catalog.<=("char", "char"),
    operator 1 pg_catalog.<("char", "char"),
    operator 3 pg_catalog.=("char", "char"),
    operator 5 pg_catalog.>("char", "char");

alter operator class pg_catalog.char_ops using btree owner to "kim-uijin";

create operator family pg_catalog.char_ops using hash;

alter operator family pg_catalog.char_ops using hash add
    function 1("char", "char") pg_catalog.hashchar("char"),
    function 2("char", "char") pg_catalog.hashcharextended("char", bigint);

alter operator family pg_catalog.char_ops using hash owner to "kim-uijin";

create operator class pg_catalog.char_ops default for type "char" using hash as
    operator 1 pg_catalog.=("char", "char");

alter operator class pg_catalog.char_ops using hash owner to "kim-uijin";

create operator family pg_catalog.datetime_ops using btree;

alter operator family pg_catalog.datetime_ops using btree add
    function 1(timestamp with time zone, date) pg_catalog.timestamptz_cmp_date(timestamp with time zone, date),
    function 4(timestamp without time zone, timestamp without time zone) pg_catalog.btequalimage(oid),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_sortsupport(internal),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_cmp(timestamp, timestamp),
    function 1(date, timestamp without time zone) pg_catalog.date_cmp_timestamp(date, timestamp),
    function 4(date, date) pg_catalog.btequalimage(oid),
    function 2(date, date) pg_catalog.date_sortsupport(internal),
    function 1(date, date) pg_catalog.date_cmp(date, date),
    function 1(timestamp without time zone, timestamp with time zone) pg_catalog.timestamp_cmp_timestamptz(timestamp, timestamp with time zone),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.timestamptz_cmp(timestamp with time zone, timestamp with time zone),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_sortsupport(internal),
    function 4(timestamp with time zone, timestamp with time zone) pg_catalog.btequalimage(oid),
    function 1(timestamp without time zone, date) pg_catalog.timestamp_cmp_date(timestamp, date),
    function 1(timestamp with time zone, timestamp without time zone) pg_catalog.timestamptz_cmp_timestamp(timestamp with time zone, timestamp),
    function 3(date, interval) pg_catalog.in_range(date, date, interval, boolean, boolean),
    function 3(timestamp without time zone, interval) pg_catalog.in_range(timestamp, timestamp, interval, boolean, boolean),
    function 3(timestamp with time zone, interval) pg_catalog.in_range(timestamp with time zone, timestamp with time zone, interval, boolean, boolean),
    function 1(date, timestamp with time zone) pg_catalog.date_cmp_timestamptz(date, timestamp with time zone);

alter operator family pg_catalog.datetime_ops using btree owner to "kim-uijin";

create operator class pg_catalog.date_ops default for type date using btree family pg_catalog.datetime_ops as
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 1 pg_catalog.<(timestamp, date),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp),
    operator 5 pg_catalog.>(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 1 pg_catalog.<(date, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp);

alter operator class pg_catalog.date_ops using btree owner to "kim-uijin";

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using btree family pg_catalog.datetime_ops as
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 1 pg_catalog.<(timestamp, date),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp),
    operator 5 pg_catalog.>(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 1 pg_catalog.<(date, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp);

alter operator class pg_catalog.timestamptz_ops using btree owner to "kim-uijin";

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using btree family pg_catalog.datetime_ops as
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, date),
    operator 4 pg_catalog.>=(timestamp, date),
    operator 3 pg_catalog.=(timestamp, date),
    operator 2 pg_catalog.<=(timestamp, date),
    operator 1 pg_catalog.<(timestamp, date),
    operator 5 pg_catalog.>(timestamp, timestamp),
    operator 4 pg_catalog.>=(timestamp, timestamp),
    operator 3 pg_catalog.=(timestamp, timestamp),
    operator 2 pg_catalog.<=(timestamp, timestamp),
    operator 1 pg_catalog.<(timestamp, timestamp),
    operator 5 pg_catalog.>(date, timestamp with time zone),
    operator 4 pg_catalog.>=(date, timestamp with time zone),
    operator 3 pg_catalog.=(date, timestamp with time zone),
    operator 2 pg_catalog.<=(date, timestamp with time zone),
    operator 1 pg_catalog.<(date, timestamp with time zone),
    operator 5 pg_catalog.>(date, timestamp),
    operator 4 pg_catalog.>=(date, timestamp),
    operator 3 pg_catalog.=(date, timestamp),
    operator 2 pg_catalog.<=(date, timestamp),
    operator 1 pg_catalog.<(date, timestamp),
    operator 5 pg_catalog.>(date, date),
    operator 4 pg_catalog.>=(date, date),
    operator 3 pg_catalog.=(date, date),
    operator 2 pg_catalog.<=(date, date),
    operator 1 pg_catalog.<(date, date),
    operator 5 pg_catalog.>(timestamp with time zone, date),
    operator 4 pg_catalog.>=(timestamp with time zone, date),
    operator 3 pg_catalog.=(timestamp with time zone, date),
    operator 2 pg_catalog.<=(timestamp with time zone, date),
    operator 1 pg_catalog.<(timestamp with time zone, date),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp, timestamp with time zone),
    operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
    operator 3 pg_catalog.=(timestamp, timestamp with time zone),
    operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
    operator 5 pg_catalog.>(timestamp with time zone, timestamp),
    operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
    operator 3 pg_catalog.=(timestamp with time zone, timestamp),
    operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
    operator 1 pg_catalog.<(timestamp with time zone, timestamp);

alter operator class pg_catalog.timestamp_ops using btree owner to "kim-uijin";

create operator family pg_catalog.date_ops using hash;

alter operator family pg_catalog.date_ops using hash add
    function 1(date, date) pg_catalog.hashint4(integer),
    function 2(date, date) pg_catalog.hashint4extended(integer, bigint);

alter operator family pg_catalog.date_ops using hash owner to "kim-uijin";

create operator class pg_catalog.date_ops default for type date using hash as
    operator 1 pg_catalog.=(date, date);

alter operator class pg_catalog.date_ops using hash owner to "kim-uijin";

create operator family pg_catalog.array_ops using hash;

alter operator family pg_catalog.array_ops using hash add
    function 1(anyarray, anyarray) pg_catalog.hash_array(anyarray),
    function 2(anyarray, anyarray) pg_catalog.hash_array_extended(anyarray, bigint);

alter operator family pg_catalog.array_ops using hash owner to "kim-uijin";

create operator class pg_catalog.array_ops default for type anyarray using hash as
    operator 1 pg_catalog.=(anyarray, anyarray);

alter operator class pg_catalog.array_ops using hash owner to "kim-uijin";

create operator family pg_catalog.point_ops using gist;

alter operator family pg_catalog.point_ops using gist add
    function 5(point, point) pg_catalog.gist_box_penalty(internal, internal, internal),
    function 1(point, point) pg_catalog.gist_point_consistent(internal, point, smallint, oid, internal),
    function 2(point, point) pg_catalog.gist_box_union(internal, internal),
    function 3(point, point) pg_catalog.gist_point_compress(internal),
    function 6(point, point) pg_catalog.gist_box_picksplit(internal, internal),
    function 7(point, point) pg_catalog.gist_box_same(box, box, internal),
    function 8(point, point) pg_catalog.gist_point_distance(internal, point, smallint, oid, internal),
    function 9(point, point) pg_catalog.gist_point_fetch(internal),
    function 11(point, point) pg_catalog.gist_point_sortsupport(internal);

alter operator family pg_catalog.point_ops using gist owner to "kim-uijin";

create operator class pg_catalog.point_ops default for type point using gist as storage box operator 30 pg_catalog.>^(point, point),
	operator 1 pg_catalog.<<(point, point),
	operator 5 pg_catalog.>>(point, point),
	operator 6 pg_catalog.~=(point, point),
	operator 15 pg_catalog.<->(point, point) for order by float_ops,
	operator 28 pg_catalog.<@(point, box),
	operator 29 pg_catalog.<^(point, point),
	operator 48 pg_catalog.<@(point, polygon),
	operator 68 pg_catalog.<@(point, circle),
	operator 10 pg_catalog.<<|(point, point),
	operator 11 pg_catalog.|>>(point, point);

alter operator class pg_catalog.point_ops using gist owner to "kim-uijin";

create operator family pg_catalog.float_ops using btree;

alter operator family pg_catalog.float_ops using btree add
    function 1(real, double precision) pg_catalog.btfloat48cmp(real, double precision),
    function 2(real, real) pg_catalog.btfloat4sortsupport(internal),
    function 1(real, real) pg_catalog.btfloat4cmp(real, real),
    function 3(real, double precision) pg_catalog.in_range(real, real, double precision, boolean, boolean),
    function 3(double precision, double precision) pg_catalog.in_range(double precision, double precision, double precision, boolean, boolean),
    function 1(double precision, real) pg_catalog.btfloat84cmp(double precision, real),
    function 2(double precision, double precision) pg_catalog.btfloat8sortsupport(internal),
    function 1(double precision, double precision) pg_catalog.btfloat8cmp(double precision, double precision);

alter operator family pg_catalog.float_ops using btree owner to "kim-uijin";

create operator class pg_catalog.float8_ops default for type double precision using btree family pg_catalog.float_ops as
    operator 3 pg_catalog.=(double precision, real),
    operator 1 pg_catalog.<(real, real),
    operator 2 pg_catalog.<=(real, real),
    operator 3 pg_catalog.=(real, real),
    operator 4 pg_catalog.>=(real, real),
    operator 5 pg_catalog.>(real, real),
    operator 1 pg_catalog.<(real, double precision),
    operator 2 pg_catalog.<=(real, double precision),
    operator 3 pg_catalog.=(real, double precision),
    operator 4 pg_catalog.>=(real, double precision),
    operator 5 pg_catalog.>(real, double precision),
    operator 1 pg_catalog.<(double precision, double precision),
    operator 2 pg_catalog.<=(double precision, double precision),
    operator 3 pg_catalog.=(double precision, double precision),
    operator 4 pg_catalog.>=(double precision, double precision),
    operator 5 pg_catalog.>(double precision, double precision),
    operator 1 pg_catalog.<(double precision, real),
    operator 2 pg_catalog.<=(double precision, real),
    operator 4 pg_catalog.>=(double precision, real),
    operator 5 pg_catalog.>(double precision, real);

alter operator class pg_catalog.float8_ops using btree owner to "kim-uijin";

create operator class pg_catalog.float4_ops default for type real using btree family pg_catalog.float_ops as
    operator 3 pg_catalog.=(double precision, real),
    operator 1 pg_catalog.<(real, real),
    operator 2 pg_catalog.<=(real, real),
    operator 3 pg_catalog.=(real, real),
    operator 4 pg_catalog.>=(real, real),
    operator 5 pg_catalog.>(real, real),
    operator 1 pg_catalog.<(real, double precision),
    operator 2 pg_catalog.<=(real, double precision),
    operator 3 pg_catalog.=(real, double precision),
    operator 4 pg_catalog.>=(real, double precision),
    operator 5 pg_catalog.>(real, double precision),
    operator 1 pg_catalog.<(double precision, double precision),
    operator 2 pg_catalog.<=(double precision, double precision),
    operator 3 pg_catalog.=(double precision, double precision),
    operator 4 pg_catalog.>=(double precision, double precision),
    operator 5 pg_catalog.>(double precision, double precision),
    operator 1 pg_catalog.<(double precision, real),
    operator 2 pg_catalog.<=(double precision, real),
    operator 4 pg_catalog.>=(double precision, real),
    operator 5 pg_catalog.>(double precision, real);

alter operator class pg_catalog.float4_ops using btree owner to "kim-uijin";

create operator family pg_catalog.float_ops using hash;

alter operator family pg_catalog.float_ops using hash add
    function 2(double precision, double precision) pg_catalog.hashfloat8extended(double precision, bigint),
    function 2(real, real) pg_catalog.hashfloat4extended(real, bigint),
    function 1(double precision, double precision) pg_catalog.hashfloat8(double precision),
    function 1(real, real) pg_catalog.hashfloat4(real);

alter operator family pg_catalog.float_ops using hash owner to "kim-uijin";

create operator class pg_catalog.float4_ops default for type real using hash family pg_catalog.float_ops as
    operator 1 pg_catalog.=(real, real),
    operator 1 pg_catalog.=(double precision, double precision),
    operator 1 pg_catalog.=(real, double precision),
    operator 1 pg_catalog.=(double precision, real);

alter operator class pg_catalog.float4_ops using hash owner to "kim-uijin";

create operator class pg_catalog.float8_ops default for type double precision using hash family pg_catalog.float_ops as
    operator 1 pg_catalog.=(real, real),
    operator 1 pg_catalog.=(double precision, double precision),
    operator 1 pg_catalog.=(real, double precision),
    operator 1 pg_catalog.=(double precision, real);

alter operator class pg_catalog.float8_ops using hash owner to "kim-uijin";

create operator family pg_catalog.network_ops using btree;

alter operator family pg_catalog.network_ops using btree add
    function 4(inet, inet) pg_catalog.btequalimage(oid),
    function 2(inet, inet) pg_catalog.network_sortsupport(internal),
    function 1(inet, inet) pg_catalog.network_cmp(inet, inet);

alter operator family pg_catalog.network_ops using btree owner to "kim-uijin";

create operator class pg_catalog.cidr_ops for type inet using btree family pg_catalog.network_ops as
    operator 1 pg_catalog.<(inet, inet),
    operator 2 pg_catalog.<=(inet, inet),
    operator 3 pg_catalog.=(inet, inet),
    operator 4 pg_catalog.>=(inet, inet),
    operator 5 pg_catalog.>(inet, inet);

alter operator class pg_catalog.cidr_ops using btree owner to "kim-uijin";

create operator class pg_catalog.inet_ops default for type inet using btree family pg_catalog.network_ops as
    operator 1 pg_catalog.<(inet, inet),
    operator 2 pg_catalog.<=(inet, inet),
    operator 3 pg_catalog.=(inet, inet),
    operator 4 pg_catalog.>=(inet, inet),
    operator 5 pg_catalog.>(inet, inet);

alter operator class pg_catalog.inet_ops using btree owner to "kim-uijin";

create operator family pg_catalog.network_ops using hash;

alter operator family pg_catalog.network_ops using hash add
    function 2(inet, inet) pg_catalog.hashinetextended(inet, bigint),
    function 1(inet, inet) pg_catalog.hashinet(inet);

alter operator family pg_catalog.network_ops using hash owner to "kim-uijin";

create operator class pg_catalog.cidr_ops for type inet using hash family pg_catalog.network_ops as
    operator 1 pg_catalog.=(inet, inet);

alter operator class pg_catalog.cidr_ops using hash owner to "kim-uijin";

create operator class pg_catalog.inet_ops default for type inet using hash family pg_catalog.network_ops as
    operator 1 pg_catalog.=(inet, inet);

alter operator class pg_catalog.inet_ops using hash owner to "kim-uijin";

create operator family pg_catalog.integer_ops using btree;

alter operator family pg_catalog.integer_ops using btree add
    function 3(bigint, bigint) pg_catalog.in_range(bigint, bigint, bigint, boolean, boolean),
    function 1(smallint, smallint) pg_catalog.btint2cmp(smallint, smallint),
    function 2(smallint, smallint) pg_catalog.btint2sortsupport(internal),
    function 4(smallint, smallint) pg_catalog.btequalimage(oid),
    function 1(smallint, integer) pg_catalog.btint24cmp(smallint, integer),
    function 1(smallint, bigint) pg_catalog.btint28cmp(smallint, bigint),
    function 3(smallint, bigint) pg_catalog.in_range(smallint, smallint, bigint, boolean, boolean),
    function 3(smallint, integer) pg_catalog.in_range(smallint, smallint, integer, boolean, boolean),
    function 3(smallint, smallint) pg_catalog.in_range(smallint, smallint, smallint, boolean, boolean),
    function 1(integer, integer) pg_catalog.btint4cmp(integer, integer),
    function 2(integer, integer) pg_catalog.btint4sortsupport(internal),
    function 4(integer, integer) pg_catalog.btequalimage(oid),
    function 1(integer, bigint) pg_catalog.btint48cmp(integer, bigint),
    function 1(integer, smallint) pg_catalog.btint42cmp(integer, smallint),
    function 3(integer, bigint) pg_catalog.in_range(integer, integer, bigint, boolean, boolean),
    function 3(integer, integer) pg_catalog.in_range(integer, integer, integer, boolean, boolean),
    function 3(integer, smallint) pg_catalog.in_range(integer, integer, smallint, boolean, boolean),
    function 1(bigint, bigint) pg_catalog.btint8cmp(bigint, bigint),
    function 2(bigint, bigint) pg_catalog.btint8sortsupport(internal),
    function 4(bigint, bigint) pg_catalog.btequalimage(oid),
    function 1(bigint, integer) pg_catalog.btint84cmp(bigint, integer),
    function 1(bigint, smallint) pg_catalog.btint82cmp(bigint, smallint);

alter operator family pg_catalog.integer_ops using btree owner to "kim-uijin";

create operator class pg_catalog.int4_ops default for type integer using btree family pg_catalog.integer_ops as
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 1 pg_catalog.<(integer, smallint),
    operator 5 pg_catalog.>(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 1 pg_catalog.<(integer, integer),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 5 pg_catalog.>(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 1 pg_catalog.<(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 1 pg_catalog.<(bigint, integer),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint);

alter operator class pg_catalog.int4_ops using btree owner to "kim-uijin";

create operator class pg_catalog.int2_ops default for type smallint using btree family pg_catalog.integer_ops as
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 1 pg_catalog.<(integer, smallint),
    operator 5 pg_catalog.>(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 1 pg_catalog.<(integer, integer),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 5 pg_catalog.>(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 1 pg_catalog.<(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 1 pg_catalog.<(bigint, integer),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint);

alter operator class pg_catalog.int2_ops using btree owner to "kim-uijin";

create operator class pg_catalog.int8_ops default for type bigint using btree family pg_catalog.integer_ops as
    operator 2 pg_catalog.<=(bigint, smallint),
    operator 1 pg_catalog.<(bigint, smallint),
    operator 5 pg_catalog.>(bigint, bigint),
    operator 4 pg_catalog.>=(bigint, bigint),
    operator 3 pg_catalog.=(bigint, bigint),
    operator 2 pg_catalog.<=(bigint, bigint),
    operator 1 pg_catalog.<(bigint, bigint),
    operator 5 pg_catalog.>(integer, bigint),
    operator 4 pg_catalog.>=(integer, bigint),
    operator 3 pg_catalog.=(integer, bigint),
    operator 2 pg_catalog.<=(integer, bigint),
    operator 1 pg_catalog.<(integer, bigint),
    operator 5 pg_catalog.>(integer, smallint),
    operator 4 pg_catalog.>=(integer, smallint),
    operator 3 pg_catalog.=(integer, smallint),
    operator 2 pg_catalog.<=(integer, smallint),
    operator 1 pg_catalog.<(integer, smallint),
    operator 5 pg_catalog.>(integer, integer),
    operator 4 pg_catalog.>=(integer, integer),
    operator 3 pg_catalog.=(integer, integer),
    operator 2 pg_catalog.<=(integer, integer),
    operator 1 pg_catalog.<(integer, integer),
    operator 5 pg_catalog.>(smallint, bigint),
    operator 4 pg_catalog.>=(smallint, bigint),
    operator 3 pg_catalog.=(smallint, bigint),
    operator 2 pg_catalog.<=(smallint, bigint),
    operator 1 pg_catalog.<(smallint, bigint),
    operator 5 pg_catalog.>(smallint, integer),
    operator 4 pg_catalog.>=(smallint, integer),
    operator 3 pg_catalog.=(smallint, integer),
    operator 2 pg_catalog.<=(smallint, integer),
    operator 1 pg_catalog.<(smallint, integer),
    operator 2 pg_catalog.<=(smallint, smallint),
    operator 1 pg_catalog.<(smallint, smallint),
    operator 3 pg_catalog.=(smallint, smallint),
    operator 5 pg_catalog.>(smallint, smallint),
    operator 4 pg_catalog.>=(smallint, smallint),
    operator 5 pg_catalog.>(bigint, integer),
    operator 4 pg_catalog.>=(bigint, integer),
    operator 3 pg_catalog.=(bigint, integer),
    operator 2 pg_catalog.<=(bigint, integer),
    operator 1 pg_catalog.<(bigint, integer),
    operator 5 pg_catalog.>(bigint, smallint),
    operator 4 pg_catalog.>=(bigint, smallint),
    operator 3 pg_catalog.=(bigint, smallint);

alter operator class pg_catalog.int8_ops using btree owner to "kim-uijin";

create operator family pg_catalog.integer_ops using hash;

alter operator family pg_catalog.integer_ops using hash add
    function 1(bigint, bigint) pg_catalog.hashint8(bigint),
    function 2(bigint, bigint) pg_catalog.hashint8extended(bigint, bigint),
    function 1(smallint, smallint) pg_catalog.hashint2(smallint),
    function 2(smallint, smallint) pg_catalog.hashint2extended(smallint, bigint),
    function 1(integer, integer) pg_catalog.hashint4(integer),
    function 2(integer, integer) pg_catalog.hashint4extended(integer, bigint);

alter operator family pg_catalog.integer_ops using hash owner to "kim-uijin";

create operator class pg_catalog.int2_ops default for type smallint using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int2_ops using hash owner to "kim-uijin";

create operator class pg_catalog.int4_ops default for type integer using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int4_ops using hash owner to "kim-uijin";

create operator class pg_catalog.int8_ops default for type bigint using hash family pg_catalog.integer_ops as
    operator 1 pg_catalog.=(smallint, bigint),
    operator 1 pg_catalog.=(smallint, smallint),
    operator 1 pg_catalog.=(integer, integer),
    operator 1 pg_catalog.=(bigint, bigint),
    operator 1 pg_catalog.=(smallint, integer),
    operator 1 pg_catalog.=(integer, smallint),
    operator 1 pg_catalog.=(integer, bigint),
    operator 1 pg_catalog.=(bigint, smallint),
    operator 1 pg_catalog.=(bigint, integer);

alter operator class pg_catalog.int8_ops using hash owner to "kim-uijin";

create operator family pg_catalog.interval_ops using btree;

alter operator family pg_catalog.interval_ops using btree add
    function 3(interval, interval) pg_catalog.in_range(interval, interval, interval, boolean, boolean),
    function 1(interval, interval) pg_catalog.interval_cmp(interval, interval);

alter operator family pg_catalog.interval_ops using btree owner to "kim-uijin";

create operator class pg_catalog.interval_ops default for type interval using btree as
    operator 1 pg_catalog.<(interval, interval),
    operator 2 pg_catalog.<=(interval, interval),
    operator 3 pg_catalog.=(interval, interval),
    operator 4 pg_catalog.>=(interval, interval),
    operator 5 pg_catalog.>(interval, interval);

alter operator class pg_catalog.interval_ops using btree owner to "kim-uijin";

create operator family pg_catalog.interval_ops using hash;

alter operator family pg_catalog.interval_ops using hash add
    function 2(interval, interval) pg_catalog.interval_hash_extended(interval, bigint),
    function 1(interval, interval) pg_catalog.interval_hash(interval);

alter operator family pg_catalog.interval_ops using hash owner to "kim-uijin";

create operator class pg_catalog.interval_ops default for type interval using hash as
    operator 1 pg_catalog.=(interval, interval);

alter operator class pg_catalog.interval_ops using hash owner to "kim-uijin";

create operator family pg_catalog.macaddr_ops using btree;

alter operator family pg_catalog.macaddr_ops using btree add
    function 2(macaddr, macaddr) pg_catalog.macaddr_sortsupport(internal),
    function 4(macaddr, macaddr) pg_catalog.btequalimage(oid),
    function 1(macaddr, macaddr) pg_catalog.macaddr_cmp(macaddr, macaddr);

alter operator family pg_catalog.macaddr_ops using btree owner to "kim-uijin";

create operator class pg_catalog.macaddr_ops default for type macaddr using btree as
    operator 1 pg_catalog.<(macaddr, macaddr),
    operator 2 pg_catalog.<=(macaddr, macaddr),
    operator 3 pg_catalog.=(macaddr, macaddr),
    operator 4 pg_catalog.>=(macaddr, macaddr),
    operator 5 pg_catalog.>(macaddr, macaddr);

alter operator class pg_catalog.macaddr_ops using btree owner to "kim-uijin";

create operator family pg_catalog.macaddr_ops using hash;

alter operator family pg_catalog.macaddr_ops using hash add
    function 1(macaddr, macaddr) pg_catalog.hashmacaddr(macaddr),
    function 2(macaddr, macaddr) pg_catalog.hashmacaddrextended(macaddr, bigint);

alter operator family pg_catalog.macaddr_ops using hash owner to "kim-uijin";

create operator class pg_catalog.macaddr_ops default for type macaddr using hash as
    operator 1 pg_catalog.=(macaddr, macaddr);

alter operator class pg_catalog.macaddr_ops using hash owner to "kim-uijin";

create operator family pg_catalog.numeric_ops using btree;

alter operator family pg_catalog.numeric_ops using btree add
    function 2(numeric, numeric) pg_catalog.numeric_sortsupport(internal),
    function 1(numeric, numeric) pg_catalog.numeric_cmp(numeric, numeric),
    function 3(numeric, numeric) pg_catalog.in_range(numeric, numeric, numeric, boolean, boolean);

alter operator family pg_catalog.numeric_ops using btree owner to "kim-uijin";

create operator class pg_catalog.numeric_ops default for type numeric using btree as
    operator 2 pg_catalog.<=(numeric, numeric),
    operator 5 pg_catalog.>(numeric, numeric),
    operator 4 pg_catalog.>=(numeric, numeric),
    operator 1 pg_catalog.<(numeric, numeric),
    operator 3 pg_catalog.=(numeric, numeric);

alter operator class pg_catalog.numeric_ops using btree owner to "kim-uijin";

create operator family pg_catalog.oid_ops using btree;

alter operator family pg_catalog.oid_ops using btree add
    function 1(oid, oid) pg_catalog.btoidcmp(oid, oid),
    function 4(oid, oid) pg_catalog.btequalimage(oid),
    function 2(oid, oid) pg_catalog.btoidsortsupport(internal);

alter operator family pg_catalog.oid_ops using btree owner to "kim-uijin";

create operator class pg_catalog.oid_ops default for type oid using btree as
    operator 2 pg_catalog.<=(oid, oid),
    operator 1 pg_catalog.<(oid, oid),
    operator 5 pg_catalog.>(oid, oid),
    operator 4 pg_catalog.>=(oid, oid),
    operator 3 pg_catalog.=(oid, oid);

alter operator class pg_catalog.oid_ops using btree owner to "kim-uijin";

create operator family pg_catalog.oid_ops using hash;

alter operator family pg_catalog.oid_ops using hash add
    function 1(oid, oid) pg_catalog.hashoid(oid),
    function 2(oid, oid) pg_catalog.hashoidextended(oid, bigint);

alter operator family pg_catalog.oid_ops using hash owner to "kim-uijin";

create operator class pg_catalog.oid_ops default for type oid using hash as
    operator 1 pg_catalog.=(oid, oid);

alter operator class pg_catalog.oid_ops using hash owner to "kim-uijin";

create operator family pg_catalog.oidvector_ops using btree;

alter operator family pg_catalog.oidvector_ops using btree add
    function 4(oidvector, oidvector) pg_catalog.btequalimage(oid),
    function 1(oidvector, oidvector) pg_catalog.btoidvectorcmp(oidvector, oidvector);

alter operator family pg_catalog.oidvector_ops using btree owner to "kim-uijin";

create operator class pg_catalog.oidvector_ops default for type oidvector using btree as
    operator 4 pg_catalog.>=(oidvector, oidvector),
    operator 5 pg_catalog.>(oidvector, oidvector),
    operator 3 pg_catalog.=(oidvector, oidvector),
    operator 2 pg_catalog.<=(oidvector, oidvector),
    operator 1 pg_catalog.<(oidvector, oidvector);

alter operator class pg_catalog.oidvector_ops using btree owner to "kim-uijin";

create operator family pg_catalog.oidvector_ops using hash;

alter operator family pg_catalog.oidvector_ops using hash add
    function 1(oidvector, oidvector) pg_catalog.hashoidvector(oidvector),
    function 2(oidvector, oidvector) pg_catalog.hashoidvectorextended(oidvector, bigint);

alter operator family pg_catalog.oidvector_ops using hash owner to "kim-uijin";

create operator class pg_catalog.oidvector_ops default for type oidvector using hash as
    operator 1 pg_catalog.=(oidvector, oidvector);

alter operator class pg_catalog.oidvector_ops using hash owner to "kim-uijin";

create operator family pg_catalog.text_ops using btree;

alter operator family pg_catalog.text_ops using btree add
    function 1(name, name) pg_catalog.btnamecmp(name, name),
    function 2(text, text) pg_catalog.bttextsortsupport(internal),
    function 4(name, name) pg_catalog.btvarstrequalimage(oid),
    function 1(name, text) pg_catalog.btnametextcmp(name, text),
    function 1(text, name) pg_catalog.bttextnamecmp(text, name),
    function 1(text, text) pg_catalog.bttextcmp(text, text),
    function 2(name, name) pg_catalog.btnamesortsupport(internal),
    function 4(text, text) pg_catalog.btvarstrequalimage(oid);

alter operator family pg_catalog.text_ops using btree owner to "kim-uijin";

create operator class pg_catalog.text_ops default for type text using btree as
    operator 3 pg_catalog.=(name, text),
    operator 2 pg_catalog.<=(name, text),
    operator 1 pg_catalog.<(name, text),
    operator 5 pg_catalog.>(name, name),
    operator 4 pg_catalog.>=(name, name),
    operator 3 pg_catalog.=(name, name),
    operator 2 pg_catalog.<=(name, name),
    operator 5 pg_catalog.>(name, text),
    operator 1 pg_catalog.<(text, name),
    operator 3 pg_catalog.=(text, name),
    operator 2 pg_catalog.<=(text, name),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.>=(name, text),
    operator 1 pg_catalog.<(text, text),
    operator 5 pg_catalog.>(text, name),
    operator 4 pg_catalog.>=(text, name),
    operator 1 pg_catalog.<(name, name),
    operator 5 pg_catalog.>(text, text),
    operator 4 pg_catalog.>=(text, text),
    operator 2 pg_catalog.<=(text, text);

alter operator class pg_catalog.text_ops using btree owner to "kim-uijin";

create operator class pg_catalog.name_ops default for type name using btree family pg_catalog.text_ops as storage cstring operator 3 pg_catalog.=(name, text),
	operator 2 pg_catalog.<=(name, text),
	operator 1 pg_catalog.<(name, text),
	operator 5 pg_catalog.>(name, name),
	operator 4 pg_catalog.>=(name, name),
	operator 3 pg_catalog.=(name, name),
	operator 2 pg_catalog.<=(name, name),
	operator 5 pg_catalog.>(name, text),
	operator 1 pg_catalog.<(text, name),
	operator 3 pg_catalog.=(text, name),
	operator 2 pg_catalog.<=(text, name),
	operator 3 pg_catalog.=(text, text),
	operator 4 pg_catalog.>=(name, text),
	operator 1 pg_catalog.<(text, text),
	operator 5 pg_catalog.>(text, name),
	operator 4 pg_catalog.>=(text, name),
	operator 1 pg_catalog.<(name, name),
	operator 5 pg_catalog.>(text, text),
	operator 4 pg_catalog.>=(text, text),
	operator 2 pg_catalog.<=(text, text);

alter operator class pg_catalog.name_ops using btree owner to "kim-uijin";

create operator class pg_catalog.varchar_ops for type text using btree family pg_catalog.text_ops as
    operator 3 pg_catalog.=(name, text),
    operator 2 pg_catalog.<=(name, text),
    operator 1 pg_catalog.<(name, text),
    operator 5 pg_catalog.>(name, name),
    operator 4 pg_catalog.>=(name, name),
    operator 3 pg_catalog.=(name, name),
    operator 2 pg_catalog.<=(name, name),
    operator 5 pg_catalog.>(name, text),
    operator 1 pg_catalog.<(text, name),
    operator 3 pg_catalog.=(text, name),
    operator 2 pg_catalog.<=(text, name),
    operator 3 pg_catalog.=(text, text),
    operator 4 pg_catalog.>=(name, text),
    operator 1 pg_catalog.<(text, text),
    operator 5 pg_catalog.>(text, name),
    operator 4 pg_catalog.>=(text, name),
    operator 1 pg_catalog.<(name, name),
    operator 5 pg_catalog.>(text, text),
    operator 4 pg_catalog.>=(text, text),
    operator 2 pg_catalog.<=(text, text);

alter operator class pg_catalog.varchar_ops using btree owner to "kim-uijin";

create operator family pg_catalog.text_ops using hash;

alter operator family pg_catalog.text_ops using hash add
    function 1(name, name) pg_catalog.hashname(name),
    function 2(text, text) pg_catalog.hashtextextended(text, bigint),
    function 1(text, text) pg_catalog.hashtext(text),
    function 2(name, name) pg_catalog.hashnameextended(name, bigint);

alter operator family pg_catalog.text_ops using hash owner to "kim-uijin";

create operator class pg_catalog.name_ops default for type name using hash family pg_catalog.text_ops as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name),
    operator 1 pg_catalog.=(name, name);

alter operator class pg_catalog.name_ops using hash owner to "kim-uijin";

create operator class pg_catalog.text_ops default for type text using hash as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name),
    operator 1 pg_catalog.=(name, name);

alter operator class pg_catalog.text_ops using hash owner to "kim-uijin";

create operator class pg_catalog.varchar_ops for type text using hash family pg_catalog.text_ops as
    operator 1 pg_catalog.=(text, text),
    operator 1 pg_catalog.=(name, text),
    operator 1 pg_catalog.=(text, name),
    operator 1 pg_catalog.=(name, name);

alter operator class pg_catalog.varchar_ops using hash owner to "kim-uijin";

create operator family pg_catalog.time_ops using btree;

alter operator family pg_catalog.time_ops using btree add
    function 3(time without time zone, interval) pg_catalog.in_range(time, time, interval, boolean, boolean),
    function 4(time without time zone, time without time zone) pg_catalog.btequalimage(oid),
    function 1(time without time zone, time without time zone) pg_catalog.time_cmp(time, time);

alter operator family pg_catalog.time_ops using btree owner to "kim-uijin";

create operator class pg_catalog.time_ops default for type time without time zone using btree as
    operator 2 pg_catalog.<=(time, time),
    operator 5 pg_catalog.>(time, time),
    operator 1 pg_catalog.<(time, time),
    operator 3 pg_catalog.=(time, time),
    operator 4 pg_catalog.>=(time, time);

alter operator class pg_catalog.time_ops using btree owner to "kim-uijin";

create operator family pg_catalog.time_ops using hash;

alter operator family pg_catalog.time_ops using hash add
    function 2(time without time zone, time without time zone) pg_catalog.time_hash_extended(time, bigint),
    function 1(time without time zone, time without time zone) pg_catalog.time_hash(time);

alter operator family pg_catalog.time_ops using hash owner to "kim-uijin";

create operator class pg_catalog.time_ops default for type time without time zone using hash as
    operator 1 pg_catalog.=(time, time);

alter operator class pg_catalog.time_ops using hash owner to "kim-uijin";

create operator family pg_catalog.numeric_ops using hash;

alter operator family pg_catalog.numeric_ops using hash add
    function 2(numeric, numeric) pg_catalog.hash_numeric_extended(numeric, bigint),
    function 1(numeric, numeric) pg_catalog.hash_numeric(numeric);

alter operator family pg_catalog.numeric_ops using hash owner to "kim-uijin";

create operator class pg_catalog.numeric_ops default for type numeric using hash as
    operator 1 pg_catalog.=(numeric, numeric);

alter operator class pg_catalog.numeric_ops using hash owner to "kim-uijin";

create operator family pg_catalog.timestamptz_ops using hash;

alter operator family pg_catalog.timestamptz_ops using hash add
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_hash_extended(timestamp, bigint),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_hash(timestamp);

alter operator family pg_catalog.timestamptz_ops using hash owner to "kim-uijin";

create operator class pg_catalog.timestamptz_ops default for type timestamp with time zone using hash as
    operator 1 pg_catalog.=(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamptz_ops using hash owner to "kim-uijin";

create operator family pg_catalog.timetz_ops using btree;

alter operator family pg_catalog.timetz_ops using btree add
    function 3(time with time zone, interval) pg_catalog.in_range(time with time zone, time with time zone, interval, boolean, boolean),
    function 1(time with time zone, time with time zone) pg_catalog.timetz_cmp(time with time zone, time with time zone),
    function 4(time with time zone, time with time zone) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.timetz_ops using btree owner to "kim-uijin";

create operator class pg_catalog.timetz_ops default for type time with time zone using btree as
    operator 1 pg_catalog.<(time with time zone, time with time zone),
    operator 3 pg_catalog.=(time with time zone, time with time zone),
    operator 4 pg_catalog.>=(time with time zone, time with time zone),
    operator 2 pg_catalog.<=(time with time zone, time with time zone),
    operator 5 pg_catalog.>(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_ops using btree owner to "kim-uijin";

create operator family pg_catalog.timetz_ops using hash;

alter operator family pg_catalog.timetz_ops using hash add
    function 1(time with time zone, time with time zone) pg_catalog.timetz_hash(time with time zone),
    function 2(time with time zone, time with time zone) pg_catalog.timetz_hash_extended(time with time zone, bigint);

alter operator family pg_catalog.timetz_ops using hash owner to "kim-uijin";

create operator class pg_catalog.timetz_ops default for type time with time zone using hash as
    operator 1 pg_catalog.=(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_ops using hash owner to "kim-uijin";

create operator family pg_catalog.varbit_ops using btree;

alter operator family pg_catalog.varbit_ops using btree add
    function 1(bit varying, bit varying) pg_catalog.varbitcmp(bit varying, bit varying),
    function 4(bit varying, bit varying) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.varbit_ops using btree owner to "kim-uijin";

create operator class pg_catalog.varbit_ops default for type bit varying using btree as
    operator 2 pg_catalog.<=(bit varying, bit varying),
    operator 1 pg_catalog.<(bit varying, bit varying),
    operator 3 pg_catalog.=(bit varying, bit varying),
    operator 4 pg_catalog.>=(bit varying, bit varying),
    operator 5 pg_catalog.>(bit varying, bit varying);

alter operator class pg_catalog.varbit_ops using btree owner to "kim-uijin";

create operator family pg_catalog.timestamp_ops using hash;

alter operator family pg_catalog.timestamp_ops using hash add
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_hash_extended(timestamp, bigint),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_hash(timestamp);

alter operator family pg_catalog.timestamp_ops using hash owner to "kim-uijin";

create operator class pg_catalog.timestamp_ops default for type timestamp without time zone using hash as
    operator 1 pg_catalog.=(timestamp, timestamp);

alter operator class pg_catalog.timestamp_ops using hash owner to "kim-uijin";

create operator family pg_catalog.text_pattern_ops using btree;

alter operator family pg_catalog.text_pattern_ops using btree add
    function 2(text, text) pg_catalog.bttext_pattern_sortsupport(internal),
    function 4(text, text) pg_catalog.btequalimage(oid),
    function 1(text, text) pg_catalog.bttext_pattern_cmp(text, text);

alter operator family pg_catalog.text_pattern_ops using btree owner to "kim-uijin";

create operator class pg_catalog.text_pattern_ops for type text using btree as
    operator 5 pg_catalog.~>~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 1 pg_catalog.~<~(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 3 pg_catalog.=(text, text);

alter operator class pg_catalog.text_pattern_ops using btree owner to "kim-uijin";

create operator class pg_catalog.varchar_pattern_ops for type text using btree family pg_catalog.text_pattern_ops as
    operator 5 pg_catalog.~>~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 1 pg_catalog.~<~(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 3 pg_catalog.=(text, text);

alter operator class pg_catalog.varchar_pattern_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bpchar_pattern_ops using btree;

alter operator family pg_catalog.bpchar_pattern_ops using btree add
    function 4(character, character) pg_catalog.btequalimage(oid),
    function 2(character, character) pg_catalog.btbpchar_pattern_sortsupport(internal),
    function 1(character, character) pg_catalog.btbpchar_pattern_cmp(char, char);

alter operator family pg_catalog.bpchar_pattern_ops using btree owner to "kim-uijin";

create operator class pg_catalog.bpchar_pattern_ops for type character using btree as
    operator 2 pg_catalog.~<=~(char, char),
    operator 4 pg_catalog.~>=~(char, char),
    operator 1 pg_catalog.~<~(char, char),
    operator 5 pg_catalog.~>~(char, char),
    operator 3 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_pattern_ops using btree owner to "kim-uijin";

create operator family pg_catalog.money_ops using btree;

alter operator family pg_catalog.money_ops using btree add
    function 1(money, money) pg_catalog.cash_cmp(money, money),
    function 4(money, money) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.money_ops using btree owner to "kim-uijin";

create operator class pg_catalog.money_ops default for type money using btree as
    operator 5 pg_catalog.>(money, money),
    operator 4 pg_catalog.>=(money, money),
    operator 3 pg_catalog.=(money, money),
    operator 2 pg_catalog.<=(money, money),
    operator 1 pg_catalog.<(money, money);

alter operator class pg_catalog.money_ops using btree owner to "kim-uijin";

create operator family pg_catalog.bool_ops using hash;

alter operator family pg_catalog.bool_ops using hash add
    function 1(boolean, boolean) pg_catalog.hashchar("char"),
    function 2(boolean, boolean) pg_catalog.hashcharextended("char", bigint);

alter operator family pg_catalog.bool_ops using hash owner to "kim-uijin";

create operator class pg_catalog.bool_ops default for type boolean using hash as
    operator 1 pg_catalog.=(boolean, boolean);

alter operator class pg_catalog.bool_ops using hash owner to "kim-uijin";

create operator family pg_catalog.bytea_ops using hash;

alter operator family pg_catalog.bytea_ops using hash add
    function 1(bytea, bytea) pg_catalog.hashvarlena(internal),
    function 2(bytea, bytea) pg_catalog.hashvarlenaextended(internal, bigint);

alter operator family pg_catalog.bytea_ops using hash owner to "kim-uijin";

create operator class pg_catalog.bytea_ops default for type bytea using hash as
    operator 1 pg_catalog.=(bytea, bytea);

alter operator class pg_catalog.bytea_ops using hash owner to "kim-uijin";

create operator family pg_catalog.xid_ops using hash;

alter operator family pg_catalog.xid_ops using hash add
    function 1(xid, xid) pg_catalog.hashint4(integer),
    function 2(xid, xid) pg_catalog.hashint4extended(integer, bigint);

alter operator family pg_catalog.xid_ops using hash owner to "kim-uijin";

create operator class pg_catalog.xid_ops default for type xid using hash as
    operator 1 pg_catalog.=(xid, xid);

alter operator class pg_catalog.xid_ops using hash owner to "kim-uijin";

create operator family pg_catalog.cid_ops using hash;

alter operator family pg_catalog.cid_ops using hash add
    function 2(cid, cid) pg_catalog.hashint4extended(integer, bigint),
    function 1(cid, cid) pg_catalog.hashint4(integer);

alter operator family pg_catalog.cid_ops using hash owner to "kim-uijin";

create operator class pg_catalog.cid_ops default for type cid using hash as
    operator 1 pg_catalog.=(cid, cid);

alter operator class pg_catalog.cid_ops using hash owner to "kim-uijin";

create operator family pg_catalog.tid_ops using hash;

alter operator family pg_catalog.tid_ops using hash add
    function 1(tid, tid) pg_catalog.hashtid(tid),
    function 2(tid, tid) pg_catalog.hashtidextended(tid, bigint);

alter operator family pg_catalog.tid_ops using hash owner to "kim-uijin";

create operator class pg_catalog.tid_ops default for type tid using hash as
    operator 1 pg_catalog.=(tid, tid);

alter operator class pg_catalog.tid_ops using hash owner to "kim-uijin";

create operator family pg_catalog.text_pattern_ops using hash;

alter operator family pg_catalog.text_pattern_ops using hash add
    function 1(text, text) pg_catalog.hashtext(text),
    function 2(text, text) pg_catalog.hashtextextended(text, bigint);

alter operator family pg_catalog.text_pattern_ops using hash owner to "kim-uijin";

create operator class pg_catalog.text_pattern_ops for type text using hash as
    operator 1 pg_catalog.=(text, text);

alter operator class pg_catalog.text_pattern_ops using hash owner to "kim-uijin";

create operator class pg_catalog.varchar_pattern_ops for type text using hash family pg_catalog.text_pattern_ops as
    operator 1 pg_catalog.=(text, text);

alter operator class pg_catalog.varchar_pattern_ops using hash owner to "kim-uijin";

create operator family pg_catalog.bpchar_pattern_ops using hash;

alter operator family pg_catalog.bpchar_pattern_ops using hash add
    function 2(character, character) pg_catalog.hashbpcharextended(char, bigint),
    function 1(character, character) pg_catalog.hashbpchar(char);

alter operator family pg_catalog.bpchar_pattern_ops using hash owner to "kim-uijin";

create operator class pg_catalog.bpchar_pattern_ops for type character using hash as
    operator 1 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_pattern_ops using hash owner to "kim-uijin";

create operator family pg_catalog.aclitem_ops using hash;

alter operator family pg_catalog.aclitem_ops using hash add
    function 2(aclitem, aclitem) pg_catalog.hash_aclitem_extended(aclitem, bigint),
    function 1(aclitem, aclitem) pg_catalog.hash_aclitem(aclitem);

alter operator family pg_catalog.aclitem_ops using hash owner to "kim-uijin";

create operator class pg_catalog.aclitem_ops default for type aclitem using hash as
    operator 1 pg_catalog.=(aclitem, aclitem);

alter operator class pg_catalog.aclitem_ops using hash owner to "kim-uijin";

create operator family pg_catalog.box_ops using gist;

alter operator family pg_catalog.box_ops using gist add
    function 1(box, box) pg_catalog.gist_box_consistent(internal, box, smallint, oid, internal),
    function 2(box, box) pg_catalog.gist_box_union(internal, internal),
    function 8(box, box) pg_catalog.gist_box_distance(internal, box, smallint, oid, internal),
    function 7(box, box) pg_catalog.gist_box_same(box, box, internal),
    function 5(box, box) pg_catalog.gist_box_penalty(internal, internal, internal),
    function 6(box, box) pg_catalog.gist_box_picksplit(internal, internal);

alter operator family pg_catalog.box_ops using gist owner to "kim-uijin";

create operator class pg_catalog.box_ops default for type box using gist as
    operator 15 pg_catalog.<->(box, point) for order by float_ops,
    operator 1 pg_catalog.<<(box, box),
    operator 2 pg_catalog.&<(box, box),
    operator 3 pg_catalog.&&(box, box),
    operator 4 pg_catalog.&>(box, box),
    operator 5 pg_catalog.>>(box, box),
    operator 6 pg_catalog.~=(box, box),
    operator 7 pg_catalog.@>(box, box),
    operator 8 pg_catalog.<@(box, box),
    operator 9 pg_catalog.&<|(box, box),
    operator 10 pg_catalog.<<|(box, box),
    operator 11 pg_catalog.|>>(box, box),
    operator 12 pg_catalog.|&>(box, box);

alter operator class pg_catalog.box_ops using gist owner to "kim-uijin";

create operator family pg_catalog.poly_ops using gist;

alter operator family pg_catalog.poly_ops using gist add
    function 5(polygon, polygon) pg_catalog.gist_box_penalty(internal, internal, internal),
    function 8(polygon, polygon) pg_catalog.gist_poly_distance(internal, polygon, smallint, oid, internal),
    function 3(polygon, polygon) pg_catalog.gist_poly_compress(internal),
    function 7(polygon, polygon) pg_catalog.gist_box_same(box, box, internal),
    function 6(polygon, polygon) pg_catalog.gist_box_picksplit(internal, internal),
    function 2(polygon, polygon) pg_catalog.gist_box_union(internal, internal),
    function 1(polygon, polygon) pg_catalog.gist_poly_consistent(internal, polygon, smallint, oid, internal);

alter operator family pg_catalog.poly_ops using gist owner to "kim-uijin";

create operator class pg_catalog.poly_ops default for type polygon using gist as storage box operator 4 pg_catalog.&>(polygon, polygon),
	operator 15 pg_catalog.<->(polygon, point) for order by float_ops,
	operator 3 pg_catalog.&&(polygon, polygon),
	operator 5 pg_catalog.>>(polygon, polygon),
	operator 6 pg_catalog.~=(polygon, polygon),
	operator 2 pg_catalog.&<(polygon, polygon),
	operator 1 pg_catalog.<<(polygon, polygon),
	operator 12 pg_catalog.|&>(polygon, polygon),
	operator 11 pg_catalog.|>>(polygon, polygon),
	operator 10 pg_catalog.<<|(polygon, polygon),
	operator 9 pg_catalog.&<|(polygon, polygon),
	operator 8 pg_catalog.<@(polygon, polygon),
	operator 7 pg_catalog.@>(polygon, polygon);

alter operator class pg_catalog.poly_ops using gist owner to "kim-uijin";

create operator family pg_catalog.circle_ops using gist;

alter operator family pg_catalog.circle_ops using gist add
    function 2(circle, circle) pg_catalog.gist_box_union(internal, internal),
    function 5(circle, circle) pg_catalog.gist_box_penalty(internal, internal, internal),
    function 6(circle, circle) pg_catalog.gist_box_picksplit(internal, internal),
    function 7(circle, circle) pg_catalog.gist_box_same(box, box, internal),
    function 8(circle, circle) pg_catalog.gist_circle_distance(internal, circle, smallint, oid, internal),
    function 1(circle, circle) pg_catalog.gist_circle_consistent(internal, circle, smallint, oid, internal),
    function 3(circle, circle) pg_catalog.gist_circle_compress(internal);

alter operator family pg_catalog.circle_ops using gist owner to "kim-uijin";

create operator class pg_catalog.circle_ops default for type circle using gist as storage box operator 15 pg_catalog.<->(circle, point) for order by float_ops,
	operator 8 pg_catalog.<@(circle, circle),
	operator 7 pg_catalog.@>(circle, circle),
	operator 6 pg_catalog.~=(circle, circle),
	operator 5 pg_catalog.>>(circle, circle),
	operator 4 pg_catalog.&>(circle, circle),
	operator 3 pg_catalog.&&(circle, circle),
	operator 2 pg_catalog.&<(circle, circle),
	operator 1 pg_catalog.<<(circle, circle),
	operator 9 pg_catalog.&<|(circle, circle),
	operator 10 pg_catalog.<<|(circle, circle),
	operator 11 pg_catalog.|>>(circle, circle),
	operator 12 pg_catalog.|&>(circle, circle);

alter operator class pg_catalog.circle_ops using gist owner to "kim-uijin";

create operator family pg_catalog.array_ops using gin;

alter operator family pg_catalog.array_ops using gin add
    function 2(anyarray, anyarray) pg_catalog.ginarrayextract(anyarray, internal, internal),
    function 6(anyarray, anyarray) pg_catalog.ginarraytriconsistent(internal, smallint, anyarray, integer, internal, internal, internal),
    function 4(anyarray, anyarray) pg_catalog.ginarrayconsistent(internal, smallint, anyarray, integer, internal, internal, internal, internal),
    function 3(anyarray, anyarray) pg_catalog.ginqueryarrayextract(anyarray, internal, smallint, internal, internal, internal, internal);

alter operator family pg_catalog.array_ops using gin owner to "kim-uijin";

create operator class pg_catalog.array_ops default for type anyarray using gin as storage anyelement operator 4 pg_catalog.=(anyarray, anyarray),
	operator 3 pg_catalog.<@(anyarray, anyarray),
	operator 2 pg_catalog.@>(anyarray, anyarray),
	operator 1 pg_catalog.&&(anyarray, anyarray);

alter operator class pg_catalog.array_ops using gin owner to "kim-uijin";

create operator family pg_catalog.tid_ops using btree;

alter operator family pg_catalog.tid_ops using btree add
    function 1(tid, tid) pg_catalog.bttidcmp(tid, tid),
    function 4(tid, tid) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.tid_ops using btree owner to "kim-uijin";

create operator class pg_catalog.tid_ops default for type tid using btree as
    operator 5 pg_catalog.>(tid, tid),
    operator 2 pg_catalog.<=(tid, tid),
    operator 1 pg_catalog.<(tid, tid),
    operator 3 pg_catalog.=(tid, tid),
    operator 4 pg_catalog.>=(tid, tid);

alter operator class pg_catalog.tid_ops using btree owner to "kim-uijin";

create operator family pg_catalog.uuid_ops using btree;

alter operator family pg_catalog.uuid_ops using btree add
    function 4(uuid, uuid) pg_catalog.btequalimage(oid),
    function 1(uuid, uuid) pg_catalog.uuid_cmp(uuid, uuid),
    function 2(uuid, uuid) pg_catalog.uuid_sortsupport(internal);

alter operator family pg_catalog.uuid_ops using btree owner to "kim-uijin";

create operator class pg_catalog.uuid_ops default for type uuid using btree as
    operator 1 pg_catalog.<(uuid, uuid),
    operator 5 pg_catalog.>(uuid, uuid),
    operator 4 pg_catalog.>=(uuid, uuid),
    operator 3 pg_catalog.=(uuid, uuid),
    operator 2 pg_catalog.<=(uuid, uuid);

alter operator class pg_catalog.uuid_ops using btree owner to "kim-uijin";

create operator family pg_catalog.uuid_ops using hash;

alter operator family pg_catalog.uuid_ops using hash add
    function 1(uuid, uuid) pg_catalog.uuid_hash(uuid),
    function 2(uuid, uuid) pg_catalog.uuid_hash_extended(uuid, bigint);

alter operator family pg_catalog.uuid_ops using hash owner to "kim-uijin";

create operator class pg_catalog.uuid_ops default for type uuid using hash as
    operator 1 pg_catalog.=(uuid, uuid);

alter operator class pg_catalog.uuid_ops using hash owner to "kim-uijin";

create operator family pg_catalog.record_ops using btree;

alter operator family pg_catalog.record_ops using btree add
    function 1(record, record) pg_catalog.btrecordcmp(record, record);

alter operator family pg_catalog.record_ops using btree owner to "kim-uijin";

create operator class pg_catalog.record_ops default for type record using btree as
    operator 5 pg_catalog.>(record, record),
    operator 3 pg_catalog.=(record, record),
    operator 2 pg_catalog.<=(record, record),
    operator 1 pg_catalog.<(record, record),
    operator 4 pg_catalog.>=(record, record);

alter operator class pg_catalog.record_ops using btree owner to "kim-uijin";

create operator family pg_catalog.record_image_ops using btree;

alter operator family pg_catalog.record_image_ops using btree add
    function 1(record, record) pg_catalog.btrecordimagecmp(record, record);

alter operator family pg_catalog.record_image_ops using btree owner to "kim-uijin";

create operator class pg_catalog.record_image_ops for type record using btree as
    operator 3 pg_catalog.*=(record, record),
    operator 2 pg_catalog.*<=(record, record),
    operator 1 pg_catalog.*<(record, record),
    operator 4 pg_catalog.*>=(record, record),
    operator 5 pg_catalog.*>(record, record);

alter operator class pg_catalog.record_image_ops using btree owner to "kim-uijin";

create operator family pg_catalog.pg_lsn_ops using btree;

alter operator family pg_catalog.pg_lsn_ops using btree add
    function 1(pg_lsn, pg_lsn) pg_catalog.pg_lsn_cmp(pg_lsn, pg_lsn),
    function 4(pg_lsn, pg_lsn) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.pg_lsn_ops using btree owner to "kim-uijin";

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using btree as
    operator 3 pg_catalog.=(pg_lsn, pg_lsn),
    operator 2 pg_catalog.<=(pg_lsn, pg_lsn),
    operator 5 pg_catalog.>(pg_lsn, pg_lsn),
    operator 1 pg_catalog.<(pg_lsn, pg_lsn),
    operator 4 pg_catalog.>=(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_ops using btree owner to "kim-uijin";

create operator family pg_catalog.pg_lsn_ops using hash;

alter operator family pg_catalog.pg_lsn_ops using hash add
    function 1(pg_lsn, pg_lsn) pg_catalog.pg_lsn_hash(pg_lsn),
    function 2(pg_lsn, pg_lsn) pg_catalog.pg_lsn_hash_extended(pg_lsn, bigint);

alter operator family pg_catalog.pg_lsn_ops using hash owner to "kim-uijin";

create operator class pg_catalog.pg_lsn_ops default for type pg_lsn using hash as
    operator 1 pg_catalog.=(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_ops using hash owner to "kim-uijin";

create operator family pg_catalog.macaddr8_ops using btree;

alter operator family pg_catalog.macaddr8_ops using btree add
    function 1(macaddr8, macaddr8) pg_catalog.macaddr8_cmp(macaddr8, macaddr8),
    function 4(macaddr8, macaddr8) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.macaddr8_ops using btree owner to "kim-uijin";

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using btree as
    operator 4 pg_catalog.>=(macaddr8, macaddr8),
    operator 3 pg_catalog.=(macaddr8, macaddr8),
    operator 2 pg_catalog.<=(macaddr8, macaddr8),
    operator 1 pg_catalog.<(macaddr8, macaddr8),
    operator 5 pg_catalog.>(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_ops using btree owner to "kim-uijin";

create operator family pg_catalog.macaddr8_ops using hash;

alter operator family pg_catalog.macaddr8_ops using hash add
    function 1(macaddr8, macaddr8) pg_catalog.hashmacaddr8(macaddr8),
    function 2(macaddr8, macaddr8) pg_catalog.hashmacaddr8extended(macaddr8, bigint);

alter operator family pg_catalog.macaddr8_ops using hash owner to "kim-uijin";

create operator class pg_catalog.macaddr8_ops default for type macaddr8 using hash as
    operator 1 pg_catalog.=(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_ops using hash owner to "kim-uijin";

create operator family pg_catalog.range_ops using spgist;

alter operator family pg_catalog.range_ops using spgist add
    function 3(anyrange, anyrange) pg_catalog.spg_range_quad_picksplit(internal, internal),
    function 4(anyrange, anyrange) pg_catalog.spg_range_quad_inner_consistent(internal, internal),
    function 5(anyrange, anyrange) pg_catalog.spg_range_quad_leaf_consistent(internal, internal),
    function 1(anyrange, anyrange) pg_catalog.spg_range_quad_config(internal, internal),
    function 2(anyrange, anyrange) pg_catalog.spg_range_quad_choose(internal, internal);

alter operator family pg_catalog.range_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.range_ops default for type anyrange using spgist as
    operator 1 pg_catalog.<<(anyrange, anyrange),
    operator 4 pg_catalog.&>(anyrange, anyrange),
    operator 8 pg_catalog.<@(anyrange, anyrange),
    operator 5 pg_catalog.>>(anyrange, anyrange),
    operator 7 pg_catalog.@>(anyrange, anyrange),
    operator 6 pg_catalog.-|-(anyrange, anyrange),
    operator 18 pg_catalog.=(anyrange, anyrange),
    operator 16 pg_catalog.@>(anyrange, anyelement),
    operator 2 pg_catalog.&<(anyrange, anyrange),
    operator 3 pg_catalog.&&(anyrange, anyrange);

alter operator class pg_catalog.range_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.enum_ops using btree;

alter operator family pg_catalog.enum_ops using btree add
    function 1(anyenum, anyenum) pg_catalog.enum_cmp(anyenum, anyenum),
    function 4(anyenum, anyenum) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.enum_ops using btree owner to "kim-uijin";

create operator class pg_catalog.enum_ops default for type anyenum using btree as
    operator 2 pg_catalog.<=(anyenum, anyenum),
    operator 1 pg_catalog.<(anyenum, anyenum),
    operator 3 pg_catalog.=(anyenum, anyenum),
    operator 4 pg_catalog.>=(anyenum, anyenum),
    operator 5 pg_catalog.>(anyenum, anyenum);

alter operator class pg_catalog.enum_ops using btree owner to "kim-uijin";

create operator family pg_catalog.enum_ops using hash;

alter operator family pg_catalog.enum_ops using hash add
    function 2(anyenum, anyenum) pg_catalog.hashenumextended(anyenum, bigint),
    function 1(anyenum, anyenum) pg_catalog.hashenum(anyenum);

alter operator family pg_catalog.enum_ops using hash owner to "kim-uijin";

create operator class pg_catalog.enum_ops default for type anyenum using hash as
    operator 1 pg_catalog.=(anyenum, anyenum);

alter operator class pg_catalog.enum_ops using hash owner to "kim-uijin";

create operator family pg_catalog.network_ops using gist;

alter operator family pg_catalog.network_ops using gist add
    function 1(inet, inet) pg_catalog.inet_gist_consistent(internal, inet, smallint, oid, internal),
    function 2(inet, inet) pg_catalog.inet_gist_union(internal, internal),
    function 3(inet, inet) pg_catalog.inet_gist_compress(internal),
    function 5(inet, inet) pg_catalog.inet_gist_penalty(internal, internal, internal),
    function 6(inet, inet) pg_catalog.inet_gist_picksplit(internal, internal),
    function 7(inet, inet) pg_catalog.inet_gist_same(inet, inet, internal),
    function 9(inet, inet) pg_catalog.inet_gist_fetch(internal);

alter operator family pg_catalog.network_ops using gist owner to "kim-uijin";

create operator class pg_catalog.inet_ops for type inet using gist family pg_catalog.network_ops as
    operator 22 pg_catalog.>(inet, inet),
    operator 21 pg_catalog.<=(inet, inet),
    operator 20 pg_catalog.<(inet, inet),
    operator 19 pg_catalog.<>(inet, inet),
    operator 18 pg_catalog.=(inet, inet),
    operator 3 pg_catalog.&&(inet, inet),
    operator 25 pg_catalog.<<=(inet, inet),
    operator 23 pg_catalog.>=(inet, inet),
    operator 26 pg_catalog.>>(inet, inet),
    operator 24 pg_catalog.<<(inet, inet),
    operator 27 pg_catalog.>>=(inet, inet);

alter operator class pg_catalog.inet_ops using gist owner to "kim-uijin";

create operator family pg_catalog.tsvector_ops using btree;

alter operator family pg_catalog.tsvector_ops using btree add
    function 1(tsvector, tsvector) pg_catalog.tsvector_cmp(tsvector, tsvector);

alter operator family pg_catalog.tsvector_ops using btree owner to "kim-uijin";

create operator class pg_catalog.tsvector_ops default for type tsvector using btree as
    operator 1 pg_catalog.<(tsvector, tsvector),
    operator 3 pg_catalog.=(tsvector, tsvector),
    operator 5 pg_catalog.>(tsvector, tsvector),
    operator 4 pg_catalog.>=(tsvector, tsvector),
    operator 2 pg_catalog.<=(tsvector, tsvector);

alter operator class pg_catalog.tsvector_ops using btree owner to "kim-uijin";

create operator family pg_catalog.tsvector_ops using gist;

alter operator family pg_catalog.tsvector_ops using gist add
    function 2(tsvector, tsvector) pg_catalog.gtsvector_union(internal, internal),
    function 3(tsvector, tsvector) pg_catalog.gtsvector_compress(internal),
    function 4(tsvector, tsvector) pg_catalog.gtsvector_decompress(internal),
    function 5(tsvector, tsvector) pg_catalog.gtsvector_penalty(internal, internal, internal),
    function 6(tsvector, tsvector) pg_catalog.gtsvector_picksplit(internal, internal),
    function 7(tsvector, tsvector) pg_catalog.gtsvector_same(gtsvector, gtsvector, internal),
    function 1(tsvector, tsvector) pg_catalog.gtsvector_consistent(internal, tsvector, smallint, oid, internal),
    function 10(tsvector, tsvector) pg_catalog.gtsvector_options(internal);

alter operator family pg_catalog.tsvector_ops using gist owner to "kim-uijin";

create operator class pg_catalog.tsvector_ops default for type tsvector using gist as storage gtsvector operator 1 pg_catalog.@@(tsvector, tsquery);

alter operator class pg_catalog.tsvector_ops using gist owner to "kim-uijin";

create operator family pg_catalog.tsvector_ops using gin;

alter operator family pg_catalog.tsvector_ops using gin add
    function 4(tsvector, tsvector) pg_catalog.gin_tsquery_consistent(internal, smallint, tsvector, integer, internal, internal, internal, internal),
    function 5(tsvector, tsvector) pg_catalog.gin_cmp_prefix(text, text, smallint, internal),
    function 2(tsvector, tsvector) pg_catalog.gin_extract_tsvector(tsvector, internal, internal),
    function 1(tsvector, tsvector) pg_catalog.gin_cmp_tslexeme(text, text),
    function 6(tsvector, tsvector) pg_catalog.gin_tsquery_triconsistent(internal, smallint, tsvector, integer, internal, internal, internal),
    function 3(tsvector, tsvector) pg_catalog.gin_extract_tsquery(tsvector, internal, smallint, internal, internal, internal, internal);

alter operator family pg_catalog.tsvector_ops using gin owner to "kim-uijin";

create operator class pg_catalog.tsvector_ops default for type tsvector using gin as storage text operator 2 pg_catalog.@@@(tsvector, tsquery),
	operator 1 pg_catalog.@@(tsvector, tsquery);

alter operator class pg_catalog.tsvector_ops using gin owner to "kim-uijin";

create operator family pg_catalog.tsquery_ops using btree;

alter operator family pg_catalog.tsquery_ops using btree add
    function 1(tsquery, tsquery) pg_catalog.tsquery_cmp(tsquery, tsquery);

alter operator family pg_catalog.tsquery_ops using btree owner to "kim-uijin";

create operator class pg_catalog.tsquery_ops default for type tsquery using btree as
    operator 5 pg_catalog.>(tsquery, tsquery),
    operator 3 pg_catalog.=(tsquery, tsquery),
    operator 4 pg_catalog.>=(tsquery, tsquery),
    operator 1 pg_catalog.<(tsquery, tsquery),
    operator 2 pg_catalog.<=(tsquery, tsquery);

alter operator class pg_catalog.tsquery_ops using btree owner to "kim-uijin";

create operator family pg_catalog.tsquery_ops using gist;

alter operator family pg_catalog.tsquery_ops using gist add
    function 1(tsquery, tsquery) pg_catalog.gtsquery_consistent(internal, tsquery, smallint, oid, internal),
    function 2(tsquery, tsquery) pg_catalog.gtsquery_union(internal, internal),
    function 5(tsquery, tsquery) pg_catalog.gtsquery_penalty(internal, internal, internal),
    function 6(tsquery, tsquery) pg_catalog.gtsquery_picksplit(internal, internal),
    function 7(tsquery, tsquery) pg_catalog.gtsquery_same(bigint, bigint, internal),
    function 3(tsquery, tsquery) pg_catalog.gtsquery_compress(internal);

alter operator family pg_catalog.tsquery_ops using gist owner to "kim-uijin";

create operator class pg_catalog.tsquery_ops default for type tsquery using gist as storage bigint operator 8 pg_catalog.<@(tsquery, tsquery),
	operator 7 pg_catalog.@>(tsquery, tsquery);

alter operator class pg_catalog.tsquery_ops using gist owner to "kim-uijin";

create operator family pg_catalog.network_ops using spgist;

alter operator family pg_catalog.network_ops using spgist add
    function 5(inet, inet) pg_catalog.inet_spg_leaf_consistent(internal, internal),
    function 4(inet, inet) pg_catalog.inet_spg_inner_consistent(internal, internal),
    function 1(inet, inet) pg_catalog.inet_spg_config(internal, internal),
    function 2(inet, inet) pg_catalog.inet_spg_choose(internal, internal),
    function 3(inet, inet) pg_catalog.inet_spg_picksplit(internal, internal);

alter operator family pg_catalog.network_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.inet_ops default for type inet using spgist family pg_catalog.network_ops as
    operator 22 pg_catalog.>(inet, inet),
    operator 21 pg_catalog.<=(inet, inet),
    operator 27 pg_catalog.>>=(inet, inet),
    operator 26 pg_catalog.>>(inet, inet),
    operator 25 pg_catalog.<<=(inet, inet),
    operator 20 pg_catalog.<(inet, inet),
    operator 19 pg_catalog.<>(inet, inet),
    operator 18 pg_catalog.=(inet, inet),
    operator 3 pg_catalog.&&(inet, inet),
    operator 24 pg_catalog.<<(inet, inet),
    operator 23 pg_catalog.>=(inet, inet);

alter operator class pg_catalog.inet_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.range_ops using btree;

alter operator family pg_catalog.range_ops using btree add
    function 1(anyrange, anyrange) pg_catalog.range_cmp(anyrange, anyrange);

alter operator family pg_catalog.range_ops using btree owner to "kim-uijin";

create operator class pg_catalog.range_ops default for type anyrange using btree as
    operator 1 pg_catalog.<(anyrange, anyrange),
    operator 2 pg_catalog.<=(anyrange, anyrange),
    operator 3 pg_catalog.=(anyrange, anyrange),
    operator 4 pg_catalog.>=(anyrange, anyrange),
    operator 5 pg_catalog.>(anyrange, anyrange);

alter operator class pg_catalog.range_ops using btree owner to "kim-uijin";

create operator family pg_catalog.range_ops using hash;

alter operator family pg_catalog.range_ops using hash add
    function 2(anyrange, anyrange) pg_catalog.hash_range_extended(anyrange, bigint),
    function 1(anyrange, anyrange) pg_catalog.hash_range(anyrange);

alter operator family pg_catalog.range_ops using hash owner to "kim-uijin";

create operator class pg_catalog.range_ops default for type anyrange using hash as
    operator 1 pg_catalog.=(anyrange, anyrange);

alter operator class pg_catalog.range_ops using hash owner to "kim-uijin";

create operator family pg_catalog.range_ops using gist;

alter operator family pg_catalog.range_ops using gist add
    function 5(anyrange, anyrange) pg_catalog.range_gist_penalty(internal, internal, internal),
    function 6(anyrange, anyrange) pg_catalog.range_gist_picksplit(internal, internal),
    function 2(anyrange, anyrange) pg_catalog.range_gist_union(internal, internal),
    function 1(anyrange, anyrange) pg_catalog.range_gist_consistent(internal, anyrange, smallint, oid, internal),
    function 7(anyrange, anyrange) pg_catalog.range_gist_same(anyrange, anyrange, internal);

alter operator family pg_catalog.range_ops using gist owner to "kim-uijin";

create operator class pg_catalog.range_ops default for type anyrange using gist as
    operator 1 pg_catalog.<<(anyrange, anyrange),
    operator 1 pg_catalog.<<(anyrange, anymultirange),
    operator 2 pg_catalog.&<(anyrange, anyrange),
    operator 2 pg_catalog.&<(anyrange, anymultirange),
    operator 3 pg_catalog.&&(anyrange, anyrange),
    operator 3 pg_catalog.&&(anyrange, anymultirange),
    operator 4 pg_catalog.&>(anyrange, anyrange),
    operator 4 pg_catalog.&>(anyrange, anymultirange),
    operator 5 pg_catalog.>>(anyrange, anyrange),
    operator 5 pg_catalog.>>(anyrange, anymultirange),
    operator 6 pg_catalog.-|-(anyrange, anyrange),
    operator 6 pg_catalog.-|-(anyrange, anymultirange),
    operator 7 pg_catalog.@>(anyrange, anyrange),
    operator 7 pg_catalog.@>(anyrange, anymultirange),
    operator 8 pg_catalog.<@(anyrange, anyrange),
    operator 8 pg_catalog.<@(anyrange, anymultirange),
    operator 16 pg_catalog.@>(anyrange, anyelement),
    operator 18 pg_catalog.=(anyrange, anyrange);

alter operator class pg_catalog.range_ops using gist owner to "kim-uijin";

create operator family pg_catalog.quad_point_ops using spgist;

alter operator family pg_catalog.quad_point_ops using spgist add
    function 5(point, point) pg_catalog.spg_quad_leaf_consistent(internal, internal),
    function 3(point, point) pg_catalog.spg_quad_picksplit(internal, internal),
    function 2(point, point) pg_catalog.spg_quad_choose(internal, internal),
    function 1(point, point) pg_catalog.spg_quad_config(internal, internal),
    function 4(point, point) pg_catalog.spg_quad_inner_consistent(internal, internal);

alter operator family pg_catalog.quad_point_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.quad_point_ops default for type point using spgist as
    operator 8 pg_catalog.<@(point, box),
    operator 5 pg_catalog.>>(point, point),
    operator 30 pg_catalog.>^(point, point),
    operator 1 pg_catalog.<<(point, point),
    operator 11 pg_catalog.|>>(point, point),
    operator 29 pg_catalog.<^(point, point),
    operator 6 pg_catalog.~=(point, point),
    operator 10 pg_catalog.<<|(point, point),
    operator 15 pg_catalog.<->(point, point) for order by float_ops;

alter operator class pg_catalog.quad_point_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.kd_point_ops using spgist;

alter operator family pg_catalog.kd_point_ops using spgist add
    function 5(point, point) pg_catalog.spg_quad_leaf_consistent(internal, internal),
    function 2(point, point) pg_catalog.spg_kd_choose(internal, internal),
    function 1(point, point) pg_catalog.spg_kd_config(internal, internal),
    function 4(point, point) pg_catalog.spg_kd_inner_consistent(internal, internal),
    function 3(point, point) pg_catalog.spg_kd_picksplit(internal, internal);

alter operator family pg_catalog.kd_point_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.kd_point_ops for type point using spgist as
    operator 15 pg_catalog.<->(point, point) for order by float_ops,
    operator 11 pg_catalog.|>>(point, point),
    operator 30 pg_catalog.>^(point, point),
    operator 1 pg_catalog.<<(point, point),
    operator 5 pg_catalog.>>(point, point),
    operator 10 pg_catalog.<<|(point, point),
    operator 29 pg_catalog.<^(point, point),
    operator 6 pg_catalog.~=(point, point),
    operator 8 pg_catalog.<@(point, box);

alter operator class pg_catalog.kd_point_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.text_ops using spgist;

alter operator family pg_catalog.text_ops using spgist add
    function 4(text, text) pg_catalog.spg_text_inner_consistent(internal, internal),
    function 3(text, text) pg_catalog.spg_text_picksplit(internal, internal),
    function 2(text, text) pg_catalog.spg_text_choose(internal, internal),
    function 1(text, text) pg_catalog.spg_text_config(internal, internal),
    function 5(text, text) pg_catalog.spg_text_leaf_consistent(internal, internal);

alter operator family pg_catalog.text_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.text_ops default for type text using spgist as
    operator 3 pg_catalog.=(text, text),
    operator 1 pg_catalog.~<~(text, text),
    operator 2 pg_catalog.~<=~(text, text),
    operator 4 pg_catalog.~>=~(text, text),
    operator 5 pg_catalog.~>~(text, text),
    operator 11 pg_catalog.<(text, text),
    operator 12 pg_catalog.<=(text, text),
    operator 14 pg_catalog.>=(text, text),
    operator 15 pg_catalog.>(text, text),
    operator 28 pg_catalog.^@(text, text);

alter operator class pg_catalog.text_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.jsonb_ops using btree;

alter operator family pg_catalog.jsonb_ops using btree add
    function 1(jsonb, jsonb) pg_catalog.jsonb_cmp(jsonb, jsonb);

alter operator family pg_catalog.jsonb_ops using btree owner to "kim-uijin";

create operator class pg_catalog.jsonb_ops default for type jsonb using btree as
    operator 4 pg_catalog.>=(jsonb, jsonb),
    operator 5 pg_catalog.>(jsonb, jsonb),
    operator 3 pg_catalog.=(jsonb, jsonb),
    operator 2 pg_catalog.<=(jsonb, jsonb),
    operator 1 pg_catalog.<(jsonb, jsonb);

alter operator class pg_catalog.jsonb_ops using btree owner to "kim-uijin";

create operator family pg_catalog.jsonb_ops using hash;

alter operator family pg_catalog.jsonb_ops using hash add
    function 1(jsonb, jsonb) pg_catalog.jsonb_hash(jsonb),
    function 2(jsonb, jsonb) pg_catalog.jsonb_hash_extended(jsonb, bigint);

alter operator family pg_catalog.jsonb_ops using hash owner to "kim-uijin";

create operator class pg_catalog.jsonb_ops default for type jsonb using hash as
    operator 1 pg_catalog.=(jsonb, jsonb);

alter operator class pg_catalog.jsonb_ops using hash owner to "kim-uijin";

create operator family pg_catalog.jsonb_ops using gin;

alter operator family pg_catalog.jsonb_ops using gin add
    function 3(jsonb, jsonb) pg_catalog.gin_extract_jsonb_query(jsonb, internal, smallint, internal, internal, internal, internal),
    function 1(jsonb, jsonb) pg_catalog.gin_compare_jsonb(text, text),
    function 2(jsonb, jsonb) pg_catalog.gin_extract_jsonb(jsonb, internal, internal),
    function 6(jsonb, jsonb) pg_catalog.gin_triconsistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal),
    function 4(jsonb, jsonb) pg_catalog.gin_consistent_jsonb(internal, smallint, jsonb, integer, internal, internal, internal, internal);

alter operator family pg_catalog.jsonb_ops using gin owner to "kim-uijin";

create operator class pg_catalog.jsonb_ops default for type jsonb using gin as storage text operator 11 pg_catalog.?&(jsonb, text[]),
	operator 15 pg_catalog.@?(jsonb, jsonpath),
	operator 16 pg_catalog.@@(jsonb, jsonpath),
	operator 10 pg_catalog.?|(jsonb, text[]),
	operator 7 pg_catalog.@>(jsonb, jsonb),
	operator 9 pg_catalog.?(jsonb, text);

alter operator class pg_catalog.jsonb_ops using gin owner to "kim-uijin";

create operator family pg_catalog.jsonb_path_ops using gin;

alter operator family pg_catalog.jsonb_path_ops using gin add
    function 2(jsonb, jsonb) pg_catalog.gin_extract_jsonb_path(jsonb, internal, internal),
    function 4(jsonb, jsonb) pg_catalog.gin_consistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal, internal),
    function 6(jsonb, jsonb) pg_catalog.gin_triconsistent_jsonb_path(internal, smallint, jsonb, integer, internal, internal, internal),
    function 1(jsonb, jsonb) pg_catalog.btint4cmp(integer, integer),
    function 3(jsonb, jsonb) pg_catalog.gin_extract_jsonb_query_path(jsonb, internal, smallint, internal, internal, internal, internal);

alter operator family pg_catalog.jsonb_path_ops using gin owner to "kim-uijin";

create operator class pg_catalog.jsonb_path_ops for type jsonb using gin as storage integer operator 7 pg_catalog.@>(jsonb, jsonb),
	operator 15 pg_catalog.@?(jsonb, jsonpath),
	operator 16 pg_catalog.@@(jsonb, jsonpath);

alter operator class pg_catalog.jsonb_path_ops using gin owner to "kim-uijin";

create operator family pg_catalog.integer_minmax_ops using brin;

alter operator family pg_catalog.integer_minmax_ops using brin add
    function 1(smallint, smallint) pg_catalog.brin_minmax_opcinfo(internal),
    function 1(bigint, bigint) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(bigint, bigint) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(bigint, bigint) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(bigint, bigint) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 2(smallint, smallint) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(smallint, smallint) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(smallint, smallint) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(integer, integer) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(integer, integer) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(integer, integer) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(integer, integer) pg_catalog.brin_minmax_union(internal, internal, internal);

alter operator family pg_catalog.integer_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int8_minmax_ops default for type bigint using brin family pg_catalog.integer_minmax_ops as storage bigint operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint);

alter operator class pg_catalog.int8_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int2_minmax_ops default for type smallint using brin family pg_catalog.integer_minmax_ops as storage smallint operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint);

alter operator class pg_catalog.int2_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int4_minmax_ops default for type integer using brin family pg_catalog.integer_minmax_ops as storage integer operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 4 pg_catalog.>=(integer, integer),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 3 pg_catalog.=(integer, bigint);

alter operator class pg_catalog.int4_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.numeric_minmax_ops using brin;

alter operator family pg_catalog.numeric_minmax_ops using brin add
    function 4(numeric, numeric) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(numeric, numeric) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(numeric, numeric) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(numeric, numeric) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.numeric_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.numeric_minmax_ops default for type numeric using brin as storage numeric operator 1 pg_catalog.<(numeric, numeric),
	operator 2 pg_catalog.<=(numeric, numeric),
	operator 3 pg_catalog.=(numeric, numeric),
	operator 4 pg_catalog.>=(numeric, numeric),
	operator 5 pg_catalog.>(numeric, numeric);

alter operator class pg_catalog.numeric_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.text_minmax_ops using brin;

alter operator family pg_catalog.text_minmax_ops using brin add
    function 2(text, text) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 4(text, text) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 3(text, text) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 1(text, text) pg_catalog.brin_minmax_opcinfo(internal);

alter operator family pg_catalog.text_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.text_minmax_ops default for type text using brin as storage text operator 2 pg_catalog.<=(text, text),
	operator 5 pg_catalog.>(text, text),
	operator 4 pg_catalog.>=(text, text),
	operator 3 pg_catalog.=(text, text),
	operator 1 pg_catalog.<(text, text);

alter operator class pg_catalog.text_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.timetz_minmax_ops using brin;

alter operator family pg_catalog.timetz_minmax_ops using brin add
    function 4(time with time zone, time with time zone) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(time with time zone, time with time zone) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(time with time zone, time with time zone) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(time with time zone, time with time zone) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.timetz_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timetz_minmax_ops default for type time with time zone using brin as storage time with time zone operator 2 pg_catalog.<=(time with time zone, time with time zone),
	operator 1 pg_catalog.<(time with time zone, time with time zone),
	operator 5 pg_catalog.>(time with time zone, time with time zone),
	operator 4 pg_catalog.>=(time with time zone, time with time zone),
	operator 3 pg_catalog.=(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.datetime_minmax_ops using brin;

alter operator family pg_catalog.datetime_minmax_ops using brin add
    function 4(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(date, date) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(date, date) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(date, date) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(date, date) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.datetime_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.date_minmax_ops default for type date using brin family pg_catalog.datetime_minmax_ops as storage date operator 3 pg_catalog.=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone);

alter operator class pg_catalog.date_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamp_minmax_ops default for type timestamp without time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp without time zone operator 3 pg_catalog.=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone);

alter operator class pg_catalog.timestamp_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamptz_minmax_ops default for type timestamp with time zone using brin family pg_catalog.datetime_minmax_ops as storage timestamp with time zone operator 3 pg_catalog.=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 4 pg_catalog.>=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone);

alter operator class pg_catalog.timestamptz_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.char_minmax_ops using brin;

alter operator family pg_catalog.char_minmax_ops using brin add
    function 1("char", "char") pg_catalog.brin_minmax_opcinfo(internal),
    function 2("char", "char") pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3("char", "char") pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4("char", "char") pg_catalog.brin_minmax_union(internal, internal, internal);

alter operator family pg_catalog.char_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.char_minmax_ops default for type "char" using brin as storage "char" operator 3 pg_catalog.=("char", "char"),
	operator 4 pg_catalog.>=("char", "char"),
	operator 5 pg_catalog.>("char", "char"),
	operator 1 pg_catalog.<("char", "char"),
	operator 2 pg_catalog.<=("char", "char");

alter operator class pg_catalog.char_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.bytea_minmax_ops using brin;

alter operator family pg_catalog.bytea_minmax_ops using brin add
    function 3(bytea, bytea) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 1(bytea, bytea) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(bytea, bytea) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 4(bytea, bytea) pg_catalog.brin_minmax_union(internal, internal, internal);

alter operator family pg_catalog.bytea_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.bytea_minmax_ops default for type bytea using brin as storage bytea operator 5 pg_catalog.>(bytea, bytea),
	operator 4 pg_catalog.>=(bytea, bytea),
	operator 1 pg_catalog.<(bytea, bytea),
	operator 3 pg_catalog.=(bytea, bytea),
	operator 2 pg_catalog.<=(bytea, bytea);

alter operator class pg_catalog.bytea_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.name_minmax_ops using brin;

alter operator family pg_catalog.name_minmax_ops using brin add
    function 3(name, name) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 1(name, name) pg_catalog.brin_minmax_opcinfo(internal),
    function 4(name, name) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 2(name, name) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.name_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.name_minmax_ops default for type name using brin as storage name operator 4 pg_catalog.>=(name, name),
	operator 1 pg_catalog.<(name, name),
	operator 2 pg_catalog.<=(name, name),
	operator 3 pg_catalog.=(name, name),
	operator 5 pg_catalog.>(name, name);

alter operator class pg_catalog.name_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.oid_minmax_ops using brin;

alter operator family pg_catalog.oid_minmax_ops using brin add
    function 1(oid, oid) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(oid, oid) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 4(oid, oid) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 3(oid, oid) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.oid_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.oid_minmax_ops default for type oid using brin as storage oid operator 2 pg_catalog.<=(oid, oid),
	operator 1 pg_catalog.<(oid, oid),
	operator 5 pg_catalog.>(oid, oid),
	operator 4 pg_catalog.>=(oid, oid),
	operator 3 pg_catalog.=(oid, oid);

alter operator class pg_catalog.oid_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.tid_minmax_ops using brin;

alter operator family pg_catalog.tid_minmax_ops using brin add
    function 4(tid, tid) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(tid, tid) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(tid, tid) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(tid, tid) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.tid_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.tid_minmax_ops default for type tid using brin as storage tid operator 3 pg_catalog.=(tid, tid),
	operator 1 pg_catalog.<(tid, tid),
	operator 2 pg_catalog.<=(tid, tid),
	operator 4 pg_catalog.>=(tid, tid),
	operator 5 pg_catalog.>(tid, tid);

alter operator class pg_catalog.tid_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.float_minmax_ops using brin;

alter operator family pg_catalog.float_minmax_ops using brin add
    function 2(real, real) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 1(real, real) pg_catalog.brin_minmax_opcinfo(internal),
    function 3(double precision, double precision) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(double precision, double precision) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(double precision, double precision) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(double precision, double precision) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(real, real) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(real, real) pg_catalog.brin_minmax_union(internal, internal, internal);

alter operator family pg_catalog.float_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float4_minmax_ops default for type real using brin family pg_catalog.float_minmax_ops as storage real operator 5 pg_catalog.>(double precision, double precision),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 2 pg_catalog.<=(real, real),
	operator 3 pg_catalog.=(real, real),
	operator 1 pg_catalog.<(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision);

alter operator class pg_catalog.float4_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float8_minmax_ops default for type double precision using brin family pg_catalog.float_minmax_ops as storage double precision operator 5 pg_catalog.>(double precision, double precision),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 2 pg_catalog.<=(real, real),
	operator 3 pg_catalog.=(real, real),
	operator 1 pg_catalog.<(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision);

alter operator class pg_catalog.float8_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr_minmax_ops using brin;

alter operator family pg_catalog.macaddr_minmax_ops using brin add
    function 4(macaddr, macaddr) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(macaddr, macaddr) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(macaddr, macaddr) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(macaddr, macaddr) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.macaddr_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr_minmax_ops default for type macaddr using brin as storage macaddr operator 3 pg_catalog.=(macaddr, macaddr),
	operator 2 pg_catalog.<=(macaddr, macaddr),
	operator 5 pg_catalog.>(macaddr, macaddr),
	operator 1 pg_catalog.<(macaddr, macaddr),
	operator 4 pg_catalog.>=(macaddr, macaddr);

alter operator class pg_catalog.macaddr_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.network_minmax_ops using brin;

alter operator family pg_catalog.network_minmax_ops using brin add
    function 3(inet, inet) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(inet, inet) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(inet, inet) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(inet, inet) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.network_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.inet_minmax_ops for type inet using brin family pg_catalog.network_minmax_ops as storage inet operator 5 pg_catalog.>(inet, inet),
	operator 4 pg_catalog.>=(inet, inet),
	operator 3 pg_catalog.=(inet, inet),
	operator 2 pg_catalog.<=(inet, inet),
	operator 1 pg_catalog.<(inet, inet);

alter operator class pg_catalog.inet_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.bpchar_minmax_ops using brin;

alter operator family pg_catalog.bpchar_minmax_ops using brin add
    function 3(character, character) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(character, character) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 2(character, character) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 1(character, character) pg_catalog.brin_minmax_opcinfo(internal);

alter operator family pg_catalog.bpchar_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.bpchar_minmax_ops default for type character using brin as storage character operator 2 pg_catalog.<=(char, char),
	operator 1 pg_catalog.<(char, char),
	operator 5 pg_catalog.>(char, char),
	operator 4 pg_catalog.>=(char, char),
	operator 3 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.time_minmax_ops using brin;

alter operator family pg_catalog.time_minmax_ops using brin add
    function 2(time without time zone, time without time zone) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 4(time without time zone, time without time zone) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 3(time without time zone, time without time zone) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 1(time without time zone, time without time zone) pg_catalog.brin_minmax_opcinfo(internal);

alter operator family pg_catalog.time_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.time_minmax_ops default for type time without time zone using brin as storage time without time zone operator 3 pg_catalog.=(time, time),
	operator 5 pg_catalog.>(time, time),
	operator 4 pg_catalog.>=(time, time),
	operator 2 pg_catalog.<=(time, time),
	operator 1 pg_catalog.<(time, time);

alter operator class pg_catalog.time_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.interval_minmax_ops using brin;

alter operator family pg_catalog.interval_minmax_ops using brin add
    function 2(interval, interval) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 4(interval, interval) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(interval, interval) pg_catalog.brin_minmax_opcinfo(internal),
    function 3(interval, interval) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.interval_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.interval_minmax_ops default for type interval using brin as storage interval operator 1 pg_catalog.<(interval, interval),
	operator 2 pg_catalog.<=(interval, interval),
	operator 3 pg_catalog.=(interval, interval),
	operator 4 pg_catalog.>=(interval, interval),
	operator 5 pg_catalog.>(interval, interval);

alter operator class pg_catalog.interval_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.bit_minmax_ops using brin;

alter operator family pg_catalog.bit_minmax_ops using brin add
    function 3(bit, bit) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 4(bit, bit) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(bit, bit) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(bit, bit) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.bit_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.bit_minmax_ops default for type bit using brin as storage bit operator 4 pg_catalog.>=(bit, bit),
	operator 1 pg_catalog.<(bit, bit),
	operator 5 pg_catalog.>(bit, bit),
	operator 2 pg_catalog.<=(bit, bit),
	operator 3 pg_catalog.=(bit, bit);

alter operator class pg_catalog.bit_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.varbit_minmax_ops using brin;

alter operator family pg_catalog.varbit_minmax_ops using brin add
    function 4(bit varying, bit varying) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(bit varying, bit varying) pg_catalog.brin_minmax_opcinfo(internal),
    function 2(bit varying, bit varying) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 3(bit varying, bit varying) pg_catalog.brin_minmax_consistent(internal, internal, internal);

alter operator family pg_catalog.varbit_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.varbit_minmax_ops default for type bit varying using brin as storage bit varying operator 3 pg_catalog.=(bit varying, bit varying),
	operator 5 pg_catalog.>(bit varying, bit varying),
	operator 4 pg_catalog.>=(bit varying, bit varying),
	operator 2 pg_catalog.<=(bit varying, bit varying),
	operator 1 pg_catalog.<(bit varying, bit varying);

alter operator class pg_catalog.varbit_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.uuid_minmax_ops using brin;

alter operator family pg_catalog.uuid_minmax_ops using brin add
    function 3(uuid, uuid) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 2(uuid, uuid) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal),
    function 1(uuid, uuid) pg_catalog.brin_minmax_opcinfo(internal),
    function 4(uuid, uuid) pg_catalog.brin_minmax_union(internal, internal, internal);

alter operator family pg_catalog.uuid_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.uuid_minmax_ops default for type uuid using brin as storage uuid operator 5 pg_catalog.>(uuid, uuid),
	operator 1 pg_catalog.<(uuid, uuid),
	operator 2 pg_catalog.<=(uuid, uuid),
	operator 3 pg_catalog.=(uuid, uuid),
	operator 4 pg_catalog.>=(uuid, uuid);

alter operator class pg_catalog.uuid_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.pg_lsn_minmax_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_ops using brin add
    function 1(pg_lsn, pg_lsn) pg_catalog.brin_minmax_opcinfo(internal),
    function 4(pg_lsn, pg_lsn) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 3(pg_lsn, pg_lsn) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 2(pg_lsn, pg_lsn) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.pg_lsn_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.pg_lsn_minmax_ops default for type pg_lsn using brin as storage pg_lsn operator 5 pg_catalog.>(pg_lsn, pg_lsn),
	operator 4 pg_catalog.>=(pg_lsn, pg_lsn),
	operator 3 pg_catalog.=(pg_lsn, pg_lsn),
	operator 2 pg_catalog.<=(pg_lsn, pg_lsn),
	operator 1 pg_catalog.<(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.network_inclusion_ops using brin;

alter operator family pg_catalog.network_inclusion_ops using brin add
    function 3(inet, inet) pg_catalog.brin_inclusion_consistent(internal, internal, internal),
    function 4(inet, inet) pg_catalog.brin_inclusion_union(internal, internal, internal),
    function 11(inet, inet) pg_catalog.inet_merge(inet, inet),
    function 12(inet, inet) pg_catalog.inet_same_family(inet, inet),
    function 1(inet, inet) pg_catalog.brin_inclusion_opcinfo(internal),
    function 13(inet, inet) pg_catalog.network_supeq(inet, inet),
    function 2(inet, inet) pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.network_inclusion_ops using brin owner to "kim-uijin";

create operator class pg_catalog.inet_inclusion_ops default for type inet using brin family pg_catalog.network_inclusion_ops as storage inet operator 3 pg_catalog.&&(inet, inet),
	operator 7 pg_catalog.>>=(inet, inet),
	operator 8 pg_catalog.<<=(inet, inet),
	operator 18 pg_catalog.=(inet, inet),
	operator 24 pg_catalog.>>(inet, inet),
	operator 26 pg_catalog.<<(inet, inet);

alter operator class pg_catalog.inet_inclusion_ops using brin owner to "kim-uijin";

create operator family pg_catalog.range_inclusion_ops using brin;

alter operator family pg_catalog.range_inclusion_ops using brin add
    function 3(anyrange, anyrange) pg_catalog.brin_inclusion_consistent(internal, internal, internal),
    function 1(anyrange, anyrange) pg_catalog.brin_inclusion_opcinfo(internal),
    function 2(anyrange, anyrange) pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal),
    function 4(anyrange, anyrange) pg_catalog.brin_inclusion_union(internal, internal, internal),
    function 11(anyrange, anyrange) pg_catalog.range_merge(anyrange, anyrange),
    function 13(anyrange, anyrange) pg_catalog.range_contains(anyrange, anyrange),
    function 14(anyrange, anyrange) pg_catalog.isempty(anyrange);

alter operator family pg_catalog.range_inclusion_ops using brin owner to "kim-uijin";

create operator class pg_catalog.range_inclusion_ops default for type anyrange using brin as storage anyrange operator 3 pg_catalog.&&(anyrange, anyrange),
	operator 1 pg_catalog.<<(anyrange, anyrange),
	operator 4 pg_catalog.&>(anyrange, anyrange),
	operator 5 pg_catalog.>>(anyrange, anyrange),
	operator 7 pg_catalog.@>(anyrange, anyrange),
	operator 8 pg_catalog.<@(anyrange, anyrange),
	operator 16 pg_catalog.@>(anyrange, anyelement),
	operator 17 pg_catalog.-|-(anyrange, anyrange),
	operator 23 pg_catalog.>=(anyrange, anyrange),
	operator 22 pg_catalog.>(anyrange, anyrange),
	operator 21 pg_catalog.<=(anyrange, anyrange),
	operator 20 pg_catalog.<(anyrange, anyrange),
	operator 18 pg_catalog.=(anyrange, anyrange),
	operator 2 pg_catalog.&<(anyrange, anyrange);

alter operator class pg_catalog.range_inclusion_ops using brin owner to "kim-uijin";

create operator family pg_catalog.box_inclusion_ops using brin;

alter operator family pg_catalog.box_inclusion_ops using brin add
    function 11(box, box) pg_catalog.bound_box(box, box),
    function 1(box, box) pg_catalog.brin_inclusion_opcinfo(internal),
    function 2(box, box) pg_catalog.brin_inclusion_add_value(internal, internal, internal, internal),
    function 3(box, box) pg_catalog.brin_inclusion_consistent(internal, internal, internal),
    function 4(box, box) pg_catalog.brin_inclusion_union(internal, internal, internal),
    function 13(box, box) pg_catalog.box_contain(box, box);

alter operator family pg_catalog.box_inclusion_ops using brin owner to "kim-uijin";

create operator class pg_catalog.box_inclusion_ops default for type box using brin as storage box operator 4 pg_catalog.&>(box, box),
	operator 7 pg_catalog.@>(box, point),
	operator 12 pg_catalog.|&>(box, box),
	operator 7 pg_catalog.@>(box, box),
	operator 11 pg_catalog.|>>(box, box),
	operator 10 pg_catalog.<<|(box, box),
	operator 6 pg_catalog.~=(box, box),
	operator 8 pg_catalog.<@(box, box),
	operator 9 pg_catalog.&<|(box, box),
	operator 5 pg_catalog.>>(box, box),
	operator 3 pg_catalog.&&(box, box),
	operator 2 pg_catalog.&<(box, box),
	operator 1 pg_catalog.<<(box, box);

alter operator class pg_catalog.box_inclusion_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr8_minmax_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_ops using brin add
    function 4(macaddr8, macaddr8) pg_catalog.brin_minmax_union(internal, internal, internal),
    function 1(macaddr8, macaddr8) pg_catalog.brin_minmax_opcinfo(internal),
    function 3(macaddr8, macaddr8) pg_catalog.brin_minmax_consistent(internal, internal, internal),
    function 2(macaddr8, macaddr8) pg_catalog.brin_minmax_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.macaddr8_minmax_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr8_minmax_ops default for type macaddr8 using brin as storage macaddr8 operator 4 pg_catalog.>=(macaddr8, macaddr8),
	operator 1 pg_catalog.<(macaddr8, macaddr8),
	operator 5 pg_catalog.>(macaddr8, macaddr8),
	operator 2 pg_catalog.<=(macaddr8, macaddr8),
	operator 3 pg_catalog.=(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_minmax_ops using brin owner to "kim-uijin";

create operator family pg_catalog.multirange_ops using btree;

alter operator family pg_catalog.multirange_ops using btree add
    function 1(anymultirange, anymultirange) pg_catalog.multirange_cmp(anymultirange, anymultirange);

alter operator family pg_catalog.multirange_ops using btree owner to "kim-uijin";

create operator class pg_catalog.multirange_ops default for type anymultirange using btree as
    operator 3 pg_catalog.=(anymultirange, anymultirange),
    operator 4 pg_catalog.>=(anymultirange, anymultirange),
    operator 5 pg_catalog.>(anymultirange, anymultirange),
    operator 2 pg_catalog.<=(anymultirange, anymultirange),
    operator 1 pg_catalog.<(anymultirange, anymultirange);

alter operator class pg_catalog.multirange_ops using btree owner to "kim-uijin";

create operator family pg_catalog.multirange_ops using hash;

alter operator family pg_catalog.multirange_ops using hash add
    function 2(anymultirange, anymultirange) pg_catalog.hash_multirange_extended(anymultirange, bigint),
    function 1(anymultirange, anymultirange) pg_catalog.hash_multirange(anymultirange);

alter operator family pg_catalog.multirange_ops using hash owner to "kim-uijin";

create operator class pg_catalog.multirange_ops default for type anymultirange using hash as
    operator 1 pg_catalog.=(anymultirange, anymultirange);

alter operator class pg_catalog.multirange_ops using hash owner to "kim-uijin";

create operator family pg_catalog.integer_bloom_ops using brin;

alter operator family pg_catalog.integer_bloom_ops using brin add
    function 5(bigint, bigint) pg_catalog.brin_bloom_options(internal),
    function 4(bigint, bigint) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(bigint, bigint) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(bigint, bigint) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(bigint, bigint) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(smallint, smallint) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 11(integer, integer) pg_catalog.hashint4(integer),
    function 5(integer, integer) pg_catalog.brin_bloom_options(internal),
    function 4(integer, integer) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(integer, integer) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(integer, integer) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(integer, integer) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(smallint, smallint) pg_catalog.hashint2(smallint),
    function 5(smallint, smallint) pg_catalog.brin_bloom_options(internal),
    function 4(smallint, smallint) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(smallint, smallint) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 1(smallint, smallint) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(bigint, bigint) pg_catalog.hashint8(bigint);

alter operator family pg_catalog.integer_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int8_bloom_ops for type bigint using brin family pg_catalog.integer_bloom_ops as storage bigint operator 1 pg_catalog.=(smallint, smallint),
	operator 1 pg_catalog.=(bigint, bigint),
	operator 1 pg_catalog.=(integer, integer);

alter operator class pg_catalog.int8_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int2_bloom_ops for type smallint using brin family pg_catalog.integer_bloom_ops as storage smallint operator 1 pg_catalog.=(smallint, smallint),
	operator 1 pg_catalog.=(bigint, bigint),
	operator 1 pg_catalog.=(integer, integer);

alter operator class pg_catalog.int2_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int4_bloom_ops for type integer using brin family pg_catalog.integer_bloom_ops as storage integer operator 1 pg_catalog.=(smallint, smallint),
	operator 1 pg_catalog.=(bigint, bigint),
	operator 1 pg_catalog.=(integer, integer);

alter operator class pg_catalog.int4_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.text_bloom_ops using brin;

alter operator family pg_catalog.text_bloom_ops using brin add
    function 11(text, text) pg_catalog.hashtext(text),
    function 1(text, text) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(text, text) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(text, text) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(text, text) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 5(text, text) pg_catalog.brin_bloom_options(internal);

alter operator family pg_catalog.text_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.text_bloom_ops for type text using brin as storage text operator 1 pg_catalog.=(text, text);

alter operator class pg_catalog.text_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.numeric_bloom_ops using brin;

alter operator family pg_catalog.numeric_bloom_ops using brin add
    function 2(numeric, numeric) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(numeric, numeric) pg_catalog.brin_bloom_opcinfo(internal),
    function 3(numeric, numeric) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(numeric, numeric) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 5(numeric, numeric) pg_catalog.brin_bloom_options(internal),
    function 11(numeric, numeric) pg_catalog.hash_numeric(numeric);

alter operator family pg_catalog.numeric_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.numeric_bloom_ops for type numeric using brin as storage numeric operator 1 pg_catalog.=(numeric, numeric);

alter operator class pg_catalog.numeric_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.timetz_bloom_ops using brin;

alter operator family pg_catalog.timetz_bloom_ops using brin add
    function 5(time with time zone, time with time zone) pg_catalog.brin_bloom_options(internal),
    function 1(time with time zone, time with time zone) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(time with time zone, time with time zone) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(time with time zone, time with time zone) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(time with time zone, time with time zone) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 11(time with time zone, time with time zone) pg_catalog.timetz_hash(time with time zone);

alter operator family pg_catalog.timetz_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timetz_bloom_ops for type time with time zone using brin as storage time with time zone operator 1 pg_catalog.=(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.datetime_bloom_ops using brin;

alter operator family pg_catalog.datetime_bloom_ops using brin add
    function 5(timestamp with time zone, timestamp with time zone) pg_catalog.brin_bloom_options(internal),
    function 11(date, date) pg_catalog.hashint4(integer),
    function 5(date, date) pg_catalog.brin_bloom_options(internal),
    function 4(date, date) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(date, date) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(date, date) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 11(timestamp without time zone, timestamp without time zone) pg_catalog.timestamp_hash(timestamp),
    function 5(timestamp without time zone, timestamp without time zone) pg_catalog.brin_bloom_options(internal),
    function 4(timestamp without time zone, timestamp without time zone) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(timestamp without time zone, timestamp without time zone) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.brin_bloom_opcinfo(internal),
    function 3(timestamp with time zone, timestamp with time zone) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(timestamp with time zone, timestamp with time zone) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(date, date) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(timestamp with time zone, timestamp with time zone) pg_catalog.timestamp_hash(timestamp);

alter operator family pg_catalog.datetime_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.date_bloom_ops for type date using brin family pg_catalog.datetime_bloom_ops as storage date operator 1 pg_catalog.=(date, date),
	operator 1 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.=(timestamp, timestamp);

alter operator class pg_catalog.date_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamp_bloom_ops for type timestamp without time zone using brin family pg_catalog.datetime_bloom_ops as storage timestamp without time zone operator 1 pg_catalog.=(date, date),
	operator 1 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.=(timestamp, timestamp);

alter operator class pg_catalog.timestamp_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamptz_bloom_ops for type timestamp with time zone using brin family pg_catalog.datetime_bloom_ops as storage timestamp with time zone operator 1 pg_catalog.=(date, date),
	operator 1 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 1 pg_catalog.=(timestamp, timestamp);

alter operator class pg_catalog.timestamptz_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.char_bloom_ops using brin;

alter operator family pg_catalog.char_bloom_ops using brin add
    function 11("char", "char") pg_catalog.hashchar("char"),
    function 1("char", "char") pg_catalog.brin_bloom_opcinfo(internal),
    function 4("char", "char") pg_catalog.brin_bloom_union(internal, internal, internal),
    function 2("char", "char") pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3("char", "char") pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 5("char", "char") pg_catalog.brin_bloom_options(internal);

alter operator family pg_catalog.char_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.char_bloom_ops for type "char" using brin as storage "char" operator 1 pg_catalog.=("char", "char");

alter operator class pg_catalog.char_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.bytea_bloom_ops using brin;

alter operator family pg_catalog.bytea_bloom_ops using brin add
    function 2(bytea, bytea) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 5(bytea, bytea) pg_catalog.brin_bloom_options(internal),
    function 11(bytea, bytea) pg_catalog.hashvarlena(internal),
    function 1(bytea, bytea) pg_catalog.brin_bloom_opcinfo(internal),
    function 4(bytea, bytea) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(bytea, bytea) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer);

alter operator family pg_catalog.bytea_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.bytea_bloom_ops for type bytea using brin as storage bytea operator 1 pg_catalog.=(bytea, bytea);

alter operator class pg_catalog.bytea_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.name_bloom_ops using brin;

alter operator family pg_catalog.name_bloom_ops using brin add
    function 3(name, name) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 1(name, name) pg_catalog.brin_bloom_opcinfo(internal),
    function 4(name, name) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 2(name, name) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 5(name, name) pg_catalog.brin_bloom_options(internal),
    function 11(name, name) pg_catalog.hashname(name);

alter operator family pg_catalog.name_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.name_bloom_ops for type name using brin as storage name operator 1 pg_catalog.=(name, name);

alter operator class pg_catalog.name_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.oid_bloom_ops using brin;

alter operator family pg_catalog.oid_bloom_ops using brin add
    function 2(oid, oid) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 11(oid, oid) pg_catalog.hashoid(oid),
    function 5(oid, oid) pg_catalog.brin_bloom_options(internal),
    function 4(oid, oid) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(oid, oid) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 1(oid, oid) pg_catalog.brin_bloom_opcinfo(internal);

alter operator family pg_catalog.oid_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.oid_bloom_ops for type oid using brin as storage oid operator 1 pg_catalog.=(oid, oid);

alter operator class pg_catalog.oid_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.tid_bloom_ops using brin;

alter operator family pg_catalog.tid_bloom_ops using brin add
    function 1(tid, tid) pg_catalog.brin_bloom_opcinfo(internal),
    function 3(tid, tid) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(tid, tid) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 5(tid, tid) pg_catalog.brin_bloom_options(internal),
    function 11(tid, tid) pg_catalog.hashtid(tid),
    function 2(tid, tid) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.tid_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.tid_bloom_ops for type tid using brin as storage tid operator 1 pg_catalog.=(tid, tid);

alter operator class pg_catalog.tid_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.float_bloom_ops using brin;

alter operator family pg_catalog.float_bloom_ops using brin add
    function 3(double precision, double precision) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(double precision, double precision) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(double precision, double precision) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(real, real) pg_catalog.hashfloat4(real),
    function 5(real, real) pg_catalog.brin_bloom_options(internal),
    function 3(real, real) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(real, real) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 2(real, real) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(real, real) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(double precision, double precision) pg_catalog.hashfloat8(double precision),
    function 5(double precision, double precision) pg_catalog.brin_bloom_options(internal),
    function 4(double precision, double precision) pg_catalog.brin_bloom_union(internal, internal, internal);

alter operator family pg_catalog.float_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float4_bloom_ops for type real using brin family pg_catalog.float_bloom_ops as storage real operator 1 pg_catalog.=(real, real),
	operator 1 pg_catalog.=(double precision, double precision);

alter operator class pg_catalog.float4_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float8_bloom_ops for type double precision using brin family pg_catalog.float_bloom_ops as storage double precision operator 1 pg_catalog.=(real, real),
	operator 1 pg_catalog.=(double precision, double precision);

alter operator class pg_catalog.float8_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr_bloom_ops using brin;

alter operator family pg_catalog.macaddr_bloom_ops using brin add
    function 11(macaddr, macaddr) pg_catalog.hashmacaddr(macaddr),
    function 4(macaddr, macaddr) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 3(macaddr, macaddr) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(macaddr, macaddr) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(macaddr, macaddr) pg_catalog.brin_bloom_opcinfo(internal),
    function 5(macaddr, macaddr) pg_catalog.brin_bloom_options(internal);

alter operator family pg_catalog.macaddr_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr_bloom_ops for type macaddr using brin as storage macaddr operator 1 pg_catalog.=(macaddr, macaddr);

alter operator class pg_catalog.macaddr_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr8_bloom_ops using brin;

alter operator family pg_catalog.macaddr8_bloom_ops using brin add
    function 11(macaddr8, macaddr8) pg_catalog.hashmacaddr8(macaddr8),
    function 1(macaddr8, macaddr8) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(macaddr8, macaddr8) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(macaddr8, macaddr8) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(macaddr8, macaddr8) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 5(macaddr8, macaddr8) pg_catalog.brin_bloom_options(internal);

alter operator family pg_catalog.macaddr8_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr8_bloom_ops for type macaddr8 using brin as storage macaddr8 operator 1 pg_catalog.=(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.network_bloom_ops using brin;

alter operator family pg_catalog.network_bloom_ops using brin add
    function 5(inet, inet) pg_catalog.brin_bloom_options(internal),
    function 2(inet, inet) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(inet, inet) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(inet, inet) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 1(inet, inet) pg_catalog.brin_bloom_opcinfo(internal),
    function 11(inet, inet) pg_catalog.hashinet(inet);

alter operator family pg_catalog.network_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.inet_bloom_ops for type inet using brin family pg_catalog.network_bloom_ops as storage inet operator 1 pg_catalog.=(inet, inet);

alter operator class pg_catalog.inet_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.bpchar_bloom_ops using brin;

alter operator family pg_catalog.bpchar_bloom_ops using brin add
    function 5(character, character) pg_catalog.brin_bloom_options(internal),
    function 11(character, character) pg_catalog.hashbpchar(char),
    function 1(character, character) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(character, character) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(character, character) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(character, character) pg_catalog.brin_bloom_union(internal, internal, internal);

alter operator family pg_catalog.bpchar_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.bpchar_bloom_ops for type character using brin as storage character operator 1 pg_catalog.=(char, char);

alter operator class pg_catalog.bpchar_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.time_bloom_ops using brin;

alter operator family pg_catalog.time_bloom_ops using brin add
    function 5(time without time zone, time without time zone) pg_catalog.brin_bloom_options(internal),
    function 2(time without time zone, time without time zone) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(time without time zone, time without time zone) pg_catalog.brin_bloom_opcinfo(internal),
    function 3(time without time zone, time without time zone) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 4(time without time zone, time without time zone) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 11(time without time zone, time without time zone) pg_catalog.time_hash(time);

alter operator family pg_catalog.time_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.time_bloom_ops for type time without time zone using brin as storage time without time zone operator 1 pg_catalog.=(time, time);

alter operator class pg_catalog.time_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.interval_bloom_ops using brin;

alter operator family pg_catalog.interval_bloom_ops using brin add
    function 3(interval, interval) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 2(interval, interval) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 1(interval, interval) pg_catalog.brin_bloom_opcinfo(internal),
    function 4(interval, interval) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 5(interval, interval) pg_catalog.brin_bloom_options(internal),
    function 11(interval, interval) pg_catalog.interval_hash(interval);

alter operator family pg_catalog.interval_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.interval_bloom_ops for type interval using brin as storage interval operator 1 pg_catalog.=(interval, interval);

alter operator class pg_catalog.interval_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.uuid_bloom_ops using brin;

alter operator family pg_catalog.uuid_bloom_ops using brin add
    function 4(uuid, uuid) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 11(uuid, uuid) pg_catalog.uuid_hash(uuid),
    function 5(uuid, uuid) pg_catalog.brin_bloom_options(internal),
    function 1(uuid, uuid) pg_catalog.brin_bloom_opcinfo(internal),
    function 2(uuid, uuid) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(uuid, uuid) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer);

alter operator family pg_catalog.uuid_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.uuid_bloom_ops for type uuid using brin as storage uuid operator 1 pg_catalog.=(uuid, uuid);

alter operator class pg_catalog.uuid_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.pg_lsn_bloom_ops using brin;

alter operator family pg_catalog.pg_lsn_bloom_ops using brin add
    function 5(pg_lsn, pg_lsn) pg_catalog.brin_bloom_options(internal),
    function 11(pg_lsn, pg_lsn) pg_catalog.pg_lsn_hash(pg_lsn),
    function 4(pg_lsn, pg_lsn) pg_catalog.brin_bloom_union(internal, internal, internal),
    function 2(pg_lsn, pg_lsn) pg_catalog.brin_bloom_add_value(internal, internal, internal, internal),
    function 3(pg_lsn, pg_lsn) pg_catalog.brin_bloom_consistent(internal, internal, internal, integer),
    function 1(pg_lsn, pg_lsn) pg_catalog.brin_bloom_opcinfo(internal);

alter operator family pg_catalog.pg_lsn_bloom_ops using brin owner to "kim-uijin";

create operator class pg_catalog.pg_lsn_bloom_ops for type pg_lsn using brin as storage pg_lsn operator 1 pg_catalog.=(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_bloom_ops using brin owner to "kim-uijin";

create operator family pg_catalog.integer_minmax_multi_ops using brin;

alter operator family pg_catalog.integer_minmax_multi_ops using brin add
    function 3(bigint, bigint) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(bigint, bigint) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 5(bigint, bigint) pg_catalog.brin_minmax_multi_options(internal),
    function 11(bigint, bigint) pg_catalog.brin_minmax_multi_distance_int8(internal, internal),
    function 1(smallint, smallint) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(bigint, bigint) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 11(integer, integer) pg_catalog.brin_minmax_multi_distance_int4(internal, internal),
    function 5(integer, integer) pg_catalog.brin_minmax_multi_options(internal),
    function 4(integer, integer) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(integer, integer) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(integer, integer) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(integer, integer) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(smallint, smallint) pg_catalog.brin_minmax_multi_distance_int2(internal, internal),
    function 5(smallint, smallint) pg_catalog.brin_minmax_multi_options(internal),
    function 4(smallint, smallint) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(smallint, smallint) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(smallint, smallint) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(bigint, bigint) pg_catalog.brin_minmax_multi_opcinfo(internal);

alter operator family pg_catalog.integer_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int8_minmax_multi_ops for type bigint using brin family pg_catalog.integer_minmax_multi_ops as storage bigint operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 4 pg_catalog.>=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 1 pg_catalog.<(integer, smallint),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint);

alter operator class pg_catalog.int8_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int2_minmax_multi_ops for type smallint using brin family pg_catalog.integer_minmax_multi_ops as storage smallint operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 4 pg_catalog.>=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 1 pg_catalog.<(integer, smallint),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint);

alter operator class pg_catalog.int2_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.int4_minmax_multi_ops for type integer using brin family pg_catalog.integer_minmax_multi_ops as storage integer operator 4 pg_catalog.>=(bigint, bigint),
	operator 3 pg_catalog.=(bigint, bigint),
	operator 2 pg_catalog.<=(bigint, bigint),
	operator 1 pg_catalog.<(bigint, bigint),
	operator 4 pg_catalog.>=(integer, integer),
	operator 3 pg_catalog.=(integer, integer),
	operator 2 pg_catalog.<=(integer, integer),
	operator 1 pg_catalog.<(integer, integer),
	operator 5 pg_catalog.>(smallint, integer),
	operator 4 pg_catalog.>=(smallint, integer),
	operator 3 pg_catalog.=(smallint, integer),
	operator 2 pg_catalog.<=(smallint, integer),
	operator 1 pg_catalog.<(smallint, integer),
	operator 5 pg_catalog.>(smallint, bigint),
	operator 4 pg_catalog.>=(smallint, bigint),
	operator 3 pg_catalog.=(smallint, bigint),
	operator 2 pg_catalog.<=(smallint, bigint),
	operator 5 pg_catalog.>(smallint, smallint),
	operator 4 pg_catalog.>=(smallint, smallint),
	operator 3 pg_catalog.=(smallint, smallint),
	operator 2 pg_catalog.<=(smallint, smallint),
	operator 1 pg_catalog.<(smallint, bigint),
	operator 4 pg_catalog.>=(integer, bigint),
	operator 5 pg_catalog.>(integer, bigint),
	operator 1 pg_catalog.<(bigint, smallint),
	operator 3 pg_catalog.=(integer, bigint),
	operator 2 pg_catalog.<=(integer, bigint),
	operator 5 pg_catalog.>(bigint, bigint),
	operator 1 pg_catalog.<(integer, bigint),
	operator 5 pg_catalog.>(integer, smallint),
	operator 4 pg_catalog.>=(integer, smallint),
	operator 3 pg_catalog.=(integer, smallint),
	operator 2 pg_catalog.<=(integer, smallint),
	operator 1 pg_catalog.<(integer, smallint),
	operator 5 pg_catalog.>(integer, integer),
	operator 1 pg_catalog.<(smallint, smallint),
	operator 5 pg_catalog.>(bigint, integer),
	operator 4 pg_catalog.>=(bigint, integer),
	operator 3 pg_catalog.=(bigint, integer),
	operator 2 pg_catalog.<=(bigint, integer),
	operator 1 pg_catalog.<(bigint, integer),
	operator 5 pg_catalog.>(bigint, smallint),
	operator 4 pg_catalog.>=(bigint, smallint),
	operator 3 pg_catalog.=(bigint, smallint),
	operator 2 pg_catalog.<=(bigint, smallint);

alter operator class pg_catalog.int4_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.numeric_minmax_multi_ops using brin;

alter operator family pg_catalog.numeric_minmax_multi_ops using brin add
    function 5(numeric, numeric) pg_catalog.brin_minmax_multi_options(internal),
    function 4(numeric, numeric) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(numeric, numeric) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(numeric, numeric) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(numeric, numeric) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(numeric, numeric) pg_catalog.brin_minmax_multi_distance_numeric(internal, internal);

alter operator family pg_catalog.numeric_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.numeric_minmax_multi_ops for type numeric using brin as storage numeric operator 4 pg_catalog.>=(numeric, numeric),
	operator 1 pg_catalog.<(numeric, numeric),
	operator 5 pg_catalog.>(numeric, numeric),
	operator 2 pg_catalog.<=(numeric, numeric),
	operator 3 pg_catalog.=(numeric, numeric);

alter operator class pg_catalog.numeric_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.timetz_minmax_multi_ops using brin;

alter operator family pg_catalog.timetz_minmax_multi_ops using brin add
    function 4(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 11(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_distance_timetz(internal, internal),
    function 1(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 5(time with time zone, time with time zone) pg_catalog.brin_minmax_multi_options(internal);

alter operator family pg_catalog.timetz_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timetz_minmax_multi_ops for type time with time zone using brin as storage time with time zone operator 5 pg_catalog.>(time with time zone, time with time zone),
	operator 4 pg_catalog.>=(time with time zone, time with time zone),
	operator 3 pg_catalog.=(time with time zone, time with time zone),
	operator 2 pg_catalog.<=(time with time zone, time with time zone),
	operator 1 pg_catalog.<(time with time zone, time with time zone);

alter operator class pg_catalog.timetz_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.datetime_minmax_multi_ops using brin;

alter operator family pg_catalog.datetime_minmax_multi_ops using brin add
    function 2(date, date) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(date, date) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_distance_timestamp(internal, internal),
    function 5(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_options(internal),
    function 4(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(timestamp with time zone, timestamp with time zone) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_distance_timestamp(internal, internal),
    function 5(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_options(internal),
    function 4(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(timestamp without time zone, timestamp without time zone) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(date, date) pg_catalog.brin_minmax_multi_distance_date(internal, internal),
    function 5(date, date) pg_catalog.brin_minmax_multi_options(internal),
    function 4(date, date) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(date, date) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer);

alter operator family pg_catalog.datetime_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.date_minmax_multi_ops for type date using brin family pg_catalog.datetime_minmax_multi_ops as storage date operator 4 pg_catalog.>=(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.date_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamp_minmax_multi_ops for type timestamp without time zone using brin family pg_catalog.datetime_minmax_multi_ops as storage timestamp without time zone operator 4 pg_catalog.>=(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamp_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.timestamptz_minmax_multi_ops for type timestamp with time zone using brin family pg_catalog.datetime_minmax_multi_ops as storage timestamp with time zone operator 4 pg_catalog.>=(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp),
	operator 2 pg_catalog.<=(timestamp, timestamp),
	operator 3 pg_catalog.=(timestamp, timestamp),
	operator 4 pg_catalog.>=(timestamp, timestamp),
	operator 5 pg_catalog.>(timestamp, timestamp),
	operator 1 pg_catalog.<(timestamp, date),
	operator 2 pg_catalog.<=(timestamp, date),
	operator 3 pg_catalog.=(timestamp, date),
	operator 5 pg_catalog.>(timestamp, date),
	operator 1 pg_catalog.<(timestamp, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp, timestamp with time zone),
	operator 1 pg_catalog.<(date, date),
	operator 2 pg_catalog.<=(date, date),
	operator 3 pg_catalog.=(date, date),
	operator 4 pg_catalog.>=(date, date),
	operator 5 pg_catalog.>(date, date),
	operator 1 pg_catalog.<(date, timestamp),
	operator 2 pg_catalog.<=(date, timestamp),
	operator 3 pg_catalog.=(date, timestamp),
	operator 4 pg_catalog.>=(date, timestamp),
	operator 5 pg_catalog.>(date, timestamp),
	operator 1 pg_catalog.<(date, timestamp with time zone),
	operator 2 pg_catalog.<=(date, timestamp with time zone),
	operator 3 pg_catalog.=(date, timestamp with time zone),
	operator 4 pg_catalog.>=(date, timestamp with time zone),
	operator 5 pg_catalog.>(date, timestamp with time zone),
	operator 1 pg_catalog.<(timestamp with time zone, date),
	operator 2 pg_catalog.<=(timestamp with time zone, date),
	operator 3 pg_catalog.=(timestamp with time zone, date),
	operator 4 pg_catalog.>=(timestamp with time zone, date),
	operator 5 pg_catalog.>(timestamp with time zone, date),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp),
	operator 1 pg_catalog.<(timestamp with time zone, timestamp with time zone),
	operator 2 pg_catalog.<=(timestamp with time zone, timestamp with time zone),
	operator 3 pg_catalog.=(timestamp with time zone, timestamp with time zone),
	operator 4 pg_catalog.>=(timestamp with time zone, timestamp with time zone),
	operator 5 pg_catalog.>(timestamp with time zone, timestamp with time zone);

alter operator class pg_catalog.timestamptz_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.oid_minmax_multi_ops using brin;

alter operator family pg_catalog.oid_minmax_multi_ops using brin add
    function 5(oid, oid) pg_catalog.brin_minmax_multi_options(internal),
    function 11(oid, oid) pg_catalog.brin_minmax_multi_distance_int4(internal, internal),
    function 1(oid, oid) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(oid, oid) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(oid, oid) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(oid, oid) pg_catalog.brin_minmax_multi_union(internal, internal, internal);

alter operator family pg_catalog.oid_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.oid_minmax_multi_ops for type oid using brin as storage oid operator 5 pg_catalog.>(oid, oid),
	operator 1 pg_catalog.<(oid, oid),
	operator 2 pg_catalog.<=(oid, oid),
	operator 3 pg_catalog.=(oid, oid),
	operator 4 pg_catalog.>=(oid, oid);

alter operator class pg_catalog.oid_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.tid_minmax_multi_ops using brin;

alter operator family pg_catalog.tid_minmax_multi_ops using brin add
    function 3(tid, tid) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(tid, tid) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 11(tid, tid) pg_catalog.brin_minmax_multi_distance_tid(internal, internal),
    function 5(tid, tid) pg_catalog.brin_minmax_multi_options(internal),
    function 1(tid, tid) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(tid, tid) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal);

alter operator family pg_catalog.tid_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.tid_minmax_multi_ops for type tid using brin as storage tid operator 1 pg_catalog.<(tid, tid),
	operator 2 pg_catalog.<=(tid, tid),
	operator 3 pg_catalog.=(tid, tid),
	operator 4 pg_catalog.>=(tid, tid),
	operator 5 pg_catalog.>(tid, tid);

alter operator class pg_catalog.tid_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.float_minmax_multi_ops using brin;

alter operator family pg_catalog.float_minmax_multi_ops using brin add
    function 4(real, real) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 5(real, real) pg_catalog.brin_minmax_multi_options(internal),
    function 11(real, real) pg_catalog.brin_minmax_multi_distance_float4(internal, internal),
    function 1(double precision, double precision) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(double precision, double precision) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(double precision, double precision) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(double precision, double precision) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 5(double precision, double precision) pg_catalog.brin_minmax_multi_options(internal),
    function 11(double precision, double precision) pg_catalog.brin_minmax_multi_distance_float8(internal, internal),
    function 1(real, real) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(real, real) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(real, real) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer);

alter operator family pg_catalog.float_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float4_minmax_multi_ops for type real using brin family pg_catalog.float_minmax_multi_ops as storage real operator 5 pg_catalog.>(double precision, double precision),
	operator 3 pg_catalog.=(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision),
	operator 2 pg_catalog.<=(real, real),
	operator 1 pg_catalog.<(real, real),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision);

alter operator class pg_catalog.float4_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.float8_minmax_multi_ops for type double precision using brin family pg_catalog.float_minmax_multi_ops as storage double precision operator 5 pg_catalog.>(double precision, double precision),
	operator 3 pg_catalog.=(real, real),
	operator 4 pg_catalog.>=(real, real),
	operator 5 pg_catalog.>(real, real),
	operator 1 pg_catalog.<(real, double precision),
	operator 2 pg_catalog.<=(real, double precision),
	operator 3 pg_catalog.=(real, double precision),
	operator 4 pg_catalog.>=(real, double precision),
	operator 2 pg_catalog.<=(real, real),
	operator 1 pg_catalog.<(real, real),
	operator 5 pg_catalog.>(real, double precision),
	operator 1 pg_catalog.<(double precision, real),
	operator 2 pg_catalog.<=(double precision, real),
	operator 3 pg_catalog.=(double precision, real),
	operator 4 pg_catalog.>=(double precision, real),
	operator 5 pg_catalog.>(double precision, real),
	operator 1 pg_catalog.<(double precision, double precision),
	operator 2 pg_catalog.<=(double precision, double precision),
	operator 3 pg_catalog.=(double precision, double precision),
	operator 4 pg_catalog.>=(double precision, double precision);

alter operator class pg_catalog.float8_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr_minmax_multi_ops using brin;

alter operator family pg_catalog.macaddr_minmax_multi_ops using brin add
    function 2(macaddr, macaddr) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(macaddr, macaddr) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 5(macaddr, macaddr) pg_catalog.brin_minmax_multi_options(internal),
    function 4(macaddr, macaddr) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 11(macaddr, macaddr) pg_catalog.brin_minmax_multi_distance_macaddr(internal, internal),
    function 1(macaddr, macaddr) pg_catalog.brin_minmax_multi_opcinfo(internal);

alter operator family pg_catalog.macaddr_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr_minmax_multi_ops for type macaddr using brin as storage macaddr operator 3 pg_catalog.=(macaddr, macaddr),
	operator 2 pg_catalog.<=(macaddr, macaddr),
	operator 5 pg_catalog.>(macaddr, macaddr),
	operator 4 pg_catalog.>=(macaddr, macaddr),
	operator 1 pg_catalog.<(macaddr, macaddr);

alter operator class pg_catalog.macaddr_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.macaddr8_minmax_multi_ops using brin;

alter operator family pg_catalog.macaddr8_minmax_multi_ops using brin add
    function 2(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 5(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_options(internal),
    function 11(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_distance_macaddr8(internal, internal),
    function 3(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(macaddr8, macaddr8) pg_catalog.brin_minmax_multi_union(internal, internal, internal);

alter operator family pg_catalog.macaddr8_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.macaddr8_minmax_multi_ops for type macaddr8 using brin as storage macaddr8 operator 2 pg_catalog.<=(macaddr8, macaddr8),
	operator 1 pg_catalog.<(macaddr8, macaddr8),
	operator 5 pg_catalog.>(macaddr8, macaddr8),
	operator 4 pg_catalog.>=(macaddr8, macaddr8),
	operator 3 pg_catalog.=(macaddr8, macaddr8);

alter operator class pg_catalog.macaddr8_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.network_minmax_multi_ops using brin;

alter operator family pg_catalog.network_minmax_multi_ops using brin add
    function 3(inet, inet) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(inet, inet) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(inet, inet) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(inet, inet) pg_catalog.brin_minmax_multi_distance_inet(internal, internal),
    function 5(inet, inet) pg_catalog.brin_minmax_multi_options(internal),
    function 4(inet, inet) pg_catalog.brin_minmax_multi_union(internal, internal, internal);

alter operator family pg_catalog.network_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.inet_minmax_multi_ops for type inet using brin family pg_catalog.network_minmax_multi_ops as storage inet operator 2 pg_catalog.<=(inet, inet),
	operator 3 pg_catalog.=(inet, inet),
	operator 1 pg_catalog.<(inet, inet),
	operator 5 pg_catalog.>(inet, inet),
	operator 4 pg_catalog.>=(inet, inet);

alter operator class pg_catalog.inet_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.time_minmax_multi_ops using brin;

alter operator family pg_catalog.time_minmax_multi_ops using brin add
    function 4(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 3(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 11(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_distance_time(internal, internal),
    function 5(time without time zone, time without time zone) pg_catalog.brin_minmax_multi_options(internal);

alter operator family pg_catalog.time_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.time_minmax_multi_ops for type time without time zone using brin as storage time without time zone operator 5 pg_catalog.>(time, time),
	operator 3 pg_catalog.=(time, time),
	operator 2 pg_catalog.<=(time, time),
	operator 1 pg_catalog.<(time, time),
	operator 4 pg_catalog.>=(time, time);

alter operator class pg_catalog.time_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.interval_minmax_multi_ops using brin;

alter operator family pg_catalog.interval_minmax_multi_ops using brin add
    function 3(interval, interval) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 2(interval, interval) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 1(interval, interval) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 4(interval, interval) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 11(interval, interval) pg_catalog.brin_minmax_multi_distance_interval(internal, internal),
    function 5(interval, interval) pg_catalog.brin_minmax_multi_options(internal);

alter operator family pg_catalog.interval_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.interval_minmax_multi_ops for type interval using brin as storage interval operator 2 pg_catalog.<=(interval, interval),
	operator 3 pg_catalog.=(interval, interval),
	operator 4 pg_catalog.>=(interval, interval),
	operator 5 pg_catalog.>(interval, interval),
	operator 1 pg_catalog.<(interval, interval);

alter operator class pg_catalog.interval_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.uuid_minmax_multi_ops using brin;

alter operator family pg_catalog.uuid_minmax_multi_ops using brin add
    function 1(uuid, uuid) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(uuid, uuid) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(uuid, uuid) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(uuid, uuid) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 5(uuid, uuid) pg_catalog.brin_minmax_multi_options(internal),
    function 11(uuid, uuid) pg_catalog.brin_minmax_multi_distance_uuid(internal, internal);

alter operator family pg_catalog.uuid_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.uuid_minmax_multi_ops for type uuid using brin as storage uuid operator 4 pg_catalog.>=(uuid, uuid),
	operator 5 pg_catalog.>(uuid, uuid),
	operator 1 pg_catalog.<(uuid, uuid),
	operator 3 pg_catalog.=(uuid, uuid),
	operator 2 pg_catalog.<=(uuid, uuid);

alter operator class pg_catalog.uuid_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.pg_lsn_minmax_multi_ops using brin;

alter operator family pg_catalog.pg_lsn_minmax_multi_ops using brin add
    function 1(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_opcinfo(internal),
    function 2(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_add_value(internal, internal, internal, internal),
    function 3(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_consistent(internal, internal, internal, integer),
    function 4(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_union(internal, internal, internal),
    function 5(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_options(internal),
    function 11(pg_lsn, pg_lsn) pg_catalog.brin_minmax_multi_distance_pg_lsn(internal, internal);

alter operator family pg_catalog.pg_lsn_minmax_multi_ops using brin owner to "kim-uijin";

create operator class pg_catalog.pg_lsn_minmax_multi_ops for type pg_lsn using brin as storage pg_lsn operator 5 pg_catalog.>(pg_lsn, pg_lsn),
	operator 4 pg_catalog.>=(pg_lsn, pg_lsn),
	operator 3 pg_catalog.=(pg_lsn, pg_lsn),
	operator 2 pg_catalog.<=(pg_lsn, pg_lsn),
	operator 1 pg_catalog.<(pg_lsn, pg_lsn);

alter operator class pg_catalog.pg_lsn_minmax_multi_ops using brin owner to "kim-uijin";

create operator family pg_catalog.box_ops using spgist;

alter operator family pg_catalog.box_ops using spgist add
    function 5(box, box) pg_catalog.spg_box_quad_leaf_consistent(internal, internal),
    function 4(box, box) pg_catalog.spg_box_quad_inner_consistent(internal, internal),
    function 3(box, box) pg_catalog.spg_box_quad_picksplit(internal, internal),
    function 2(box, box) pg_catalog.spg_box_quad_choose(internal, internal),
    function 1(box, box) pg_catalog.spg_box_quad_config(internal, internal);

alter operator family pg_catalog.box_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.box_ops default for type box using spgist as
    operator 15 pg_catalog.<->(box, point) for order by float_ops,
    operator 6 pg_catalog.~=(box, box),
    operator 2 pg_catalog.&<(box, box),
    operator 1 pg_catalog.<<(box, box),
    operator 3 pg_catalog.&&(box, box),
    operator 4 pg_catalog.&>(box, box),
    operator 5 pg_catalog.>>(box, box),
    operator 7 pg_catalog.@>(box, box),
    operator 8 pg_catalog.<@(box, box),
    operator 9 pg_catalog.&<|(box, box),
    operator 10 pg_catalog.<<|(box, box),
    operator 11 pg_catalog.|>>(box, box),
    operator 12 pg_catalog.|&>(box, box);

alter operator class pg_catalog.box_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.poly_ops using spgist;

alter operator family pg_catalog.poly_ops using spgist add
    function 6(polygon, polygon) pg_catalog.spg_poly_quad_compress(polygon),
    function 5(polygon, polygon) pg_catalog.spg_box_quad_leaf_consistent(internal, internal),
    function 4(polygon, polygon) pg_catalog.spg_box_quad_inner_consistent(internal, internal),
    function 3(polygon, polygon) pg_catalog.spg_box_quad_picksplit(internal, internal),
    function 2(polygon, polygon) pg_catalog.spg_box_quad_choose(internal, internal),
    function 1(polygon, polygon) pg_catalog.spg_bbox_quad_config(internal, internal);

alter operator family pg_catalog.poly_ops using spgist owner to "kim-uijin";

create operator class pg_catalog.poly_ops default for type polygon using spgist as storage box operator 1 pg_catalog.<<(polygon, polygon),
	operator 12 pg_catalog.|&>(polygon, polygon),
	operator 15 pg_catalog.<->(polygon, point) for order by float_ops,
	operator 2 pg_catalog.&<(polygon, polygon),
	operator 3 pg_catalog.&&(polygon, polygon),
	operator 4 pg_catalog.&>(polygon, polygon),
	operator 5 pg_catalog.>>(polygon, polygon),
	operator 6 pg_catalog.~=(polygon, polygon),
	operator 7 pg_catalog.@>(polygon, polygon),
	operator 8 pg_catalog.<@(polygon, polygon),
	operator 9 pg_catalog.&<|(polygon, polygon),
	operator 10 pg_catalog.<<|(polygon, polygon),
	operator 11 pg_catalog.|>>(polygon, polygon);

alter operator class pg_catalog.poly_ops using spgist owner to "kim-uijin";

create operator family pg_catalog.xid8_ops using hash;

alter operator family pg_catalog.xid8_ops using hash add
    function 1(xid8, xid8) pg_catalog.hashint8(bigint),
    function 2(xid8, xid8) pg_catalog.hashint8extended(bigint, bigint);

alter operator family pg_catalog.xid8_ops using hash owner to "kim-uijin";

create operator class pg_catalog.xid8_ops default for type xid8 using hash as
    operator 1 pg_catalog.=(xid8, xid8);

alter operator class pg_catalog.xid8_ops using hash owner to "kim-uijin";

create operator family pg_catalog.xid8_ops using btree;

alter operator family pg_catalog.xid8_ops using btree add
    function 1(xid8, xid8) pg_catalog.xid8cmp(xid8, xid8),
    function 4(xid8, xid8) pg_catalog.btequalimage(oid);

alter operator family pg_catalog.xid8_ops using btree owner to "kim-uijin";

create operator class pg_catalog.xid8_ops default for type xid8 using btree as
    operator 1 pg_catalog.<(xid8, xid8),
    operator 2 pg_catalog.<=(xid8, xid8),
    operator 5 pg_catalog.>(xid8, xid8),
    operator 4 pg_catalog.>=(xid8, xid8),
    operator 3 pg_catalog.=(xid8, xid8);

alter operator class pg_catalog.xid8_ops using btree owner to "kim-uijin";

create operator family pg_catalog.multirange_ops using gist;

alter operator family pg_catalog.multirange_ops using gist add
    function 3(anymultirange, anymultirange) pg_catalog.multirange_gist_compress(internal),
    function 2(anymultirange, anymultirange) pg_catalog.range_gist_union(internal, internal),
    function 1(anymultirange, anymultirange) pg_catalog.multirange_gist_consistent(internal, anymultirange, smallint, oid, internal),
    function 6(anymultirange, anymultirange) pg_catalog.range_gist_picksplit(internal, internal),
    function 5(anymultirange, anymultirange) pg_catalog.range_gist_penalty(internal, internal, internal),
    function 7(anymultirange, anymultirange) pg_catalog.range_gist_same(anyrange, anyrange, internal);

alter operator family pg_catalog.multirange_ops using gist owner to "kim-uijin";

create operator class pg_catalog.multirange_ops default for type anymultirange using gist as storage anyrange operator 16 pg_catalog.@>(anymultirange, anyelement),
	operator 18 pg_catalog.=(anymultirange, anymultirange),
	operator 5 pg_catalog.>>(anymultirange, anyrange),
	operator 6 pg_catalog.-|-(anymultirange, anyrange),
	operator 7 pg_catalog.@>(anymultirange, anymultirange),
	operator 7 pg_catalog.@>(anymultirange, anyrange),
	operator 8 pg_catalog.<@(anymultirange, anymultirange),
	operator 8 pg_catalog.<@(anymultirange, anyrange),
	operator 6 pg_catalog.-|-(anymultirange, anymultirange),
	operator 1 pg_catalog.<<(anymultirange, anymultirange),
	operator 1 pg_catalog.<<(anymultirange, anyrange),
	operator 2 pg_catalog.&<(anymultirange, anymultirange),
	operator 2 pg_catalog.&<(anymultirange, anyrange),
	operator 3 pg_catalog.&&(anymultirange, anymultirange),
	operator 3 pg_catalog.&&(anymultirange, anyrange),
	operator 4 pg_catalog.&>(anymultirange, anymultirange),
	operator 4 pg_catalog.&>(anymultirange, anyrange),
	operator 5 pg_catalog.>>(anymultirange, anymultirange);

alter operator class pg_catalog.multirange_ops using gist owner to "kim-uijin";

create operator family pg_catalog.record_ops using hash;

alter operator family pg_catalog.record_ops using hash add
    function 1(record, record) pg_catalog.hash_record(record),
    function 2(record, record) pg_catalog.hash_record_extended(record, bigint);

alter operator family pg_catalog.record_ops using hash owner to "kim-uijin";

create operator class pg_catalog.record_ops default for type record using hash as
    operator 1 pg_catalog.=(record, record);

alter operator class pg_catalog.record_ops using hash owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.bool_and(boolean) (
    sfunc = booland_statefunc,
    stype = boolean,
    combinefunc = booland_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_alltrue,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.bool_and(boolean) is 'boolean-and aggregate';

alter aggregate pg_catalog.bool_and(boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.bool_or(boolean) (
    sfunc = boolor_statefunc,
    stype = boolean,
    combinefunc = boolor_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_anytrue,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.bool_or(boolean) is 'boolean-or aggregate';

alter aggregate pg_catalog.bool_or(boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.every(boolean) (
    sfunc = booland_statefunc,
    stype = boolean,
    combinefunc = booland_statefunc,
    parallel = safe,
    msfunc = bool_accum,
    minvfunc = bool_accum_inv,
    mstype = internal,
    msspace = 16,
    mfinalfunc = bool_alltrue,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.every(boolean) is 'boolean-and aggregate';

alter aggregate pg_catalog.every(boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(anyarray) (
    sfunc = array_larger,
    stype = anyarray,
    combinefunc = array_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(anyarray) is 'maximum value of all anyarray input values';

alter aggregate pg_catalog.max(anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(anyenum) (
    sfunc = enum_larger,
    stype = anyenum,
    combinefunc = enum_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(anyenum) is 'maximum value of all enum input values';

alter aggregate pg_catalog.max(anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(bigint) (
    sfunc = int8larger,
    stype = bigint,
    combinefunc = int8larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(bigint) is 'maximum value of all bigint input values';

alter aggregate pg_catalog.max(bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(char) (
    sfunc = bpchar_larger,
    stype = char,
    combinefunc = bpchar_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(char) is 'maximum value of all bpchar input values';

alter aggregate pg_catalog.max(char) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(date) (
    sfunc = date_larger,
    stype = date,
    combinefunc = date_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(date) is 'maximum value of all date input values';

alter aggregate pg_catalog.max(date) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(double precision) (
    sfunc = float8larger,
    stype = double precision,
    combinefunc = float8larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(double precision) is 'maximum value of all float8 input values';

alter aggregate pg_catalog.max(double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(inet) (
    sfunc = network_larger,
    stype = inet,
    combinefunc = network_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(inet) is 'maximum value of all inet input values';

alter aggregate pg_catalog.max(inet) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(integer) (
    sfunc = int4larger,
    stype = integer,
    combinefunc = int4larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(integer) is 'maximum value of all integer input values';

alter aggregate pg_catalog.max(integer) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(interval) (
    sfunc = interval_larger,
    stype = interval,
    combinefunc = interval_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(interval) is 'maximum value of all interval input values';

alter aggregate pg_catalog.max(interval) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(money) (
    sfunc = cashlarger,
    stype = money,
    combinefunc = cashlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(money) is 'maximum value of all money input values';

alter aggregate pg_catalog.max(money) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(numeric) (
    sfunc = numeric_larger,
    stype = numeric,
    combinefunc = numeric_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(numeric) is 'maximum value of all numeric input values';

alter aggregate pg_catalog.max(numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(oid) (
    sfunc = oidlarger,
    stype = oid,
    combinefunc = oidlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(oid) is 'maximum value of all oid input values';

alter aggregate pg_catalog.max(oid) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(pg_lsn) (
    sfunc = pg_lsn_larger,
    stype = pg_lsn,
    combinefunc = pg_lsn_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(pg_lsn) is 'maximum value of all pg_lsn input values';

alter aggregate pg_catalog.max(pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(real) (
    sfunc = float4larger,
    stype = real,
    combinefunc = float4larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(real) is 'maximum value of all float4 input values';

alter aggregate pg_catalog.max(real) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(smallint) (
    sfunc = int2larger,
    stype = smallint,
    combinefunc = int2larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(smallint) is 'maximum value of all smallint input values';

alter aggregate pg_catalog.max(smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(text) (
    sfunc = text_larger,
    stype = text,
    combinefunc = text_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(text) is 'maximum value of all text input values';

alter aggregate pg_catalog.max(text) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(tid) (
    sfunc = tidlarger,
    stype = tid,
    combinefunc = tidlarger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(tid) is 'maximum value of all tid input values';

alter aggregate pg_catalog.max(tid) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(time with time zone) (
    sfunc = timetz_larger,
    stype = time with time zone,
    combinefunc = timetz_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(time with time zone) is 'maximum value of all time with time zone input values';

alter aggregate pg_catalog.max(time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(time) (
    sfunc = time_larger,
    stype = time,
    combinefunc = time_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(time) is 'maximum value of all time input values';

alter aggregate pg_catalog.max(time) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp with time zone) (
    sfunc = timestamptz_larger,
    stype = timestamp with time zone,
    combinefunc = timestamptz_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(timestamp with time zone) is 'maximum value of all timestamp with time zone input values';

alter aggregate pg_catalog.max(timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.max(timestamp) (
    sfunc = timestamp_larger,
    stype = timestamp,
    combinefunc = timestamp_larger,
    parallel = safe,
    sortop = operator (>)
    );

comment on aggregate pg_catalog.max(timestamp) is 'maximum value of all timestamp input values';

alter aggregate pg_catalog.max(timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(anyarray) (
    sfunc = array_smaller,
    stype = anyarray,
    combinefunc = array_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(anyarray) is 'minimum value of all anyarray input values';

alter aggregate pg_catalog.min(anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(anyenum) (
    sfunc = enum_smaller,
    stype = anyenum,
    combinefunc = enum_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(anyenum) is 'minimum value of all enum input values';

alter aggregate pg_catalog.min(anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(bigint) (
    sfunc = int8smaller,
    stype = bigint,
    combinefunc = int8smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(bigint) is 'minimum value of all bigint input values';

alter aggregate pg_catalog.min(bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(char) (
    sfunc = bpchar_smaller,
    stype = char,
    combinefunc = bpchar_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(char) is 'minimum value of all bpchar input values';

alter aggregate pg_catalog.min(char) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(date) (
    sfunc = date_smaller,
    stype = date,
    combinefunc = date_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(date) is 'minimum value of all date input values';

alter aggregate pg_catalog.min(date) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(double precision) (
    sfunc = float8smaller,
    stype = double precision,
    combinefunc = float8smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(double precision) is 'minimum value of all float8 input values';

alter aggregate pg_catalog.min(double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(inet) (
    sfunc = network_smaller,
    stype = inet,
    combinefunc = network_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(inet) is 'minimum value of all inet input values';

alter aggregate pg_catalog.min(inet) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(integer) (
    sfunc = int4smaller,
    stype = integer,
    combinefunc = int4smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(integer) is 'minimum value of all integer input values';

alter aggregate pg_catalog.min(integer) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(interval) (
    sfunc = interval_smaller,
    stype = interval,
    combinefunc = interval_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(interval) is 'minimum value of all interval input values';

alter aggregate pg_catalog.min(interval) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(money) (
    sfunc = cashsmaller,
    stype = money,
    combinefunc = cashsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(money) is 'minimum value of all money input values';

alter aggregate pg_catalog.min(money) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(numeric) (
    sfunc = numeric_smaller,
    stype = numeric,
    combinefunc = numeric_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(numeric) is 'minimum value of all numeric input values';

alter aggregate pg_catalog.min(numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(oid) (
    sfunc = oidsmaller,
    stype = oid,
    combinefunc = oidsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(oid) is 'minimum value of all oid input values';

alter aggregate pg_catalog.min(oid) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(pg_lsn) (
    sfunc = pg_lsn_smaller,
    stype = pg_lsn,
    combinefunc = pg_lsn_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(pg_lsn) is 'minimum value of all pg_lsn input values';

alter aggregate pg_catalog.min(pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(real) (
    sfunc = float4smaller,
    stype = real,
    combinefunc = float4smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(real) is 'minimum value of all float4 input values';

alter aggregate pg_catalog.min(real) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(smallint) (
    sfunc = int2smaller,
    stype = smallint,
    combinefunc = int2smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(smallint) is 'minimum value of all smallint input values';

alter aggregate pg_catalog.min(smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(text) (
    sfunc = text_smaller,
    stype = text,
    combinefunc = text_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(text) is 'minimum value of all text values';

alter aggregate pg_catalog.min(text) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(tid) (
    sfunc = tidsmaller,
    stype = tid,
    combinefunc = tidsmaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(tid) is 'minimum value of all tid input values';

alter aggregate pg_catalog.min(tid) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(time with time zone) (
    sfunc = timetz_smaller,
    stype = time with time zone,
    combinefunc = timetz_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(time with time zone) is 'minimum value of all time with time zone input values';

alter aggregate pg_catalog.min(time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(time) (
    sfunc = time_smaller,
    stype = time,
    combinefunc = time_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(time) is 'minimum value of all time input values';

alter aggregate pg_catalog.min(time) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp with time zone) (
    sfunc = timestamptz_smaller,
    stype = timestamp with time zone,
    combinefunc = timestamptz_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(timestamp with time zone) is 'minimum value of all timestamp with time zone input values';

alter aggregate pg_catalog.min(timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create aggregate pg_catalog.min(timestamp) (
    sfunc = timestamp_smaller,
    stype = timestamp,
    combinefunc = timestamp_smaller,
    parallel = safe,
    sortop = operator (<)
    );

comment on aggregate pg_catalog.min(timestamp) is 'minimum value of all timestamp input values';

alter aggregate pg_catalog.min(timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.bpcharregexne, leftarg = char, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(char, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(char, text) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.bpcharregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(char, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(char, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.nameregexne, leftarg = name, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(name, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(name, text) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.nameregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(name, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~ (procedure = pg_catalog.textregexne, leftarg = text, rightarg = text, negator = pg_catalog.~, join = pg_catalog.regexnejoinsel, restrict = pg_catalog.regexnesel);

comment on operator pg_catalog.!~(text, text) is 'does not match regular expression, case-sensitive';

alter operator pg_catalog.!~(text, text) owner to "kim-uijin";

create operator pg_catalog.~ (procedure = pg_catalog.textregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~, join = pg_catalog.regexeqjoinsel, restrict = pg_catalog.regexeqsel);

comment on operator pg_catalog.~(text, text) is 'matches regular expression, case-sensitive';

alter operator pg_catalog.~(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.bpcharicregexne, leftarg = char, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(char, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(char, text) owner to "kim-uijin";

create operator pg_catalog.~* (procedure = pg_catalog.bpcharicregexeq, leftarg = char, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(char, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(char, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.nameicregexne, leftarg = name, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(name, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(name, text) owner to "kim-uijin";

create operator pg_catalog.~* (procedure = pg_catalog.nameicregexeq, leftarg = name, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(name, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~* (procedure = pg_catalog.texticregexne, leftarg = text, rightarg = text, negator = pg_catalog.~*, join = pg_catalog.icregexnejoinsel, restrict = pg_catalog.icregexnesel);

comment on operator pg_catalog.!~*(text, text) is 'does not match regular expression, case-insensitive';

alter operator pg_catalog.!~*(text, text) owner to "kim-uijin";

create operator pg_catalog.~* (procedure = pg_catalog.texticregexeq, leftarg = text, rightarg = text, negator = pg_catalog.!~*, join = pg_catalog.icregexeqjoinsel, restrict = pg_catalog.icregexeqsel);

comment on operator pg_catalog.~*(text, text) is 'matches regular expression, case-insensitive';

alter operator pg_catalog.~*(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.byteanlike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(bytea, bytea) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(bytea, bytea) owner to "kim-uijin";

create operator pg_catalog.~~ (procedure = pg_catalog.bytealike, leftarg = bytea, rightarg = bytea, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(bytea, bytea) is 'matches LIKE expression';

alter operator pg_catalog.~~(bytea, bytea) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.bpcharnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(char, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(char, text) owner to "kim-uijin";

create operator pg_catalog.~~ (procedure = pg_catalog.bpcharlike, leftarg = char, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(char, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(char, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.namenlike, leftarg = name, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(name, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(name, text) owner to "kim-uijin";

create operator pg_catalog.~~ (procedure = pg_catalog.namelike, leftarg = name, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(name, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~ (procedure = pg_catalog.textnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~, join = pg_catalog.nlikejoinsel, restrict = pg_catalog.nlikesel);

comment on operator pg_catalog.!~~(text, text) is 'does not match LIKE expression';

alter operator pg_catalog.!~~(text, text) owner to "kim-uijin";

create operator pg_catalog.~~ (procedure = pg_catalog.textlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~, join = pg_catalog.likejoinsel, restrict = pg_catalog.likesel);

comment on operator pg_catalog.~~(text, text) is 'matches LIKE expression';

alter operator pg_catalog.~~(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.bpcharicnlike, leftarg = char, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(char, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(char, text) owner to "kim-uijin";

create operator pg_catalog.~~* (procedure = pg_catalog.bpchariclike, leftarg = char, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(char, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(char, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.nameicnlike, leftarg = name, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(name, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(name, text) owner to "kim-uijin";

create operator pg_catalog.~~* (procedure = pg_catalog.nameiclike, leftarg = name, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(name, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.!~~* (procedure = pg_catalog.texticnlike, leftarg = text, rightarg = text, negator = pg_catalog.~~*, join = pg_catalog.icnlikejoinsel, restrict = pg_catalog.icnlikesel);

comment on operator pg_catalog.!~~*(text, text) is 'does not match LIKE expression, case-insensitive';

alter operator pg_catalog.!~~*(text, text) owner to "kim-uijin";

create operator pg_catalog.~~* (procedure = pg_catalog.texticlike, leftarg = text, rightarg = text, negator = pg_catalog.!~~*, join = pg_catalog.iclikejoinsel, restrict = pg_catalog.iclikesel);

comment on operator pg_catalog.~~*(text, text) is 'matches LIKE expression, case-insensitive';

alter operator pg_catalog.~~*(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.&& (procedure = pg_catalog.multirange_overlaps_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&&(anymultirange, anyrange) is 'overlaps';

alter operator pg_catalog.&&(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.&& (procedure = pg_catalog.range_overlaps_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.&&, join = pg_catalog.areajoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.&&(anyrange, anymultirange) is 'overlaps';

alter operator pg_catalog.&&(anyrange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int84mul, leftarg = bigint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, integer) is 'multiply';

alter operator pg_catalog.*(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int48mul, leftarg = integer, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, bigint) is 'multiply';

alter operator pg_catalog.*(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int8_mul_cash, leftarg = bigint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, money) is 'multiply';

alter operator pg_catalog.*(bigint, money) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int8, leftarg = money, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, bigint) is 'multiply';

alter operator pg_catalog.*(money, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int82mul, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(bigint, smallint) is 'multiply';

alter operator pg_catalog.*(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int28mul, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, bigint) is 'multiply';

alter operator pg_catalog.*(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.mul_d_interval, leftarg = double precision, rightarg = interval, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, interval) is 'multiply';

alter operator pg_catalog.*(double precision, interval) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.interval_mul, leftarg = interval, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(interval, double precision) is 'multiply';

alter operator pg_catalog.*(interval, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.flt8_mul_cash, leftarg = double precision, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, money) is 'multiply';

alter operator pg_catalog.*(double precision, money) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt8, leftarg = money, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, double precision) is 'multiply';

alter operator pg_catalog.*(money, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.float84mul, leftarg = double precision, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(double precision, real) is 'multiply';

alter operator pg_catalog.*(double precision, real) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.float48mul, leftarg = real, rightarg = double precision, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, double precision) is 'multiply';

alter operator pg_catalog.*(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int4_mul_cash, leftarg = integer, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, money) is 'multiply';

alter operator pg_catalog.*(integer, money) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int4, leftarg = money, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, integer) is 'multiply';

alter operator pg_catalog.*(money, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.int42mul, leftarg = integer, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(integer, smallint) is 'multiply';

alter operator pg_catalog.*(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int24mul, leftarg = smallint, rightarg = integer, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, integer) is 'multiply';

alter operator pg_catalog.*(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_flt4, leftarg = money, rightarg = real, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, real) is 'multiply';

alter operator pg_catalog.*(money, real) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.flt4_mul_cash, leftarg = real, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(real, money) is 'multiply';

alter operator pg_catalog.*(real, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.* (procedure = pg_catalog.cash_mul_int2, leftarg = money, rightarg = smallint, commutator = pg_catalog.*);

comment on operator pg_catalog.*(money, smallint) is 'multiply';

alter operator pg_catalog.*(money, smallint) owner to "kim-uijin";

create operator pg_catalog.* (procedure = pg_catalog.int2_mul_cash, leftarg = smallint, rightarg = money, commutator = pg_catalog.*);

comment on operator pg_catalog.*(smallint, money) is 'multiply';

alter operator pg_catalog.*(smallint, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.*<> (procedure = pg_catalog.record_image_ne, leftarg = record, rightarg = record, commutator = pg_catalog.*<>, negator = pg_catalog.*=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.*<>(record, record) is 'not identical';

alter operator pg_catalog.*<>(record, record) owner to "kim-uijin";

create operator pg_catalog.*= (procedure = pg_catalog.record_image_eq, leftarg = record, rightarg = record, commutator = pg_catalog.*=, negator = pg_catalog.*<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.*=(record, record) is 'identical';

alter operator pg_catalog.*=(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int8pl_inet, leftarg = bigint, rightarg = inet, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, inet) is 'add';

alter operator pg_catalog.+(bigint, inet) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.inetpl, leftarg = inet, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(inet, bigint) is 'add';

alter operator pg_catalog.+(inet, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int84pl, leftarg = bigint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, integer) is 'add';

alter operator pg_catalog.+(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int48pl, leftarg = integer, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, bigint) is 'add';

alter operator pg_catalog.+(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int82pl, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(bigint, smallint) is 'add';

alter operator pg_catalog.+(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int28pl, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, bigint) is 'add';

alter operator pg_catalog.+(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.date_pli, leftarg = date, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, integer) is 'add';

alter operator pg_catalog.+(date, integer) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.integer_pl_date, leftarg = integer, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, date) is 'add';

alter operator pg_catalog.+(integer, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.date_pl_interval, leftarg = date, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, interval) is 'add';

alter operator pg_catalog.+(date, interval) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_date, leftarg = interval, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, date) is 'add';

alter operator pg_catalog.+(interval, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.datetimetz_pl, leftarg = date, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time with time zone) is 'convert date and time with time zone to timestamp with time zone';

alter operator pg_catalog.+(date, time with time zone) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.timetzdate_pl, leftarg = time with time zone, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, date) is 'convert time with time zone and date to timestamp with time zone';

alter operator pg_catalog.+(time with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.datetime_pl, leftarg = date, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(date, time) is 'convert date and time to timestamp';

alter operator pg_catalog.+(date, time) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.timedate_pl, leftarg = time, rightarg = date, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, date) is 'convert time and date to timestamp';

alter operator pg_catalog.+(time, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.float84pl, leftarg = double precision, rightarg = real, commutator = pg_catalog.+);

comment on operator pg_catalog.+(double precision, real) is 'add';

alter operator pg_catalog.+(double precision, real) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.float48pl, leftarg = real, rightarg = double precision, commutator = pg_catalog.+);

comment on operator pg_catalog.+(real, double precision) is 'add';

alter operator pg_catalog.+(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.int42pl, leftarg = integer, rightarg = smallint, commutator = pg_catalog.+);

comment on operator pg_catalog.+(integer, smallint) is 'add';

alter operator pg_catalog.+(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.int24pl, leftarg = smallint, rightarg = integer, commutator = pg_catalog.+);

comment on operator pg_catalog.+(smallint, integer) is 'add';

alter operator pg_catalog.+(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timetz, leftarg = interval, rightarg = time with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time with time zone) is 'add';

alter operator pg_catalog.+(interval, time with time zone) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.timetz_pl_interval, leftarg = time with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time with time zone, interval) is 'add';

alter operator pg_catalog.+(time with time zone, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_time, leftarg = interval, rightarg = time, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, time) is 'add';

alter operator pg_catalog.+(interval, time) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.time_pl_interval, leftarg = time, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(time, interval) is 'add';

alter operator pg_catalog.+(time, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamptz, leftarg = interval, rightarg = timestamp with time zone, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp with time zone) is 'add';

alter operator pg_catalog.+(interval, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.timestamptz_pl_interval, leftarg = timestamp with time zone, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp with time zone, interval) is 'add';

alter operator pg_catalog.+(timestamp with time zone, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.interval_pl_timestamp, leftarg = interval, rightarg = timestamp, commutator = pg_catalog.+);

comment on operator pg_catalog.+(interval, timestamp) is 'add';

alter operator pg_catalog.+(interval, timestamp) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.timestamp_pl_interval, leftarg = timestamp, rightarg = interval, commutator = pg_catalog.+);

comment on operator pg_catalog.+(timestamp, interval) is 'add';

alter operator pg_catalog.+(timestamp, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.+ (procedure = pg_catalog.numeric_pl_pg_lsn, leftarg = numeric, rightarg = pg_lsn, commutator = pg_catalog.+);

comment on operator pg_catalog.+(numeric, pg_lsn) is 'add';

alter operator pg_catalog.+(numeric, pg_lsn) owner to "kim-uijin";

create operator pg_catalog.+ (procedure = pg_catalog.pg_lsn_pli, leftarg = pg_lsn, rightarg = numeric, commutator = pg_catalog.+);

comment on operator pg_catalog.+(pg_lsn, numeric) is 'add';

alter operator pg_catalog.+(pg_lsn, numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.-|- (procedure = pg_catalog.multirange_adjacent_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.-|-, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.-|-(anymultirange, anyrange) is 'is adjacent to';

alter operator pg_catalog.-|-(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.-|- (procedure = pg_catalog.range_adjacent_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.-|-, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.-|-(anyrange, anymultirange) is 'is adjacent to';

alter operator pg_catalog.-|-(anyrange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.path_n_lt, leftarg = path, rightarg = path, commutator = pg_catalog.>);

comment on operator pg_catalog.<(path, path) is 'less than';

alter operator pg_catalog.<(path, path) owner to "kim-uijin";

create operator pg_catalog.> (procedure = pg_catalog.path_n_gt, leftarg = path, rightarg = path, commutator = pg_catalog.<);

comment on operator pg_catalog.>(path, path) is 'greater than';

alter operator pg_catalog.>(path, path) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bl, leftarg = box, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, line) is 'distance between';

alter operator pg_catalog.<->(box, line) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_lb, leftarg = line, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, box) is 'distance between';

alter operator pg_catalog.<->(line, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bs, leftarg = box, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, lseg) is 'distance between';

alter operator pg_catalog.<->(box, lseg) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sb, leftarg = lseg, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, box) is 'distance between';

alter operator pg_catalog.<->(lseg, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_bp, leftarg = box, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(box, point) is 'distance between';

alter operator pg_catalog.<->(box, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pb, leftarg = point, rightarg = box, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, box) is 'distance between';

alter operator pg_catalog.<->(point, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoint, leftarg = circle, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, point) is 'distance between';

alter operator pg_catalog.<->(circle, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pc, leftarg = point, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, circle) is 'distance between';

alter operator pg_catalog.<->(point, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_cpoly, leftarg = circle, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(circle, polygon) is 'distance between';

alter operator pg_catalog.<->(circle, polygon) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_polyc, leftarg = polygon, rightarg = circle, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, circle) is 'distance between';

alter operator pg_catalog.<->(polygon, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ls, leftarg = line, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, lseg) is 'distance between';

alter operator pg_catalog.<->(line, lseg) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sl, leftarg = lseg, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, line) is 'distance between';

alter operator pg_catalog.<->(lseg, line) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_lp, leftarg = line, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(line, point) is 'distance between';

alter operator pg_catalog.<->(line, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pl, leftarg = point, rightarg = line, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, line) is 'distance between';

alter operator pg_catalog.<->(point, line) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_sp, leftarg = lseg, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(lseg, point) is 'distance between';

alter operator pg_catalog.<->(lseg, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ps, leftarg = point, rightarg = lseg, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, lseg) is 'distance between';

alter operator pg_catalog.<->(point, lseg) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_pathp, leftarg = path, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(path, point) is 'distance between';

alter operator pg_catalog.<->(path, point) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, path) is 'distance between';

alter operator pg_catalog.<->(point, path) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<-> (procedure = pg_catalog.dist_ppoly, leftarg = point, rightarg = polygon, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(point, polygon) is 'distance between';

alter operator pg_catalog.<->(point, polygon) owner to "kim-uijin";

create operator pg_catalog.<-> (procedure = pg_catalog.dist_polyp, leftarg = polygon, rightarg = point, commutator = pg_catalog.<->);

comment on operator pg_catalog.<->(polygon, point) is 'distance between';

alter operator pg_catalog.<->(polygon, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.multirange_before_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<<(anymultirange, anymultirange) is 'is left of';

alter operator pg_catalog.<<(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.multirange_after_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.>>(anymultirange, anymultirange) is 'is right of';

alter operator pg_catalog.>>(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.multirange_before_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<<(anymultirange, anyrange) is 'is left of';

alter operator pg_catalog.<<(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.range_after_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.>>(anyrange, anymultirange) is 'is right of';

alter operator pg_catalog.>>(anyrange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.range_before_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<<(anyrange, anymultirange) is 'is left of';

alter operator pg_catalog.<<(anyrange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.multirange_after_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.>>(anymultirange, anyrange) is 'is right of';

alter operator pg_catalog.>>(anymultirange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.range_before, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>>, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<<(anyrange, anyrange) is 'is left of';

alter operator pg_catalog.<<(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.range_after, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<<, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>>(anyrange, anyrange) is 'is right of';

alter operator pg_catalog.>>(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<< (procedure = pg_catalog.network_sub, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<(inet, inet) is 'is subnet';

alter operator pg_catalog.<<(inet, inet) owner to "kim-uijin";

create operator pg_catalog.>> (procedure = pg_catalog.network_sup, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>(inet, inet) is 'is supernet';

alter operator pg_catalog.>>(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<<= (procedure = pg_catalog.network_subeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.>>=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.<<=(inet, inet) is 'is subnet or equal';

alter operator pg_catalog.<<=(inet, inet) owner to "kim-uijin";

create operator pg_catalog.>>= (procedure = pg_catalog.network_supeq, leftarg = inet, rightarg = inet, commutator = pg_catalog.<<=, join = pg_catalog.networkjoinsel, restrict = pg_catalog.networksel);

comment on operator pg_catalog.>>=(inet, inet) is 'is supernet or equal';

alter operator pg_catalog.>>=(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.path_n_le, leftarg = path, rightarg = path, commutator = pg_catalog.>=);

comment on operator pg_catalog.<=(path, path) is 'less than or equal';

alter operator pg_catalog.<=(path, path) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.path_n_ge, leftarg = path, rightarg = path, commutator = pg_catalog.<=);

comment on operator pg_catalog.>=(path, path) is 'greater than or equal';

alter operator pg_catalog.>=(path, path) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.charne, leftarg = "char", rightarg = "char", commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>("char", "char") is 'not equal';

alter operator pg_catalog.<>("char", "char") owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.chareq, leftarg = "char", rightarg = "char", commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=("char", "char") is 'equal';

alter operator pg_catalog.=("char", "char") owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.array_ne, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyarray, anyarray) is 'not equal';

alter operator pg_catalog.<>(anyarray, anyarray) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.array_eq, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyarray, anyarray) is 'equal';

alter operator pg_catalog.=(anyarray, anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.enum_ne, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyenum, anyenum) is 'not equal';

alter operator pg_catalog.<>(anyenum, anyenum) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.enum_eq, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyenum, anyenum) is 'equal';

alter operator pg_catalog.=(anyenum, anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.multirange_ne, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anymultirange, anymultirange) is 'not equal';

alter operator pg_catalog.<>(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.multirange_eq, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anymultirange, anymultirange) is 'equal';

alter operator pg_catalog.=(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.range_ne, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(anyrange, anyrange) is 'not equal';

alter operator pg_catalog.<>(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.range_eq, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(anyrange, anyrange) is 'equal';

alter operator pg_catalog.=(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int8ne, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, bigint) is 'not equal';

alter operator pg_catalog.<>(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int8eq, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, bigint) is 'equal';

alter operator pg_catalog.=(bigint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.varbitne, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit varying, bit varying) is 'not equal';

alter operator pg_catalog.<>(bit varying, bit varying) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.varbiteq, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit varying, bit varying) is 'equal';

alter operator pg_catalog.=(bit varying, bit varying) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.bitne, leftarg = bit, rightarg = bit, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bit, bit) is 'not equal';

alter operator pg_catalog.<>(bit, bit) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.biteq, leftarg = bit, rightarg = bit, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(bit, bit) is 'equal';

alter operator pg_catalog.=(bit, bit) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.boolne, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(boolean, boolean) is 'not equal';

alter operator pg_catalog.<>(boolean, boolean) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.booleq, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(boolean, boolean) is 'equal';

alter operator pg_catalog.=(boolean, boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.byteane, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bytea, bytea) is 'not equal';

alter operator pg_catalog.<>(bytea, bytea) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.byteaeq, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bytea, bytea) is 'equal';

alter operator pg_catalog.=(bytea, bytea) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.bpcharne, leftarg = char, rightarg = char, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(char, char) is 'not equal';

alter operator pg_catalog.<>(char, char) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.bpchareq, leftarg = char, rightarg = char, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(char, char) is 'equal';

alter operator pg_catalog.=(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.circle_ne, leftarg = circle, rightarg = circle, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(circle, circle) is 'not equal by area';

alter operator pg_catalog.<>(circle, circle) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.circle_eq, leftarg = circle, rightarg = circle, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(circle, circle) is 'equal by area';

alter operator pg_catalog.=(circle, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne, leftarg = date, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, date) is 'not equal';

alter operator pg_catalog.<>(date, date) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.date_eq, leftarg = date, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(date, date) is 'equal';

alter operator pg_catalog.=(date, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float8ne, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, double precision) is 'not equal';

alter operator pg_catalog.<>(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.float8eq, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, double precision) is 'equal';

alter operator pg_catalog.=(double precision, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.network_ne, leftarg = inet, rightarg = inet, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(inet, inet) is 'not equal';

alter operator pg_catalog.<>(inet, inet) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.network_eq, leftarg = inet, rightarg = inet, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(inet, inet) is 'equal';

alter operator pg_catalog.=(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int4ne, leftarg = integer, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, integer) is 'not equal';

alter operator pg_catalog.<>(integer, integer) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int4eq, leftarg = integer, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, integer) is 'equal';

alter operator pg_catalog.=(integer, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.interval_ne, leftarg = interval, rightarg = interval, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(interval, interval) is 'not equal';

alter operator pg_catalog.<>(interval, interval) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.interval_eq, leftarg = interval, rightarg = interval, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(interval, interval) is 'equal';

alter operator pg_catalog.=(interval, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.jsonb_ne, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(jsonb, jsonb) is 'not equal';

alter operator pg_catalog.<>(jsonb, jsonb) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.jsonb_eq, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(jsonb, jsonb) is 'equal';

alter operator pg_catalog.=(jsonb, jsonb) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.lseg_ne, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(lseg, lseg) is 'not equal';

alter operator pg_catalog.<>(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.lseg_eq, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(lseg, lseg) is 'equal';

alter operator pg_catalog.=(lseg, lseg) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.macaddr_ne, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr, macaddr) is 'not equal';

alter operator pg_catalog.<>(macaddr, macaddr) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.macaddr_eq, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr, macaddr) is 'equal';

alter operator pg_catalog.=(macaddr, macaddr) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.macaddr8_ne, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(macaddr8, macaddr8) is 'not equal';

alter operator pg_catalog.<>(macaddr8, macaddr8) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.macaddr8_eq, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(macaddr8, macaddr8) is 'equal';

alter operator pg_catalog.=(macaddr8, macaddr8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.cash_ne, leftarg = money, rightarg = money, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(money, money) is 'not equal';

alter operator pg_catalog.<>(money, money) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.cash_eq, leftarg = money, rightarg = money, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(money, money) is 'equal';

alter operator pg_catalog.=(money, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.namene, leftarg = name, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, name) is 'not equal';

alter operator pg_catalog.<>(name, name) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.nameeq, leftarg = name, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, name) is 'equal';

alter operator pg_catalog.=(name, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.numeric_ne, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(numeric, numeric) is 'not equal';

alter operator pg_catalog.<>(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.numeric_eq, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(numeric, numeric) is 'equal';

alter operator pg_catalog.=(numeric, numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.oidne, leftarg = oid, rightarg = oid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oid, oid) is 'not equal';

alter operator pg_catalog.<>(oid, oid) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.oideq, leftarg = oid, rightarg = oid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oid, oid) is 'equal';

alter operator pg_catalog.=(oid, oid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.oidvectorne, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(oidvector, oidvector) is 'not equal';

alter operator pg_catalog.<>(oidvector, oidvector) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.oidvectoreq, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(oidvector, oidvector) is 'equal';

alter operator pg_catalog.=(oidvector, oidvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.pg_lsn_ne, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(pg_lsn, pg_lsn) is 'not equal';

alter operator pg_catalog.<>(pg_lsn, pg_lsn) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.pg_lsn_eq, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(pg_lsn, pg_lsn) is 'equal';

alter operator pg_catalog.=(pg_lsn, pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.point_ne, leftarg = point, rightarg = point, commutator = pg_catalog.<>, negator = pg_catalog.~=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(point, point) is 'not equal';

alter operator pg_catalog.<>(point, point) owner to "kim-uijin";

create operator pg_catalog.~= (procedure = pg_catalog.point_eq, leftarg = point, rightarg = point, commutator = pg_catalog.~=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.~=(point, point) is 'same as';

alter operator pg_catalog.~=(point, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float4ne, leftarg = real, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, real) is 'not equal';

alter operator pg_catalog.<>(real, real) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.float4eq, leftarg = real, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, real) is 'equal';

alter operator pg_catalog.=(real, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.record_ne, leftarg = record, rightarg = record, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(record, record) is 'not equal';

alter operator pg_catalog.<>(record, record) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.record_eq, leftarg = record, rightarg = record, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(record, record) is 'equal';

alter operator pg_catalog.=(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int2ne, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, smallint) is 'not equal';

alter operator pg_catalog.<>(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int2eq, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, smallint) is 'equal';

alter operator pg_catalog.=(smallint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.textne, leftarg = text, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, text) is 'not equal';

alter operator pg_catalog.<>(text, text) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.texteq, leftarg = text, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, text) is 'equal';

alter operator pg_catalog.=(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tidne, leftarg = tid, rightarg = tid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tid, tid) is 'not equal';

alter operator pg_catalog.<>(tid, tid) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.tideq, leftarg = tid, rightarg = tid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(tid, tid) is 'equal';

alter operator pg_catalog.=(tid, tid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timetz_ne, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time with time zone, time with time zone) is 'not equal';

alter operator pg_catalog.<>(time with time zone, time with time zone) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timetz_eq, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time with time zone, time with time zone) is 'equal';

alter operator pg_catalog.=(time with time zone, time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.time_ne, leftarg = time, rightarg = time, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(time, time) is 'not equal';

alter operator pg_catalog.<>(time, time) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.time_eq, leftarg = time, rightarg = time, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(time, time) is 'equal';

alter operator pg_catalog.=(time, time) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(timestamp, timestamp) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tsquery_ne, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsquery, tsquery) is 'not equal';

alter operator pg_catalog.<>(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.tsquery_eq, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsquery, tsquery) is 'equal';

alter operator pg_catalog.=(tsquery, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.tsvector_ne, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(tsvector, tsvector) is 'not equal';

alter operator pg_catalog.<>(tsvector, tsvector) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.tsvector_eq, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(tsvector, tsvector) is 'equal';

alter operator pg_catalog.=(tsvector, tsvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.uuid_ne, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(uuid, uuid) is 'not equal';

alter operator pg_catalog.<>(uuid, uuid) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.uuid_eq, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(uuid, uuid) is 'equal';

alter operator pg_catalog.=(uuid, uuid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.xidneqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, integer) is 'not equal';

alter operator pg_catalog.<>(xid, integer) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.xideqint4, leftarg = xid, rightarg = integer, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel);

comment on operator pg_catalog.=(xid, integer) is 'equal';

alter operator pg_catalog.=(xid, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.xidneq, leftarg = xid, rightarg = xid, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid, xid) is 'not equal';

alter operator pg_catalog.<>(xid, xid) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.xideq, leftarg = xid, rightarg = xid, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes);

comment on operator pg_catalog.=(xid, xid) is 'equal';

alter operator pg_catalog.=(xid, xid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.xid8ne, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(xid8, xid8) is 'not equal';

alter operator pg_catalog.<>(xid8, xid8) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.xid8eq, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(xid8, xid8) is 'equal';

alter operator pg_catalog.=(xid8, xid8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.arraycontained, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.@>, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.<@(anyarray, anyarray) is 'is contained by';

alter operator pg_catalog.<@(anyarray, anyarray) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.arraycontains, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<@, join = pg_catalog.arraycontjoinsel, restrict = pg_catalog.arraycontsel);

comment on operator pg_catalog.@>(anyarray, anyarray) is 'contains';

alter operator pg_catalog.@>(anyarray, anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.elem_contained_by_multirange, leftarg = anyelement, rightarg = anymultirange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<@(anyelement, anymultirange) is 'is contained by';

alter operator pg_catalog.<@(anyelement, anymultirange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.multirange_contains_elem, leftarg = anymultirange, rightarg = anyelement, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.@>(anymultirange, anyelement) is 'contains';

alter operator pg_catalog.@>(anymultirange, anyelement) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.elem_contained_by_range, leftarg = anyelement, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyelement, anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyelement, anyrange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.range_contains_elem, leftarg = anyrange, rightarg = anyelement, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyelement) is 'contains';

alter operator pg_catalog.@>(anyrange, anyelement) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.multirange_contained_by_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<@(anymultirange, anymultirange) is 'is contained by';

alter operator pg_catalog.<@(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.multirange_contains_multirange, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.@>(anymultirange, anymultirange) is 'contains';

alter operator pg_catalog.@>(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.multirange_contained_by_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<@(anymultirange, anyrange) is 'is contained by';

alter operator pg_catalog.<@(anymultirange, anyrange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.range_contains_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.@>(anyrange, anymultirange) is 'contains';

alter operator pg_catalog.@>(anyrange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.range_contained_by_multirange, leftarg = anyrange, rightarg = anymultirange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<@(anyrange, anymultirange) is 'is contained by';

alter operator pg_catalog.<@(anyrange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.multirange_contains_range, leftarg = anymultirange, rightarg = anyrange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.@>(anymultirange, anyrange) is 'contains';

alter operator pg_catalog.@>(anymultirange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.range_contained_by, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<@(anyrange, anyrange) is 'is contained by';

alter operator pg_catalog.<@(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.range_contains, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.@>(anyrange, anyrange) is 'contains';

alter operator pg_catalog.@>(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.box_contained, leftarg = box, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(box, box) is 'is contained by';

alter operator pg_catalog.<@(box, box) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.box_contain, leftarg = box, rightarg = box, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, box) is 'contains';

alter operator pg_catalog.@>(box, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.circle_contained, leftarg = circle, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(circle, circle) is 'is contained by';

alter operator pg_catalog.<@(circle, circle) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain, leftarg = circle, rightarg = circle, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, circle) is 'contains';

alter operator pg_catalog.@>(circle, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.jsonb_contained, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.@>, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.<@(jsonb, jsonb) is 'is contained by';

alter operator pg_catalog.<@(jsonb, jsonb) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.jsonb_contains, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<@, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@>(jsonb, jsonb) is 'contains';

alter operator pg_catalog.@>(jsonb, jsonb) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_pb, leftarg = point, rightarg = box, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, box) is 'point inside box';

alter operator pg_catalog.<@(point, box) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.box_contain_pt, leftarg = box, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(box, point) is 'contains';

alter operator pg_catalog.@>(box, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_circle, leftarg = point, rightarg = circle, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, circle) is 'is contained by';

alter operator pg_catalog.<@(point, circle) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.circle_contain_pt, leftarg = circle, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(circle, point) is 'contains';

alter operator pg_catalog.@>(circle, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.on_ppath, leftarg = point, rightarg = path, commutator = pg_catalog.@>);

comment on operator pg_catalog.<@(point, path) is 'point within closed path, or point on open path';

alter operator pg_catalog.<@(point, path) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.path_contain_pt, leftarg = path, rightarg = point, commutator = pg_catalog.<@);

comment on operator pg_catalog.@>(path, point) is 'contains';

alter operator pg_catalog.@>(path, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.pt_contained_poly, leftarg = point, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(point, polygon) is 'is contained by';

alter operator pg_catalog.<@(point, polygon) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain_pt, leftarg = polygon, rightarg = point, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, point) is 'contains';

alter operator pg_catalog.@>(polygon, point) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.poly_contained, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.@>, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.<@(polygon, polygon) is 'is contained by';

alter operator pg_catalog.<@(polygon, polygon) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.poly_contain, leftarg = polygon, rightarg = polygon, commutator = pg_catalog.<@, join = pg_catalog.contjoinsel, restrict = pg_catalog.contsel);

comment on operator pg_catalog.@>(polygon, polygon) is 'contains';

alter operator pg_catalog.@>(polygon, polygon) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<@ (procedure = pg_catalog.tsq_mcontained, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.@>, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.<@(tsquery, tsquery) is 'is contained by';

alter operator pg_catalog.<@(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.@> (procedure = pg_catalog.tsq_mcontains, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<@, join = pg_catalog.matchingjoinsel, restrict = pg_catalog.matchingsel);

comment on operator pg_catalog.@>(tsquery, tsquery) is 'contains';

alter operator pg_catalog.@>(tsquery, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsquery, tsvector) is 'text search match';

alter operator pg_catalog.@@(tsquery, tsvector) owner to "kim-uijin";

create operator pg_catalog.@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@(tsvector, tsquery) is 'text search match';

alter operator pg_catalog.@@(tsvector, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_qv, leftarg = tsquery, rightarg = tsvector, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsquery, tsvector) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsquery, tsvector) owner to "kim-uijin";

create operator pg_catalog.@@@ (procedure = pg_catalog.ts_match_vq, leftarg = tsvector, rightarg = tsquery, commutator = pg_catalog.@@@, join = pg_catalog.tsmatchjoinsel, restrict = pg_catalog.tsmatchsel);

comment on operator pg_catalog.@@@(tsvector, tsquery) is 'deprecated, use @@ instead';

alter operator pg_catalog.@@@(tsvector, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.*< (procedure = pg_catalog.record_image_lt, leftarg = record, rightarg = record, commutator = pg_catalog.*>, negator = pg_catalog.*>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.*<(record, record) is 'less than';

alter operator pg_catalog.*<(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.*> (procedure = pg_catalog.record_image_gt, leftarg = record, rightarg = record, commutator = pg_catalog.*<, negator = pg_catalog.*<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.*>(record, record) is 'greater than';

alter operator pg_catalog.*>(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.*<= (procedure = pg_catalog.record_image_le, leftarg = record, rightarg = record, commutator = pg_catalog.*>=, negator = pg_catalog.*>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.*<=(record, record) is 'less than or equal';

alter operator pg_catalog.*<=(record, record) owner to "kim-uijin";

create operator pg_catalog.*>= (procedure = pg_catalog.record_image_ge, leftarg = record, rightarg = record, commutator = pg_catalog.*<=, negator = pg_catalog.*<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.*>=(record, record) is 'greater than or equal';

alter operator pg_catalog.*>=(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.charlt, leftarg = "char", rightarg = "char", commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<("char", "char") is 'less than';

alter operator pg_catalog.<("char", "char") owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.chargt, leftarg = "char", rightarg = "char", commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>("char", "char") is 'greater than';

alter operator pg_catalog.>("char", "char") owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.charle, leftarg = "char", rightarg = "char", commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=("char", "char") is 'less than or equal';

alter operator pg_catalog.<=("char", "char") owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.charge, leftarg = "char", rightarg = "char", commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=("char", "char") is 'greater than or equal';

alter operator pg_catalog.>=("char", "char") owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.array_lt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyarray, anyarray) is 'less than';

alter operator pg_catalog.<(anyarray, anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.array_gt, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyarray, anyarray) is 'greater than';

alter operator pg_catalog.>(anyarray, anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.array_le, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyarray, anyarray) is 'less than or equal';

alter operator pg_catalog.<=(anyarray, anyarray) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.array_ge, leftarg = anyarray, rightarg = anyarray, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyarray, anyarray) is 'greater than or equal';

alter operator pg_catalog.>=(anyarray, anyarray) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.enum_lt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(anyenum, anyenum) is 'less than';

alter operator pg_catalog.<(anyenum, anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.enum_gt, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(anyenum, anyenum) is 'greater than';

alter operator pg_catalog.>(anyenum, anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.enum_le, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(anyenum, anyenum) is 'less than or equal';

alter operator pg_catalog.<=(anyenum, anyenum) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.enum_ge, leftarg = anyenum, rightarg = anyenum, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(anyenum, anyenum) is 'greater than or equal';

alter operator pg_catalog.>=(anyenum, anyenum) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.multirange_lt, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<(anymultirange, anymultirange) is 'less than';

alter operator pg_catalog.<(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.multirange_gt, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.>(anymultirange, anymultirange) is 'greater than';

alter operator pg_catalog.>(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.multirange_le, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.<=(anymultirange, anymultirange) is 'less than or equal';

alter operator pg_catalog.<=(anymultirange, anymultirange) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.multirange_ge, leftarg = anymultirange, rightarg = anymultirange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.multirangesel);

comment on operator pg_catalog.>=(anymultirange, anymultirange) is 'greater than or equal';

alter operator pg_catalog.>=(anymultirange, anymultirange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.range_lt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<(anyrange, anyrange) is 'less than';

alter operator pg_catalog.<(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.range_gt, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>(anyrange, anyrange) is 'greater than';

alter operator pg_catalog.>(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.range_le, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.<=(anyrange, anyrange) is 'less than or equal';

alter operator pg_catalog.<=(anyrange, anyrange) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.range_ge, leftarg = anyrange, rightarg = anyrange, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.rangesel);

comment on operator pg_catalog.>=(anyrange, anyrange) is 'greater than or equal';

alter operator pg_catalog.>=(anyrange, anyrange) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int8lt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, bigint) is 'less than';

alter operator pg_catalog.<(bigint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int8gt, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, bigint) is 'greater than';

alter operator pg_catalog.>(bigint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int8le, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, bigint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, bigint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int8ge, leftarg = bigint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int84lt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, integer) is 'less than';

alter operator pg_catalog.<(bigint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int48gt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, bigint) is 'greater than';

alter operator pg_catalog.>(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int48le, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, bigint) is 'less than or equal';

alter operator pg_catalog.<=(integer, bigint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int84ge, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, integer) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int82lt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bigint, smallint) is 'less than';

alter operator pg_catalog.<(bigint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int28gt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, bigint) is 'greater than';

alter operator pg_catalog.>(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int28le, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, bigint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, bigint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int82ge, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bigint, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(bigint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.varbitlt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit varying, bit varying) is 'less than';

alter operator pg_catalog.<(bit varying, bit varying) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.varbitgt, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit varying, bit varying) is 'greater than';

alter operator pg_catalog.>(bit varying, bit varying) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.varbitle, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit varying, bit varying) is 'less than or equal';

alter operator pg_catalog.<=(bit varying, bit varying) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.varbitge, leftarg = bit varying, rightarg = bit varying, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit varying, bit varying) is 'greater than or equal';

alter operator pg_catalog.>=(bit varying, bit varying) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bitlt, leftarg = bit, rightarg = bit, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bit, bit) is 'less than';

alter operator pg_catalog.<(bit, bit) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.bitgt, leftarg = bit, rightarg = bit, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bit, bit) is 'greater than';

alter operator pg_catalog.>(bit, bit) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.bitle, leftarg = bit, rightarg = bit, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bit, bit) is 'less than or equal';

alter operator pg_catalog.<=(bit, bit) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.bitge, leftarg = bit, rightarg = bit, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bit, bit) is 'greater than or equal';

alter operator pg_catalog.>=(bit, bit) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.boollt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(boolean, boolean) is 'less than';

alter operator pg_catalog.<(boolean, boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.boolgt, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(boolean, boolean) is 'greater than';

alter operator pg_catalog.>(boolean, boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.boolle, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(boolean, boolean) is 'less than or equal';

alter operator pg_catalog.<=(boolean, boolean) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.boolge, leftarg = boolean, rightarg = boolean, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(boolean, boolean) is 'greater than or equal';

alter operator pg_catalog.>=(boolean, boolean) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.box_lt, leftarg = box, rightarg = box, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(box, box) is 'less than by area';

alter operator pg_catalog.<(box, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.box_gt, leftarg = box, rightarg = box, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(box, box) is 'greater than by area';

alter operator pg_catalog.>(box, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.box_le, leftarg = box, rightarg = box, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(box, box) is 'less than or equal by area';

alter operator pg_catalog.<=(box, box) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.box_ge, leftarg = box, rightarg = box, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(box, box) is 'greater than or equal by area';

alter operator pg_catalog.>=(box, box) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bytealt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(bytea, bytea) is 'less than';

alter operator pg_catalog.<(bytea, bytea) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.byteagt, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bytea, bytea) is 'greater than';

alter operator pg_catalog.>(bytea, bytea) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.byteale, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bytea, bytea) is 'less than or equal';

alter operator pg_catalog.<=(bytea, bytea) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.byteage, leftarg = bytea, rightarg = bytea, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(bytea, bytea) is 'greater than or equal';

alter operator pg_catalog.>=(bytea, bytea) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.bpcharlt, leftarg = char, rightarg = char, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(char, char) is 'less than';

alter operator pg_catalog.<(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.bpchargt, leftarg = char, rightarg = char, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(char, char) is 'greater than';

alter operator pg_catalog.>(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.bpcharle, leftarg = char, rightarg = char, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(char, char) is 'less than or equal';

alter operator pg_catalog.<=(char, char) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.bpcharge, leftarg = char, rightarg = char, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(char, char) is 'greater than or equal';

alter operator pg_catalog.>=(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.circle_lt, leftarg = circle, rightarg = circle, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<(circle, circle) is 'less than by area';

alter operator pg_catalog.<(circle, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.circle_gt, leftarg = circle, rightarg = circle, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>(circle, circle) is 'greater than by area';

alter operator pg_catalog.>(circle, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.circle_le, leftarg = circle, rightarg = circle, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.<=(circle, circle) is 'less than or equal by area';

alter operator pg_catalog.<=(circle, circle) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.circle_ge, leftarg = circle, rightarg = circle, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.areajoinsel, restrict = pg_catalog.areasel);

comment on operator pg_catalog.>=(circle, circle) is 'greater than or equal by area';

alter operator pg_catalog.>=(circle, circle) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt, leftarg = date, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, date) is 'less than';

alter operator pg_catalog.<(date, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt, leftarg = date, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, date) is 'greater than';

alter operator pg_catalog.>(date, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le, leftarg = date, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, date) is 'less than or equal';

alter operator pg_catalog.<=(date, date) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.date_ge, leftarg = date, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, date) is 'greater than or equal';

alter operator pg_catalog.>=(date, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(date, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, date) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, date) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.date_lt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(date, timestamp) is 'less than';

alter operator pg_catalog.<(date, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, date) is 'greater than';

alter operator pg_catalog.>(timestamp, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, date) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, date) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.date_ge_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(date, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(date, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float8lt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, double precision) is 'less than';

alter operator pg_catalog.<(double precision, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float8gt, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, double precision) is 'greater than';

alter operator pg_catalog.>(double precision, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float8le, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, double precision) is 'less than or equal';

alter operator pg_catalog.<=(double precision, double precision) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.float8ge, leftarg = double precision, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, double precision) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float84lt, leftarg = double precision, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(double precision, real) is 'less than';

alter operator pg_catalog.<(double precision, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float48gt, leftarg = real, rightarg = double precision, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, double precision) is 'greater than';

alter operator pg_catalog.>(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float48le, leftarg = real, rightarg = double precision, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, double precision) is 'less than or equal';

alter operator pg_catalog.<=(real, double precision) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.float84ge, leftarg = double precision, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(double precision, real) is 'greater than or equal';

alter operator pg_catalog.>=(double precision, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.network_lt, leftarg = inet, rightarg = inet, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(inet, inet) is 'less than';

alter operator pg_catalog.<(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.network_gt, leftarg = inet, rightarg = inet, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(inet, inet) is 'greater than';

alter operator pg_catalog.>(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.network_le, leftarg = inet, rightarg = inet, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(inet, inet) is 'less than or equal';

alter operator pg_catalog.<=(inet, inet) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.network_ge, leftarg = inet, rightarg = inet, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(inet, inet) is 'greater than or equal';

alter operator pg_catalog.>=(inet, inet) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int48lt, leftarg = integer, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, bigint) is 'less than';

alter operator pg_catalog.<(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int84gt, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, integer) is 'greater than';

alter operator pg_catalog.>(bigint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int84le, leftarg = bigint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, integer) is 'less than or equal';

alter operator pg_catalog.<=(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int48ge, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int4lt, leftarg = integer, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, integer) is 'less than';

alter operator pg_catalog.<(integer, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int4gt, leftarg = integer, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, integer) is 'greater than';

alter operator pg_catalog.>(integer, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int4le, leftarg = integer, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, integer) is 'less than or equal';

alter operator pg_catalog.<=(integer, integer) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int4ge, leftarg = integer, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, integer) is 'greater than or equal';

alter operator pg_catalog.>=(integer, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int42lt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(integer, smallint) is 'less than';

alter operator pg_catalog.<(integer, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int24gt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, integer) is 'greater than';

alter operator pg_catalog.>(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int24le, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, integer) is 'less than or equal';

alter operator pg_catalog.<=(smallint, integer) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int42ge, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(integer, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(integer, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.interval_lt, leftarg = interval, rightarg = interval, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(interval, interval) is 'less than';

alter operator pg_catalog.<(interval, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.interval_gt, leftarg = interval, rightarg = interval, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(interval, interval) is 'greater than';

alter operator pg_catalog.>(interval, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.interval_le, leftarg = interval, rightarg = interval, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(interval, interval) is 'less than or equal';

alter operator pg_catalog.<=(interval, interval) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.interval_ge, leftarg = interval, rightarg = interval, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(interval, interval) is 'greater than or equal';

alter operator pg_catalog.>=(interval, interval) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.jsonb_lt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(jsonb, jsonb) is 'less than';

alter operator pg_catalog.<(jsonb, jsonb) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.jsonb_gt, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(jsonb, jsonb) is 'greater than';

alter operator pg_catalog.>(jsonb, jsonb) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.jsonb_le, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(jsonb, jsonb) is 'less than or equal';

alter operator pg_catalog.<=(jsonb, jsonb) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.jsonb_ge, leftarg = jsonb, rightarg = jsonb, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(jsonb, jsonb) is 'greater than or equal';

alter operator pg_catalog.>=(jsonb, jsonb) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.lseg_lt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>, negator = pg_catalog.>=);

comment on operator pg_catalog.<(lseg, lseg) is 'less than by length';

alter operator pg_catalog.<(lseg, lseg) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.lseg_gt, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<, negator = pg_catalog.<=);

comment on operator pg_catalog.>(lseg, lseg) is 'greater than by length';

alter operator pg_catalog.>(lseg, lseg) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.lseg_le, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.>=, negator = pg_catalog.>);

comment on operator pg_catalog.<=(lseg, lseg) is 'less than or equal by length';

alter operator pg_catalog.<=(lseg, lseg) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.lseg_ge, leftarg = lseg, rightarg = lseg, commutator = pg_catalog.<=, negator = pg_catalog.<);

comment on operator pg_catalog.>=(lseg, lseg) is 'greater than or equal by length';

alter operator pg_catalog.>=(lseg, lseg) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr_lt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr, macaddr) is 'less than';

alter operator pg_catalog.<(macaddr, macaddr) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.macaddr_gt, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr, macaddr) is 'greater than';

alter operator pg_catalog.>(macaddr, macaddr) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.macaddr_le, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr, macaddr) is 'less than or equal';

alter operator pg_catalog.<=(macaddr, macaddr) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.macaddr_ge, leftarg = macaddr, rightarg = macaddr, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr, macaddr) is 'greater than or equal';

alter operator pg_catalog.>=(macaddr, macaddr) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.macaddr8_lt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(macaddr8, macaddr8) is 'less than';

alter operator pg_catalog.<(macaddr8, macaddr8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.macaddr8_gt, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(macaddr8, macaddr8) is 'greater than';

alter operator pg_catalog.>(macaddr8, macaddr8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.macaddr8_le, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(macaddr8, macaddr8) is 'less than or equal';

alter operator pg_catalog.<=(macaddr8, macaddr8) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.macaddr8_ge, leftarg = macaddr8, rightarg = macaddr8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(macaddr8, macaddr8) is 'greater than or equal';

alter operator pg_catalog.>=(macaddr8, macaddr8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.cash_lt, leftarg = money, rightarg = money, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(money, money) is 'less than';

alter operator pg_catalog.<(money, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.cash_gt, leftarg = money, rightarg = money, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(money, money) is 'greater than';

alter operator pg_catalog.>(money, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.cash_le, leftarg = money, rightarg = money, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(money, money) is 'less than or equal';

alter operator pg_catalog.<=(money, money) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.cash_ge, leftarg = money, rightarg = money, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(money, money) is 'greater than or equal';

alter operator pg_catalog.>=(money, money) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelt, leftarg = name, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, name) is 'less than';

alter operator pg_catalog.<(name, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.namegt, leftarg = name, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, name) is 'greater than';

alter operator pg_catalog.>(name, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.namele, leftarg = name, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, name) is 'less than or equal';

alter operator pg_catalog.<=(name, name) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.namege, leftarg = name, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, name) is 'greater than or equal';

alter operator pg_catalog.>=(name, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.namelttext, leftarg = name, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(name, text) is 'less than';

alter operator pg_catalog.<(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.textgtname, leftarg = text, rightarg = name, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, name) is 'greater than';

alter operator pg_catalog.>(text, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.textlename, leftarg = text, rightarg = name, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, name) is 'less than or equal';

alter operator pg_catalog.<=(text, name) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.namegetext, leftarg = name, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(name, text) is 'greater than or equal';

alter operator pg_catalog.>=(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.numeric_lt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(numeric, numeric) is 'less than';

alter operator pg_catalog.<(numeric, numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.numeric_gt, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(numeric, numeric) is 'greater than';

alter operator pg_catalog.>(numeric, numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.numeric_le, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(numeric, numeric) is 'less than or equal';

alter operator pg_catalog.<=(numeric, numeric) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.numeric_ge, leftarg = numeric, rightarg = numeric, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(numeric, numeric) is 'greater than or equal';

alter operator pg_catalog.>=(numeric, numeric) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidlt, leftarg = oid, rightarg = oid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oid, oid) is 'less than';

alter operator pg_catalog.<(oid, oid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.oidgt, leftarg = oid, rightarg = oid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oid, oid) is 'greater than';

alter operator pg_catalog.>(oid, oid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.oidle, leftarg = oid, rightarg = oid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oid, oid) is 'less than or equal';

alter operator pg_catalog.<=(oid, oid) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.oidge, leftarg = oid, rightarg = oid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oid, oid) is 'greater than or equal';

alter operator pg_catalog.>=(oid, oid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.oidvectorlt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(oidvector, oidvector) is 'less than';

alter operator pg_catalog.<(oidvector, oidvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.oidvectorgt, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(oidvector, oidvector) is 'greater than';

alter operator pg_catalog.>(oidvector, oidvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.oidvectorle, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(oidvector, oidvector) is 'less than or equal';

alter operator pg_catalog.<=(oidvector, oidvector) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.oidvectorge, leftarg = oidvector, rightarg = oidvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(oidvector, oidvector) is 'greater than or equal';

alter operator pg_catalog.>=(oidvector, oidvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.pg_lsn_lt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(pg_lsn, pg_lsn) is 'less than';

alter operator pg_catalog.<(pg_lsn, pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.pg_lsn_gt, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(pg_lsn, pg_lsn) is 'greater than';

alter operator pg_catalog.>(pg_lsn, pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.pg_lsn_le, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(pg_lsn, pg_lsn) is 'less than or equal';

alter operator pg_catalog.<=(pg_lsn, pg_lsn) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.pg_lsn_ge, leftarg = pg_lsn, rightarg = pg_lsn, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(pg_lsn, pg_lsn) is 'greater than or equal';

alter operator pg_catalog.>=(pg_lsn, pg_lsn) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float48lt, leftarg = real, rightarg = double precision, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, double precision) is 'less than';

alter operator pg_catalog.<(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float84gt, leftarg = double precision, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(double precision, real) is 'greater than';

alter operator pg_catalog.>(double precision, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float84le, leftarg = double precision, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(double precision, real) is 'less than or equal';

alter operator pg_catalog.<=(double precision, real) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.float48ge, leftarg = real, rightarg = double precision, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, double precision) is 'greater than or equal';

alter operator pg_catalog.>=(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.float4lt, leftarg = real, rightarg = real, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(real, real) is 'less than';

alter operator pg_catalog.<(real, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.float4gt, leftarg = real, rightarg = real, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(real, real) is 'greater than';

alter operator pg_catalog.>(real, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.float4le, leftarg = real, rightarg = real, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(real, real) is 'less than or equal';

alter operator pg_catalog.<=(real, real) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.float4ge, leftarg = real, rightarg = real, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(real, real) is 'greater than or equal';

alter operator pg_catalog.>=(real, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.record_lt, leftarg = record, rightarg = record, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(record, record) is 'less than';

alter operator pg_catalog.<(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.record_gt, leftarg = record, rightarg = record, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(record, record) is 'greater than';

alter operator pg_catalog.>(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.record_le, leftarg = record, rightarg = record, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(record, record) is 'less than or equal';

alter operator pg_catalog.<=(record, record) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.record_ge, leftarg = record, rightarg = record, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(record, record) is 'greater than or equal';

alter operator pg_catalog.>=(record, record) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int28lt, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, bigint) is 'less than';

alter operator pg_catalog.<(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int82gt, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(bigint, smallint) is 'greater than';

alter operator pg_catalog.>(bigint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int82le, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(bigint, smallint) is 'less than or equal';

alter operator pg_catalog.<=(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int28ge, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, bigint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int24lt, leftarg = smallint, rightarg = integer, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, integer) is 'less than';

alter operator pg_catalog.<(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int42gt, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(integer, smallint) is 'greater than';

alter operator pg_catalog.>(integer, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int42le, leftarg = integer, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(integer, smallint) is 'less than or equal';

alter operator pg_catalog.<=(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int24ge, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, integer) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.int2lt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(smallint, smallint) is 'less than';

alter operator pg_catalog.<(smallint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.int2gt, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(smallint, smallint) is 'greater than';

alter operator pg_catalog.>(smallint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.int2le, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(smallint, smallint) is 'less than or equal';

alter operator pg_catalog.<=(smallint, smallint) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.int2ge, leftarg = smallint, rightarg = smallint, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(smallint, smallint) is 'greater than or equal';

alter operator pg_catalog.>=(smallint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.textltname, leftarg = text, rightarg = name, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, name) is 'less than';

alter operator pg_catalog.<(text, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.namegttext, leftarg = name, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(name, text) is 'greater than';

alter operator pg_catalog.>(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.nameletext, leftarg = name, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(name, text) is 'less than or equal';

alter operator pg_catalog.<=(name, text) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.textgename, leftarg = text, rightarg = name, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, name) is 'greater than or equal';

alter operator pg_catalog.>=(text, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.text_lt, leftarg = text, rightarg = text, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(text, text) is 'less than';

alter operator pg_catalog.<(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.text_gt, leftarg = text, rightarg = text, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(text, text) is 'greater than';

alter operator pg_catalog.>(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.text_le, leftarg = text, rightarg = text, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(text, text) is 'less than or equal';

alter operator pg_catalog.<=(text, text) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.text_ge, leftarg = text, rightarg = text, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(text, text) is 'greater than or equal';

alter operator pg_catalog.>=(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tidlt, leftarg = tid, rightarg = tid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tid, tid) is 'less than';

alter operator pg_catalog.<(tid, tid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tidgt, leftarg = tid, rightarg = tid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tid, tid) is 'greater than';

alter operator pg_catalog.>(tid, tid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tidle, leftarg = tid, rightarg = tid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tid, tid) is 'less than or equal';

alter operator pg_catalog.<=(tid, tid) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.tidge, leftarg = tid, rightarg = tid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tid, tid) is 'greater than or equal';

alter operator pg_catalog.>=(tid, tid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timetz_lt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time with time zone, time with time zone) is 'less than';

alter operator pg_catalog.<(time with time zone, time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timetz_gt, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time with time zone, time with time zone) is 'greater than';

alter operator pg_catalog.>(time with time zone, time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timetz_le, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time with time zone, time with time zone) is 'less than or equal';

alter operator pg_catalog.<=(time with time zone, time with time zone) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timetz_ge, leftarg = time with time zone, rightarg = time with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time with time zone, time with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(time with time zone, time with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.time_lt, leftarg = time, rightarg = time, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(time, time) is 'less than';

alter operator pg_catalog.<(time, time) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.time_gt, leftarg = time, rightarg = time, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(time, time) is 'greater than';

alter operator pg_catalog.>(time, time) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.time_le, leftarg = time, rightarg = time, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(time, time) is 'less than or equal';

alter operator pg_catalog.<=(time, time) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.time_ge, leftarg = time, rightarg = time, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(time, time) is 'greater than or equal';

alter operator pg_catalog.>=(time, time) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, date) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(date, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge, leftarg = timestamp with time zone, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamptz_lt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp with time zone, timestamp) is 'less than';

alter operator pg_catalog.<(timestamp with time zone, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp with time zone) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp with time zone) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamptz_ge_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp with time zone, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp with time zone, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, date) is 'less than';

alter operator pg_catalog.<(timestamp, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.date_gt_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(date, timestamp) is 'greater than';

alter operator pg_catalog.>(date, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.date_le_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(date, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(date, timestamp) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, date) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp with time zone) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamptz_gt_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp with time zone, timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp with time zone, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamptz_le_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp with time zone, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp with time zone, timestamp) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp with time zone) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.timestamp_lt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(timestamp, timestamp) is 'less than';

alter operator pg_catalog.<(timestamp, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.timestamp_gt, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(timestamp, timestamp) is 'greater than';

alter operator pg_catalog.>(timestamp, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.timestamp_le, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(timestamp, timestamp) is 'less than or equal';

alter operator pg_catalog.<=(timestamp, timestamp) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.timestamp_ge, leftarg = timestamp, rightarg = timestamp, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(timestamp, timestamp) is 'greater than or equal';

alter operator pg_catalog.>=(timestamp, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsquery_lt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsquery, tsquery) is 'less than';

alter operator pg_catalog.<(tsquery, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tsquery_gt, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsquery, tsquery) is 'greater than';

alter operator pg_catalog.>(tsquery, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tsquery_le, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsquery, tsquery) is 'less than or equal';

alter operator pg_catalog.<=(tsquery, tsquery) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.tsquery_ge, leftarg = tsquery, rightarg = tsquery, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsquery, tsquery) is 'greater than or equal';

alter operator pg_catalog.>=(tsquery, tsquery) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.tsvector_lt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(tsvector, tsvector) is 'less than';

alter operator pg_catalog.<(tsvector, tsvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.tsvector_gt, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(tsvector, tsvector) is 'greater than';

alter operator pg_catalog.>(tsvector, tsvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.tsvector_le, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(tsvector, tsvector) is 'less than or equal';

alter operator pg_catalog.<=(tsvector, tsvector) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.tsvector_ge, leftarg = tsvector, rightarg = tsvector, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(tsvector, tsvector) is 'greater than or equal';

alter operator pg_catalog.>=(tsvector, tsvector) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.uuid_lt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(uuid, uuid) is 'less than';

alter operator pg_catalog.<(uuid, uuid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.uuid_gt, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(uuid, uuid) is 'greater than';

alter operator pg_catalog.>(uuid, uuid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.uuid_le, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(uuid, uuid) is 'less than or equal';

alter operator pg_catalog.<=(uuid, uuid) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.uuid_ge, leftarg = uuid, rightarg = uuid, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(uuid, uuid) is 'greater than or equal';

alter operator pg_catalog.>=(uuid, uuid) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.< (procedure = pg_catalog.xid8lt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>, negator = pg_catalog.>=, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.<(xid8, xid8) is 'less than';

alter operator pg_catalog.<(xid8, xid8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.> (procedure = pg_catalog.xid8gt, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<, negator = pg_catalog.<=, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.>(xid8, xid8) is 'greater than';

alter operator pg_catalog.>(xid8, xid8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<= (procedure = pg_catalog.xid8le, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.>=, negator = pg_catalog.>, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.<=(xid8, xid8) is 'less than or equal';

alter operator pg_catalog.<=(xid8, xid8) owner to "kim-uijin";

create operator pg_catalog.>= (procedure = pg_catalog.xid8ge, leftarg = xid8, rightarg = xid8, commutator = pg_catalog.<=, negator = pg_catalog.<, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.>=(xid8, xid8) is 'greater than or equal';

alter operator pg_catalog.>=(xid8, xid8) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int84ne, leftarg = bigint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, integer) is 'not equal';

alter operator pg_catalog.<>(bigint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int48ne, leftarg = integer, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, bigint) is 'not equal';

alter operator pg_catalog.<>(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int84eq, leftarg = bigint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, integer) is 'equal';

alter operator pg_catalog.=(bigint, integer) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int48eq, leftarg = integer, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, bigint) is 'equal';

alter operator pg_catalog.=(integer, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int82ne, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(bigint, smallint) is 'not equal';

alter operator pg_catalog.<>(bigint, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int28ne, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, bigint) is 'not equal';

alter operator pg_catalog.<>(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int82eq, leftarg = bigint, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(bigint, smallint) is 'equal';

alter operator pg_catalog.=(bigint, smallint) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int28eq, leftarg = smallint, rightarg = bigint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, bigint) is 'equal';

alter operator pg_catalog.=(smallint, bigint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(date, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, date) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamptz, leftarg = date, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(date, timestamp with time zone) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_date, leftarg = timestamp with time zone, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, date) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.date_ne_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(date, timestamp) is 'not equal';

alter operator pg_catalog.<>(date, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, date) is 'not equal';

alter operator pg_catalog.<>(timestamp, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.date_eq_timestamp, leftarg = date, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(date, timestamp) is 'equal';

alter operator pg_catalog.=(date, timestamp) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_date, leftarg = timestamp, rightarg = date, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, date) is 'equal';

alter operator pg_catalog.=(timestamp, date) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float84ne, leftarg = double precision, rightarg = real, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(double precision, real) is 'not equal';

alter operator pg_catalog.<>(double precision, real) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.float48ne, leftarg = real, rightarg = double precision, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(real, double precision) is 'not equal';

alter operator pg_catalog.<>(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.float84eq, leftarg = double precision, rightarg = real, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(double precision, real) is 'equal';

alter operator pg_catalog.=(double precision, real) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.float48eq, leftarg = real, rightarg = double precision, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(real, double precision) is 'equal';

alter operator pg_catalog.=(real, double precision) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int42ne, leftarg = integer, rightarg = smallint, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(integer, smallint) is 'not equal';

alter operator pg_catalog.<>(integer, smallint) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.int24ne, leftarg = smallint, rightarg = integer, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(smallint, integer) is 'not equal';

alter operator pg_catalog.<>(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.int42eq, leftarg = integer, rightarg = smallint, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(integer, smallint) is 'equal';

alter operator pg_catalog.=(integer, smallint) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.int24eq, leftarg = smallint, rightarg = integer, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(smallint, integer) is 'equal';

alter operator pg_catalog.=(smallint, integer) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.namenetext, leftarg = name, rightarg = text, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(name, text) is 'not equal';

alter operator pg_catalog.<>(name, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.textnename, leftarg = text, rightarg = name, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(text, name) is 'not equal';

alter operator pg_catalog.<>(text, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.nameeqtext, leftarg = name, rightarg = text, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(name, text) is 'equal';

alter operator pg_catalog.=(name, text) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.texteqname, leftarg = text, rightarg = name, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, hashes, merges);

comment on operator pg_catalog.=(text, name) is 'equal';

alter operator pg_catalog.=(text, name) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamptz_ne_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp with time zone, timestamp) is 'not equal';

alter operator pg_catalog.<>(timestamp with time zone, timestamp) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.<> (procedure = pg_catalog.timestamp_ne_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.<>, negator = pg_catalog.=, join = pg_catalog.neqjoinsel, restrict = pg_catalog.neqsel);

comment on operator pg_catalog.<>(timestamp, timestamp with time zone) is 'not equal';

alter operator pg_catalog.<>(timestamp, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.= (procedure = pg_catalog.timestamptz_eq_timestamp, leftarg = timestamp with time zone, rightarg = timestamp, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp with time zone, timestamp) is 'equal';

alter operator pg_catalog.=(timestamp with time zone, timestamp) owner to "kim-uijin";

create operator pg_catalog.= (procedure = pg_catalog.timestamp_eq_timestamptz, leftarg = timestamp, rightarg = timestamp with time zone, commutator = pg_catalog.=, negator = pg_catalog.<>, join = pg_catalog.eqjoinsel, restrict = pg_catalog.eqsel, merges);

comment on operator pg_catalog.=(timestamp, timestamp with time zone) is 'equal';

alter operator pg_catalog.=(timestamp, timestamp with time zone) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.bpchar_pattern_le, leftarg = char, rightarg = char, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(char, char) is 'less than or equal';

alter operator pg_catalog.~<=~(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = pg_catalog.bpchar_pattern_ge, leftarg = char, rightarg = char, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(char, char) is 'greater than or equal';

alter operator pg_catalog.~>=~(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = pg_catalog.bpchar_pattern_lt, leftarg = char, rightarg = char, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(char, char) is 'less than';

alter operator pg_catalog.~<~(char, char) owner to "kim-uijin";

create operator pg_catalog.~>~ (procedure = pg_catalog.bpchar_pattern_gt, leftarg = char, rightarg = char, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(char, char) is 'greater than';

alter operator pg_catalog.~>~(char, char) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~<=~ (procedure = pg_catalog.text_pattern_le, leftarg = text, rightarg = text, commutator = pg_catalog.~>=~, negator = pg_catalog.~>~, join = pg_catalog.scalarlejoinsel, restrict = pg_catalog.scalarlesel);

comment on operator pg_catalog.~<=~(text, text) is 'less than or equal';

alter operator pg_catalog.~<=~(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~>=~ (procedure = pg_catalog.text_pattern_ge, leftarg = text, rightarg = text, commutator = pg_catalog.~<=~, negator = pg_catalog.~<~, join = pg_catalog.scalargejoinsel, restrict = pg_catalog.scalargesel);

comment on operator pg_catalog.~>=~(text, text) is 'greater than or equal';

alter operator pg_catalog.~>=~(text, text) owner to "kim-uijin";

-- Cyclic dependencies found

create operator pg_catalog.~<~ (procedure = pg_catalog.text_pattern_lt, leftarg = text, rightarg = text, commutator = pg_catalog.~>~, negator = pg_catalog.~>=~, join = pg_catalog.scalarltjoinsel, restrict = pg_catalog.scalarltsel);

comment on operator pg_catalog.~<~(text, text) is 'less than';

alter operator pg_catalog.~<~(text, text) owner to "kim-uijin";

create operator pg_catalog.~>~ (procedure = pg_catalog.text_pattern_gt, leftarg = text, rightarg = text, commutator = pg_catalog.~<~, negator = pg_catalog.~<=~, join = pg_catalog.scalargtjoinsel, restrict = pg_catalog.scalargtsel);

comment on operator pg_catalog.~>~(text, text) is 'greater than';

alter operator pg_catalog.~>~(text, text) owner to "kim-uijin";

